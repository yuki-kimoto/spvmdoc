    <div class="container">
      <div>
        <a href="/">SPVMドキュメント</a> &gt SPVM言語仕様
      </div>
      <h2>名前</h2>
      <p>
        SPVM::Guides::LanguageSpecification - SPVM 1.0 言語仕様
      </p>
      <p>
        最終更新日 2019年11月4日 (SPVM言語仕様は、現在95%の完成度)
      </p>
      
      <h2 id="language-summary">説明</a></h2>
      <p>
        <b>SPVM 1.0の言語仕様</b>がこのドキュメントには記述されています。SPVMは、1.0のリリースに向けて、ベータテスト中です。言語仕様は、警告なく変更されることがあります。
      </p>
      <p>
このドキュメントでは、SPVM 1.0言語仕様について説明します。
SPVMは1.0リリースのベータテスト中です。
言語仕様は警告なしに変更される場合があります。
      </p>

      <p>
SPVM言語は、Perlから使用するように設計されています。 PerlはSPVMサブルーチンを呼び出すことができます。
      </p>

      <p>
SPVM言語は、高速な配列操作と高速な数値計算を提供します。
      </p>

      <p>
SPVMサブルーチンは、SPVMランタイムによって実行されます。共有ライブラリまたはDLLに変換できます。
      </p>

      <p>
SPVM言語はマシンコードに変換でき、単一の実行可能ファイルとして実行できます。
      </p>

      <p>
実行可能ファイルには、Unix / Linux / macOS / ios実行可能ファイルだけでなく、Windowsネイティブな実行ファイルも含みます。
      </p>
      
      <h2 id="language-c99">C99準拠</h2><!-- 2019/2/27 almost ok -->
      <ul class="list">
        <li><a href="#language-c99-spec">C99準拠のコンパイラとランタイム</a>
        <li><a href="#language-c99-type">C99との型の対応</a>
      </ul>
      
      <h3 id="language-c99-spec">C99準拠のコンパイラとランタイム</h3><!-- 2019/2/27 almost ok -->
      <p>
        SPVMコンパイラおよびSPVMランタイムのソースコードは、<b>C言語で書かれ、C99に準拠</b>します。
      </p>
      <p>
        このことは、ユーザーが、C99以外のCのバージョン(C11、GNU拡張など)や、C++で書かれたコードをSPVMから呼び出せないという意味ではないので注意してください。SPVMのコンパイラとランタイムが、C99に準拠する必要があるという意味です。
      </p>
      <h3 id="language-c99-type">C99との型の対応</h3><!-- 2019/2/27 almost ok -->
      <p>
        SPVMの型は、C99の次の型と完全に一致します。
      </p>
      <table>
        <tr>
          <th>
            <b>SPVMの型</b>
          </th>
          <th>
            <b>C99の型</b>
          </th>
          <th>
            <b>説明</b>
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            int8_t
          </td>
          <td>
            SPVMの<a href="#language-type-byte">byte型</a>は、C99のint8_t型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            int16_t
          </td>
          <td>
            SPVMの<a href="#language-type-short">short型</a>は、C99のint16_t型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            int32_t
          </td>
          <td>
            SPVMの<a href="#language-type-int">int型</a>は、C99のint32_t型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            int64_t
          </td>
          <td>
            SPVMの<a href="#language-type-long">long型</a>は、C99のint64_t型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            float
          </td>
          <td>
            SPVMの<a href="#language-type-float">float型</a>は、C99のfloat型に一致します。
          </td>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            double
          </td>
          <td>
            SPVMの<a href="#language-type-double">double型</a>は、C99のdouble型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>オブジェクト型</b>
          </td>
          <td>
            void*
          </td>
          <td>
            SPVMの<a href="#language-type-object">オブジェクト型</a>は、C99のvoid*型に一致します。
          </td>
        </tr>
        <tr>
          <td>
            <b>複数数値型</b>
          </td>
          <td>
            複数数値型のフィールドの型と個数が一致する数値の配列型
          </td>
          <td>
            <p>
              たとえば<a href="#language-type-multi-numeric">複数数値型</a>が
            </p>
            <p>
              package Point_2i : mulnum_t { has x : int; has y : int; }
            </p>
            <p>
              として定義されていた場合は
            </p>
            <p>
              C99の「int32_t var[2];」で宣言された型に一致します。
            </p>
          </td>
        </tr>
      </table>
      
      <h2 id="language-parser">構文解析</h2>
      <ul class="list">
        <li><a href="#language-parser-lalr">LALR(1)法</a>
        <li><a href="#language-parser-component">構成要素</a>
        <li><a href="#language-parser-line-terminater">行終端</a>
        <li><a href="#language-parser-space-character">空白文字</a>
        <li><a href="#language-parser-identifier">識別子</a>
        <li><a href="#language-parser-separator">区切り文字</a>
        <li><a href="#language-parser-operator">演算子</a>
        <li><a href="#language-parser-table">構文解析表</a></li>
      </ul>
      
      <h3 id="language-parser-lalr">LALR(1)法</h3><!-- 2019/2/27 almost ok -->
      <p>
        SPVMのソースコードは、LALR(1)法によって解析できます。yacc/bisonで生成されたパーサージェネレータによって解析することができます。
      </p>
      
      <h3 id="language-parser-component">構成要素</h3><!-- 2019/2/27 almost ok -->
      <p>
        SPVMのソースコードは「<a href="#language-parser-space-character">空白文字</a>」「<a href="#language-comment">コメント</a>」「<a href="#language-pod">POD</a>」「<a href="#language-literal">リテラル</a>」「<a href="#language-parser-identifier">識別子</a>」「<a href="#language-parser-keyword">キーワード</a>」「<a href="#language-parser-separator">区切り文字</a>」「<a href="#language-parser-operator">演算子</a>」で構成されます。
      </p>
      
      <h3 id="language-parser-line-terminater">行終端</h3><!-- 2019/7/1 check -->
      <p>
        SPVMのソースコードの行終端は、ASCIIコードの「LF」「CR」「CR LF」です。
      </p>
      <p>
        行終端が現れたときは、適切に行番号がインクリメントされます。ソースコード中の行終端は、ASCIIコードの「LF」として扱われます。
      </p>
      
      <h3 id="language-parser-space-character">空白文字</h3><!-- 2019/2/27 almost ok -->
      <p>
        SPVMにおける空白文字はASCIIコードの「SP」「HT」「FF」と「<a href="#language-parser-line-terminater">行終端</a>」です。
      </p>
      <p>
        空白文字はソースコード上では意味を持ちません。
      </p>
      
      <h3 id="language-parser-identifier">識別子</h3><!-- 2019/2/27 maybe ok -->
      <p>
        SPVMにおける識別子は「パッケージ名」「サブルーチン名」「フィールド名」「パッケージ変数名」「レキシカル変数名」です。
      </p>
      <ul class="list">
        <li><a href="#language-parser-identifier-package-name">パッケージ名</a></li>
        <li><a href="#language-parser-identifier-sub-name">サブルーチン名</a></li>
        <li><a href="#language-parser-identifier-field-name">フィールド名</a></li>
        <li><a href="#language-parser-identifier-package-var-name">パッケージ変数名</a></li>
        <li><a href="#language-parser-identifier-lex-var-name">レキシカル変数名</a></li>
      </ul>
      
      <h4 id="language-parser-identifier-package-name">パッケージ名</h4><!-- 2019/2/27 almost ok -->
      <p>
        パッケージ名は、「ASCIIコードにおけるアルファベットあるいはアンダースコアの一文字以上」と「::」の組み合わせです。「::」は、含まれていなくてもかまいません。
      </p>
      <p>
        パッケージ名は、ASCIIコードにおけるアルファベットの大文字で始まらなければなりません。
      </p>
      <p>
        「::」を連続して続けることはできません。最後は「::」で終わってはいけません。
      </p>
      <p>
        アンダースコアは、二つ以上続いてはいけません。
      </p>
<pre>
# 正しいパッケージ名
Foo
Foo::Bar
Foo::Bar::Baz
Foo::bar
Foo_Bar::Baz_Baz

# 不正なパッケージ名
foo
Foo::Bar::
Foo__Bar
</pre>

      <h4 id="language-parser-identifier-sub-name">サブルーチン名</h4><!-- 2019/2/27 almost ok -->
      <p>
        サブルーチン名は、「ASCIIコードにおけるアルファベットあるいはアンダースコアの一文字以上」です。
      </p>
      <p>
        アンダースコアは、二つ以上続いてはいけません。
      </p>
<pre>
# 正しいサブルーチン名
FOO
FOO_BAR
foo
foo_bar
_foo
_foo_bar_

# 不正なサブルーチン名
foo__bar
</pre>

      <h4 id="language-parser-identifier-field-name">フィールド名</h4><!-- 2019/2/27 almost ok -->
      <p>
        フィールド名は、「ASCIIコードにおけるアルファベットあるいはアンダースコアの一文字以上」です。
      </p>
      <p>
        アンダースコアは、二つ以上続いてはいけません。
      </p>
<pre>
# 正しいフィールド名
FOO
FOO_BAR
foo
foo_bar
_foo
_foo_bar_

# 不正なフィールド名
foo__bar
</pre>

      <h4 id="language-parser-identifier-package-var-name">パッケージ変数名</h4><!-- 2019/2/27 maybe ok -->
      <p>
        パッケージ変数名は、先頭が「$」で始まり、その後「ASCIIコードにおけるアルファベットあるいはアンダースコアの一文字以上」と「::」の組み合わせが続きます。「::」は含まれていなくてもかまいません。
      </p>
      <p>
        アンダースコアは、二つ以上続いてはいけません。
      </p>
<pre>
# 正しいパッケージ変数名
$FOO::BAR
$Foo::Bar
$FOO
$FOO_BAR
$foo

# 不正なパッケージ変数名
$FOO__BAR
$
</pre>

      <h4 id="language-parser-identifier-lex-var-name">レキシカル変数名</h4><!-- 2019/2/27 maybe ok -->
      <p>
        レキシカル変数名は、先頭が「$」で始まり、その後「ASCIIコードにおけるアルファベットあるいはアンダースコアの一文字以上」が続きます。
      </p>
      <p>
        アンダースコアは、二つ以上続いてはいけません。
      </p>
<pre>
# 正しいレキシカル変数名
$foo
$foo_bar
$_foo
$FOO

# 不正なレキシカル変数名
$foo__bar
$
</pre>

      <h3 id="language-parser-keyword">キーワード</h3><!-- 2019/2/27 maybe ok -->
      <p>
        SPVMにおけるキーワードは以下です。
      </p>
<pre>
allow byte BEGIN case die warn print default double elsif else enum eq
eval for float gt ge has if callback_t isa int last break length
lt le long my native ne next new our object package private
public precompile pointer_t return require rw ro self switch
sub string short scalar undef unless use void mulnum_t while
weaken wo __END__ __PACKAGE__ __FILE__ __LINE__
</pre>

      <h3 id="language-parser-separator">区切り文字</h3><!-- 2019/2/27 almost ok -->
      <p>
        SPVMにおける区切り文字は以下です。
      </p>
<pre>
( ) { } [ ] ; , -> =>
</pre>

      <h3 id="language-parser-operator">演算子</h3><!-- 2019/2/27 almost ok -->
      <p>
        SPVMにおける演算子は以下です。
      </p>
<pre>
=   >   <   !   ~
==  <=  >=  !=  &&  ||  ++  --
+   -   *   /   &   |   ^   %   <<   >>   >>>
+=  -=  *=  /=  &=  |=  ^=  %=  <<=  >>=  >>>=
\   $   @   .   .=
</pre>

      <h3 id="language-parser-table">構文解析表</h3><!-- 2019/2/27 not ok -->
      <p>
        SPVMの文法を表現する、yacc/bisonにおける構文解析表と、トークンとキーワード・演算子の対応表です。
      </p>
      <p>
        <b>SPVM文法のyacc/bisonにおける構文解析表</b>
      </p>

<pre>
%token <opval> PACKAGE HAS SUB OUR ENUM MY SELF USE REQUIRE ALLOW
%token <opval> DESCRIPTOR
%token <opval> IF UNLESS ELSIF ELSE FOR WHILE LAST NEXT SWITCH CASE DEFAULT BREAK EVAL
%token <opval> NAME VAR_NAME CONSTANT EXCEPTION_VAR
%token <opval> UNDEF VOID BYTE SHORT INT LONG FLOAT DOUBLE STRING OBJECT
%token <opval> DOT3 FATCAMMA RW RO WO BEGIN NEW
%token <opval> RETURN WEAKEN DIE WARN CURRENT_PACKAGE UNWEAKEN '[' '{' '('

%type <opval> grammar
%type <opval> opt_packages packages package package_block refcnt
%type <opval> opt_declarations declarations declaration
%type <opval> enumeration enumeration_block opt_enumeration_values enumeration_values enumeration_value
%type <opval> sub cb_obj opt_args args arg invocant has use require our string_length
%type <opval> opt_descriptors descriptors sub_names opt_sub_names
%type <opval> opt_statements statements statement if_statement else_statement 
%type <opval> for_statement while_statement switch_statement case_statement default_statement
%type <opval> block eval_block begin_block switch_block if_require_statement
%type <opval> unary_op binary_op num_comparison_op str_comparison_op isa logical_op
%type <opval> call_sub opt_vaarg
%type <opval> array_access field_access weaken_field unweaken_field isweak_field convert array_length
%type <opval> deref ref assign inc dec allow
%type <opval> new array_init
%type <opval> my_var var
%type <opval> expression opt_expressions expressions opt_expression case_statements
%type <opval> field_name sub_name
%type <opval> type basic_type array_type array_type_with_length ref_type  type_or_void

%right <opval> ASSIGN SPECIAL_ASSIGN
%left <opval> LOGICAL_OR
%left <opval> LOGICAL_AND
%left <opval> BIT_OR BIT_XOR
%left <opval> '&'
%nonassoc <opval> NUMEQ NUMNE STREQ STRNE
%nonassoc <opval> NUMGT NUMGE NUMLT NUMLE STRGT STRGE STRLT STRLE ISA
%left <opval> SHIFT
%left <opval> '+' '-' '.'
%left <opval> MULTIPLY DIVIDE REMAINDER
%right <opval> LOGICAL_NOT BIT_NOT '@' REF DEREF PLUS MINUS CONVERT SCALAR LENGTH ISWEAK REFCNT
%nonassoc <opval> INC DEC
%left <opval> ARROW

%%

grammar
  : opt_packages

opt_packages
  :	/* Empty */
  |	packages
  
packages
  : packages package
  | package

package
  : PACKAGE basic_type package_block
  | PACKAGE basic_type ':' opt_descriptors package_block
  | PACKAGE basic_type ';'
  | PACKAGE basic_type ':' opt_descriptors ';'

package_block
  : '{' opt_declarations '}'

opt_declarations
  :	/* Empty */
  |	declarations

declarations
  : declarations declaration
  | declaration

declaration
  : has
  | sub
  | enumeration
  | our ';'
  | use
  | allow
  | begin_block

begin_block
  : BEGIN block
    
use
  : USE basic_type ';'
  | USE basic_type '(' opt_sub_names ')' ';'

require
  : REQUIRE basic_type

allow
  : ALLOW basic_type ';'

enumeration
  : opt_descriptors ENUM enumeration_block

enumeration_block 
  : '{' opt_enumeration_values '}'

opt_enumeration_values
  :	/* Empty */
  |	enumeration_values
    
enumeration_values
  : enumeration_values ',' enumeration_value 
  | enumeration_values ','
  | enumeration_value
  
enumeration_value
  : sub_name
  | sub_name ASSIGN CONSTANT

our
  : OUR PACKAGE_VAR_NAME ':' opt_descriptors type

has
  : HAS field_name ':' opt_descriptors type ';'

sub
  : opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' block
  | opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' ';'

cb_obj
  : opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block
  | '[' args ']' opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block

opt_args
  :	/* Empty */
  |	args
  | invocant
  | invocant ',' args

args
  : args ',' arg
  | args ','
  | arg

arg
  : var ':' type

opt_vaarg
  : /* Empty */
  | DOT3

invocant
  : var ':' SELF

opt_descriptors
  :	/* Empty */
  |	descriptors
    
descriptors
  : descriptors DESCRIPTOR
  | DESCRIPTOR

opt_statements
  :	/* Empty */
  |	statements
    
statements
  : statements statement 
  | statement

statement
  : if_statement
  | for_statement
  | while_statement
  | block
  | switch_statement
  | case_statement
  | default_statement
  | eval_block
  | if_require_statement
  | expression ';'
  | LAST ';'
  | NEXT ';'
  | RETURN ';'
  | RETURN expression ';'
  | DIE ';'
  | DIE expression ';'
  | WARN ';'
  | WARN expression ';'
  | PRINT expression ';'
  | weaken_field ';'
  | unweaken_field ';'
  | ';'

for_statement
  : FOR '(' opt_expression ';' expression ';' opt_expression ')' block

while_statement
  : WHILE '(' expression ')' block

switch_statement
  : SWITCH '(' expression ')' switch_block

switch_block
  : '{' case_statements '}'
  | '{' case_statements default_statement '}'

case_statements
  : case_statements case_statement
  | case_statement

case_statement
  : CASE expression ':' block
  | CASE expression ':'

default_statement
  : DEFAULT ':' block
  | DEFAULT ':'

if_require_statement
  : IF '(' require ')' block
  | IF '(' require ')' block ELSE block

if_statement
  : IF '(' expression ')' block else_statement
  | UNLESS '(' expression ')' block else_statement

else_statement
  : /* NULL */
  | ELSE block
  | ELSIF '(' expression ')' block else_statement

block 
  : '{' opt_statements '}'

eval_block
  : EVAL block ';'

opt_expressions
  :	/* Empty */
  |	expressions
    
opt_expression
  : /* Empty */
  | expression

expression
  : var
  | EXCEPTION_VAR
  | package_var_access
  | CONSTANT
  | UNDEF
  | call_sub
  | field_access
  | array_access
  | convert
  | new
  | array_init
  | array_length
  | string_length
  | refcnt
  | my_var
  | binary_op
  | unary_op
  | ref
  | deref
  | assign
  | inc
  | dec
  | '(' expressions ')'
  | CURRENT_PACKAGE
  | isweak_field
  | num_comparison_op
  | str_comparison_op
  | isa
  | logical_op

refcnt
  : REFCNT var
expressions
  : expressions ',' expression
  | expressions ','
  | expression

unary_op
  : '+' expression %prec PLUS
  | '-' expression %prec MINUS
  | BIT_NOT expression

inc
  : INC expression
  | expression INC

dec
  : DEC expression
  | expression DEC

binary_op
  : expression '+' expression
  | expression '-' expression
  | expression MULTIPLY expression
  | expression DIVIDE expression
  | expression REMAINDER expression
  | expression BIT_XOR expression
  | expression '&' expression
  | expression BIT_OR expression
  | expression SHIFT expression
  | expression '.' expression

num_comparison_op
  : expression NUMEQ expression
  | expression NUMNE expression
  | expression NUMGT expression
  | expression NUMGE expression
  | expression NUMLT expression
  | expression NUMLE expression

str_comparison_op
  : expression STREQ expression
  | expression STRNE expression
  | expression STRGT expression
  | expression STRGE expression
  | expression STRLT expression
  | expression STRLE expression
    
isa
  : expression ISA type

logical_op
  : expression LOGICAL_OR expression
  | expression LOGICAL_AND expression
  | LOGICAL_NOT expression

assign
  : expression ASSIGN expression
  | expression SPECIAL_ASSIGN expression

new
  : NEW basic_type
  | NEW array_type_with_length
  | cb_obj

array_init
  : '[' opt_expressions ']'

convert
  : '(' type ')' expression %prec CONVERT

array_access
  : expression ARROW '[' expression ']'
  | array_access '[' expression ']'
  | field_access '[' expression ']'

call_sub
  : NAME '(' opt_expressions  ')'
  | basic_type ARROW sub_name '(' opt_expressions  ')'
  | basic_type ARROW sub_name
  | expression ARROW sub_name '(' opt_expressions ')'
  | expression ARROW sub_name
  | expression ARROW '(' opt_expressions ')'

field_access
  : expression ARROW '{' field_name '}'
  | field_access '{' field_name '}'
  | array_access '{' field_name '}'

weaken_field
  : WEAKEN var ARROW '{' field_name '}'

unweaken_field
  : UNWEAKEN var ARROW '{' field_name '}'

isweak_field
  : ISWEAK var ARROW '{' field_name '}'

array_length
  : '@' expression
  | '@' '{' expression '}'
  | SCALAR '@' expression
  | SCALAR '@' '{' expression '}'

string_length
  : LENGTH expression
    
deref
  : DEREF var

ref
  : REF var

my_var
  : MY var ':' type
  | MY var

var
  : VAR_NAME

package_var_access
  : PACKAGE_VAR_NAME

type
  : basic_type
  | array_type
  | ref_type

basic_type
  : NAME
  | BYTE
  | SHORT
  | INT
  | LONG
  | FLOAT
  | DOUBLE
  | OBJECT
  | STRING

ref_type
  : basic_type '&'
array_type
  : basic_type '[' ']'
  | array_type '[' ']'

array_type_with_length
  : basic_type '[' expression ']'
  | array_type '[' expression ']'

type_or_void
  : type
  | VOID

field_name
  : NAME

sub_name
  : NAME

opt_sub_names
  :	/* Empty */
  |	sub_names

sub_names
  : sub_names ',' sub_name
  | sub_names ','
  | sub_name
%%
</pre>
      <p>
        <b>トークンとキーワード・演算子の対応表</b>
      </p>
      <table>
        <tr>
          <th>トークン</th><th>キーワード・演算子</th>
        </tr>
        <tr>
          <td>PACKAGE</td><td>package</td>
        </tr>
        <tr>
          <td>SUB</td><td>sub</td>
        </tr>
        <tr>
          <td>OUR</td><td>our</td>
        </tr>
        <tr>
          <td>ENUM</td><td>enum</td>
        </tr>
        <tr>
          <td>MY</td><td>my</td>
        </tr>
        <tr>
          <td>SELF</td><td>self</td>
        </tr>
        <tr>
          <td>USE</td><td>use</td>
        </tr>
        <tr>
          <td>REQUIRE</td><td>require</td>
        </tr>
        <tr>
          <td>ALLOW</td><td>allow</td>
        </tr>
        <tr>
          <td>DESCRIPTOR</td><td>descriptor</td>
        </tr>
        <tr>
          <td>IF</td><td>if</td>
        </tr>
        <tr>
          <td>UNLESS</td><td>unless</td>
        </tr>
        <tr>
          <td>ELSIF</td><td>elsif</td>
        </tr>
        <tr>
          <td>ELSE</td><td>else</td>
        </tr>
        <tr>
          <td>FOR</td><td>for</td>
        </tr>
        <tr>
          <td>WHILE</td><td>while</td>
        </tr>
        <tr>
          <td>LAST</td><td>last</td>
        </tr>
        <tr>
          <td>BREAK</td><td>break</td>
        </tr>
        <tr>
          <td>NEXT</td><td>next</td>
        </tr>
        <tr>
          <td>SWITCH</td><td>switch</td>
        </tr>
        <tr>
          <td>CASE</td><td>case</td>
        </tr>
        <tr>
          <td>DEFAULT</td><td>default</td>
        </tr>
        <tr>
          <td>EVAL</td><td>eval</td>
        </tr>
        <tr>
          <td>NAME</td><td>name</td>
        </tr>
        <tr>
          <td>VAR</td><td>var</td>
        </tr>
        <tr>
          <td>CONSTANT</td><td>リテラル</td>
        </tr>
        <tr>
          <td>PACKAGE_VAR_NAME</td><td>パッケージ変数名</td>
        </tr>
        <tr>
          <td>EXCEPTION_VAR</td><td>$@</td>
        </tr>
        <tr>
          <td>UNDEF</td><td>undef</td>
        </tr>
        <tr>
          <td>VOID</td><td>void</td>
        </tr>
        <tr>
          <td>BYTE</td><td>byte</td>
        </tr>
        <tr>
          <td>SHORT</td><td>short</td>
        </tr>
        <tr>
          <td>INT</td><td>int</td>
        </tr>
        <tr>
          <td>LONG</td><td>long</td>
        </tr>
        <tr>
          <td>FLOAT</td><td>float</td>
        </tr>
        <tr>
          <td>DOUBLE</td><td>double</td>
        </tr>
        <tr>
          <td>STRING</td><td>string</td>
        </tr>
        <tr>
          <td>OBJECT</td><td>object</td>
        </tr>
        <tr>
          <td>DOT3</td><td>...</td>
        </tr>
        <tr>
          <td>FATCAMMA</td><td>=></td>
        </tr>
        <tr>
          <td>RW</td><td>rw</td>
        </tr>
        <tr>
          <td>RO</td><td>ro</td>
        </tr>
        <tr>
          <td>WO</td><td>wo</td>
        </tr>
        <tr>
          <td>BEGIN</td><td>BEGIN</td>
        </tr>
        <tr>
          <td>NEW</td><td>new</td>
        </tr>
        <tr>
          <td>RETURN</td><td>return</td>
        </tr>
        <tr>
          <td>WEAKEN</td><td>weaken</td>
        </tr>
        <tr>
          <td>DIE</td><td>die</td>
        </tr>
        <tr>
          <td>WARN</td><td>warn</td>
        </tr>
        <tr>
          <td>PRINT</td><td>print</td>
        </tr>
        <tr>
          <td>CURRENT_PACKAGE</td><td>__PACKAGE__</td>
        </tr>
        <tr>
          <td>UNWEAKEN</td><td>unweaken</td>
        </tr>
        <tr>
          <td>ASSIGN</td><td>=</td>
        </tr>
        <tr>
          <td>SPECIAL_ASSIGN</td><td>+=  -=  *=  /=  &=  |=  ^=  %=  &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;= .=</td>
        </tr>
        <tr>
          <td>LOGICAL_OR</td><td>||</td>
        </tr>
        <tr>
          <td>LOGICAL_AND</td><td>&&</td>
        </tr>
        <tr>
          <td>BIT_OR</td><td>|</td>
        </tr>
        <tr>
          <td>BIT_XOR</td><td>&</td>
        </tr>
        <tr>
          <td>NUMEQ</td><td>==</td>
        </tr>
        <tr>
          <td>NUMNE</td><td>!=</td>
        </tr>
        <tr>
          <td>STREQ</td><td>eq</td>
        </tr>
        <tr>
          <td>STRNE</td><td>ne</td>
        </tr>
        <tr>
          <td>NUMGT</td><td>&gt;</td>
        </tr>
        <tr>
          <td>NUMGE</td><td>&gt;=</td>
        </tr>
        <tr>
          <td>NUMLT</td><td>&lt;</td>
        </tr>
        <tr>
          <td>NUMLE</td><td>&lt;=</td>
        </tr>
        <tr>
          <td>STRGT</td><td>gt</td>
        </tr>
        <tr>
          <td>STRGE</td><td>ge</td>
        </tr>
        <tr>
          <td>STRLT</td><td>lt</td>
        </tr>
        <tr>
          <td>STRLE</td><td>le</td>
        </tr>
        <tr>
          <td>ISA</td><td>isa</td>
        </tr>
        <tr>
          <td>SHIFT</td><td>&lt;&lt;  &gt;&gt;  &gt;&gt;&gt;</td>
        </tr>
        <tr>
          <td>MULTIPLY</td><td>*</td>
        </tr>
        <tr>
          <td>DIVIDE</td><td>/</td>
        </tr>
        <tr>
          <td>REMAINDER</td><td>%</td>
        </tr>
        <tr>
          <td>LOGICAL_NOT</td><td>!</td>
        </tr>
        <tr>
          <td>BIT_NOT</td><td>~</td>
        </tr>
        <tr>
          <td>REF</td><td>\</td>
        </tr>
        <tr>
          <td>DEREF</td><td>$</td>
        </tr>
        <tr>
          <td>PLUS</td><td>+</td>
        </tr>
        <tr>
          <td>MINUS</td><td>-</td>
        </tr>
        <tr>
          <td>CONVERT</td><td>(型名)</td>
        </tr>
        <tr>
          <td>SCALAR</td><td>scalar</td>
        </tr>
        <tr>
          <td>LENGTH</td><td>length</td>
        </tr>
        <tr>
          <td>ISWEAK</td><td>isweak</td>
        </tr>
        <tr>
          <td>REFCNT</td><td>refcnt</td>
        </tr>
        <tr>
          <td>INC</td><td>++</td>
        </tr>
        <tr>
          <td>DEC</td><td>--</td>
        </tr>
        <tr>
          <td>ARROW</td><td>-></td>
        </tr>
      </table>

      <h2 id="language-comment">コメント</h2>
      <p>
        コメントは「#」で始まり<a href="#language-parser-line-terminater">行終端</a>で終わります。
      </p>
<pre>
# コメント
</pre>
      <p>
        コメントは、プログラムの実行において無視されます。
      </p>
      
      <h2 id="language-pod">POD</h2>
      <p>
        POD(プレーンオールドドキュメント)は、簡単なドキュメントを記載するための機能です。
      </p>
      <p>
        複数行のコメントを記述する方法として利用できます。
      </p>
      <p>
        PODは、行頭が「=」で始まり、その後ろに、0文字以上の任意の文字列が続き<a href="#language-parser-line-terminater">行終端</a>で終わる行から始まります。
      </p>
      <p>
        PODは、行頭が「=cut」で、<a href="#language-parser-line-terminater">行終端</a>で終わる行で終わります。この行が、存在しなかった場合は、ソースコードの終わりまでが、PODになります。
      </p>
      <p>
        <b>PODのサンプル</b>
      </p>
<pre>
=pod

複数行
コメント

=cut
</pre>

<pre>
=head1

複数行
コメント

=cut
</pre>
      <p>
        PODは、プログラムの実行において無視されます。
      </p>

      <h2 id="language-package">パッケージ</h2>
      <ul class="list">
        <li><a href="#language-package-definition">パッケージの定義</a></li>
        <li><a href="#language-package-destructor">デストラクタ</a></li>
      </ul>
      
      <h3 id="language-package-definition">パッケージの定義</h3>
      <p>
        パッケージを定義するには以下の構文を使用します。
      </p>
<pre>
package パッケージ名 {

}
</pre>
      <p>
        パッケージ名は「大文字」で始まる必要があります。パッケージ名には「::」を使用することができます。
      </p>
<p>
Foo
Foo::Bar
Foo::Bar::Baz
</p>
      <p>
        「パッケージ名」の後に「:」をつなげてその後ろに「デスクリプタ」を指定することができます。
      </p>
<pre>
package パッケージ名 : デスクリプタ {

}
</pre>
      <p>
        パッケージの定義のサンプルです。
      </p>
<pre>
# パッケージ名のみ
package Point {

}
</pre>

<pre>
# パッケージ名とデスクリプタ
package Point : public {

}
</pre>
      
      <p id="language-package-descriptor">
        <b>パッケージデスクリプタ</b>
      </p>
      <p>
        パッケージで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このパッケージに対するnewキーワードが他のパッケージから利用できます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このパッケージに対するnewキーワードが他のパッケージから利用できません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>callback_t</b>
          </td>
          <td>
            このパッケージは「インターフェイス型」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>mulnum_t</b>
          </td>
          <td>
            このパッケージは「<a href="#language-type-multi-numeric">複数数値型</a>」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>pointer_t</b>
          </td>
          <td>
            このパッケージは「ポインタ型」になります。「ポインタ型」は「クラス型」の一種です。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        「callback_t」「mulnum_t」「pointer_t」のひとつより多くが同時に指定されている場合は、コンパイル時エラーが発生します。
      </p>
      
      <p>
        <b>パッケージ内部で定義できるもの</b>
      </p>
      <p>
        パッケージ内部では<b>「use」</b><b>「パッケージ変数」</b><b>「フィールド」</b><b>「列挙」</b><b>「サブルーチン」</b>が定義できます。
      </p>
<pre>
package Foo {
  # use
  use Point;
  
  # パッケージ変数
  our $VAR int;
  
  # フィールド
  has var : int;
  
  # 列挙
  enum {
    CONST_VAL
  }
  
  # サブルーチン
  sub foo : int ($num : int) {
  
  }
}
</pre>

      <h3 id="language-package-destructor">デストラクタ</h3>
      <p>
        パッケージが<a href="#language-type-class">クラス型</a>である場合は、デストラクタを定義することができます。
      </p>
      <p>
        デストラクタとは、オブジェクトが解放されるときに実行される特別な<a href="#language-sub">サブルーチン</a>のことです。
      </p>
      <p>
        デストラクタの名前は「DESTROY」でなければなりません。
      </p>
      <p>
        デストラクタの戻り値の型は、<a href="#language-type-void">void型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デストラクタの引数は、ひとつで、<a href="#language-type-self">self型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
<pre>
sub DESTROY : void ($self : self) {
  
}
</pre>
      <p>
        デストラクタの中で<a href="#language-exception-occur">例外の発生</a>が起こった場合は、プログラムは終了せず、例外メッセージが、標準エラーに出力されます。
      </p>
      <p>
        <b>デストラクタのサンプル</b>
      </p>
      <p>
        デストラクタのサンプルです。
      </p>
<pre>
package Foo {
  sub new : Foo {
    return new Foo;
  }
  
  sub DESTROY : void ($self : self) {
    print "DESTROY";
  }
}
</pre>
      
      <h2 id="language-module">モジュール</h2>
      <ul class="list">
        <li href="#language-module-summary">モジュールの概要</li>
        <li href="#language-module-file-name">モジュールのファイル名</li>
        <li href="#language-module-use">モジュールの読み込み</li>
        <li href="#language-module-if-require">選択的なモジュールの読み込み</li>
      </ul>
      
      <h3 id="language-module-summary">モジュールの概要</h3>
      <p>
        モジュールとは、SPVMのソースコードとして読み込むことができるひとつのファイルのことをいいます。
      </p>
<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}
</pre>
      <p>
        モジュールには、複数のパッケージを含むことができます。
      </p>
<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}

package Foo::Bar::Baz {

}
</pre>

      <h3 id="language-module-file-name">モジュールのファイル名</h3>
      <p>
        モジュールは、モジュールの読み込みパスに、以下のファイル名で配置される必要があります。
      </p>
      <p>
        「::」を「/」に変更。末尾に「.spvm」をつける。
      </p>
<pre>
Foo.spvm
Foo/Bar.spvm
Foo/Bar/Baz.spvm
</pre>

      <h3 id="language-module-use">モジュールの読み込み</h3>
      <p>
        モジュールを読み込むには、useキーワードを使用します。
      </p>
<pre>
use Foo;
use Foo::Bar;
</pre>
      <p>
        モジュールはコンパイル時に読み込まれます。
      </p>
      <p>
        モジュールが存在しなかった場合は、コンパイルエラーになります。
      </p>
      <p>
        useキーワードは、パッケージの定義の直下で定義する必要があります。
      </p>
<pre>
package Foo {
  use Foo;
}
</pre>

      <h3 id="language-module-if-require">選択的なモジュールの読み込み</h3>
      <p>
        SPVMでは、モジュールが、検索パスに存在する場合だけ読み込み、そうでない場合は、ブロックの内部が存在しないことにできるif require文があります。これはC言語の「#ifdef」の一部の機能を実現するために設計されました。
      </p>
<pre>
if (require Foo) {
  
}
</pre>
      <p>
        if require文はelse文を続けることができます。elsif文は、指定できないので注意してください。
      </p>
<pre>
if (require Foo) {
  
}
else {
  
}
</pre>
      
      <p>
        一つの例を見てみましょう。以下の例で、Fooが存在しない場合は、コンパイルエラーにはならず、ifブロックがないことになります。そのため「$foo = new Foo;」は、存在しないことになっているので、コンパイルエラーになりません。elseブロックは存在するので、警告がされます。
      </p>
<pre>
my $foo : object;
if (require Foo) {
  $foo = new Foo;
}
else {
  warn "Warning: Can't load Foo";
}
</pre>

      <h2 id="language-allow-access">アクセス許可</h2>
      <p>
        デフォルトでは、プライベートなサブルーチン、フィールド、パッケージ変数には、パッケージの外部からは、アクセスすることができません。また、プライベートなパッケージは、パッケージの外部から、オブジェクトの生成を行うことができません。
      </p>
      <p>
        外部のパッケージに対してアクセス許可を設定すると、外部のパッケージは、プライベートなサブルーチン、フィールド、パッケージ変数にアクセスすることができ、またオブジェクトの生成を行うことができます。
      </p>
<pre>
allow パッケージ名;
</pre>
      <p>
        allowキーワードは、パッケージの定義の直下で定義する必要があります。
      </p>
<pre>
package Foo {
  allow Bar;
}
</pre>
      <p>
        この例では、Fooにおいてprivateが指定されているサブルーチン、フィールド、パッケージ変数に、Barからアクセスすることができます。また、BarからFooのオブジェクトの生成を行うことができます。
      </p>

      <h2 id="language-package-var">パッケージ変数</h2>
      <ul class="list">
        <li><a href="#language-package-var-definition">パッケージ変数の定義</a></li>
        <li><a href="#language-package-var-initial-value">パッケージ変数の初期値</a></li>
        <li><a href="#language-package-var-access">パッケージ変数へのアクセス</a></li>
      </ul>
      <h3 id="language-package-var-definition">パッケージ変数の定義</h3>
      <p>
        パッケージ変数とは、パッケージに属する、プログラムの開始から終了まで維持されるグローバル変数のことです。
      </p>
      <p>
        「our」キーワードを使用してパッケージ変数を定義することができます。
      </p>
<pre>
our パッケージ変数名 : 型名;
</pre>
      <p>
        パッケージ変数の定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        パッケージ変数の定義には「<a href="#language-type">型名</a>」が必要です。型名には「数値型」と「オブジェクト型」を指定できます。
      </p>
      <p>
        パッケージ変数名は、<a href="#language-parser-identifier-package-var-name">パッケージ変数名</a>で定義されている名前の規則に従い、かつ「::」が含まれていてはいけません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        パッケージ変数定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
      </p>
<pre>
our パッケージ変数名 : デスクリプタ 型名;
</pre>
      <p>
        <b>パッケージ変数デスクリプタ</b>
      </p>
      <p>
        パッケージ変数で指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このパッケージ変数は、外部のパッケージからアクセスできます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このパッケージ変数は、外部のパッケージからアクセスできません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>ro</b>
          </td>
          <td>
            このパッケージ変数は、読み込み用のパッケージ変数アクセッサを持ちます。パッケージ変数アクセッサ名は、パッケージ変数名から「$」を除いたものです。パッケージ変数名が「$FOO」の場合は、パッケージ変数アクセッサ名は「FOO」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>wo</b>
          </td>
          <td>
            このパッケージ変数は、書き込み用のパッケージ変数アクセッサを持ちます。パッケージ変数アクセッサ名は、「SET_パッケージ変数名から$を除いたもの」になります。パッケージ変数名が「$FOO」の場合は、パッケージ変数アクセッサ名は「SET_FOO」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>rw</b>
          </td>
          <td>
            このパッケージ変数は、読み込み用のパッケージ変数アクセッサと書き込み用のパッケージ変数アクセッサを持ちます。読み込み用のパッケージ変数アクセッサ名は「ro」で説明したものと同じです。書き込み用のパッケージ変数アクセッサ名は「wo」で説明したものと同じです。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        「ro」「wo」「rw」のひとつより多くが同時に指定されている場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        パッケージ変数アクセッサとは、パッケージ変数にアクセスするためのクラスメソッドのことです。
      </p>
      <p>
        書き込み用のパッケージ変数アクセッサの戻り値は「void型」です。
      </p>
      <p>
        SPVMのソースコードの中からパッケージ変数アクセッサが呼び出された場合は、パッケージ変数アクセッサはインライン展開されます。それ以外の場合は、インライン展開されません。
      </p>
      <p>
        <b>パッケージ変数定義のサンプル</b>
      </p>
      <p>
        パッケージ変数定義のサンプルです。
      </p>
<pre>
package Foo {
  our $NUM1 : byte;
  our $NUM2 : short;
  our $NUM3 : int;
  our $NUM4 : long;
  our $NUM5 : float;
  our $NUM6 : double;

  our $NUM_PUBLIC : public int;
  our $NUM_RO : ro int;
  our $NUM_WO : wo int;
  our $NUM_RW : rw int;
}
</pre>
      <h3 id="language-package-var-initial-value">パッケージ変数の初期値</h3>
      <p>
        パッケージ変数は、コンパイルが終了して、実行時に入る前に、<a href="#language-type-initial-value">型の初期値</a>で初期化されます。
      </p>
      <p>
        この初期値は、<a href="#language-begin-block">BEGINブロック</a>を使うことで、変更することができます。
      </p>
<pre>
package Foo {
  our $VAR : int;
  
  BEGIN {
    $VAR = 3;
  }
}
</pre>
      <h3 id="language-package-var-access">パッケージ変数へのアクセス</h3>
      <p>
        パッケージ変数へのアクセスとは、パッケージ変数にアクセスして、値を取得したり、設定したりする操作のことです。
      </p>
      <p>
        パッケージ変数の値の取得については、<a href="#language-expression-get-package-var">パッケージ変数の値の取得</a>を見てください。
      </p>
      <p>
        パッケージ変数の値の設定については、<a href="#language-expression-set-package-var">パッケージ変数の値の設定</a>を見てください。
      </p>
      
      <h2 id="language-field">フィールド</h2>
      <ul class="list">
        <li><a href="#language-field-definition">フィールドの定義</a></li>
        <li><a href="#language-field-access">フィールドへのアクセス</a></li>
      </ul>
      <h3 id="language-field-definition">フィールドの定義</h3>
      <p>
        フィールドとは「new」を使ってオブジェクト生成した場合に、オブジェクトからアクセスできるデータ領域のことです。
      </p>
      <p>
        「has」キーワードを使用してフィールドを定義することができます。
      </p>
<pre>
has フィールド名 : 型名;
</pre>
      <p>
        フィールド定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        フィールド定義には「<a href="#language-type">型名</a>」が必要です。型名には「数値型」と「オブジェクト型」を指定できます。
      </p>
      <p>
        フィールド名は、1文字以上の「a～z」「A～Z」「0～9」「_」で構成する必要があります。先頭は、数字から始めることはできません。連続した「_」を使用することはできません。
      </p>
      <p>
        フィールド名には、<a href="#language-parser-keyword">キーワード</a>と同じ名前を使用することができます。
      </p>
      <p>
        フィールド定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
      </p>
<pre>
has フィールド名 : デスクリプタ 型名;
</pre>
      <p>
        <b>フィールドデスクリプタ</b>
      </p>
      <p>
        フィールドで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            このフィールドは、外部のパッケージからアクセスできます。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            このフィールドは、外部のパッケージからアクセスできません。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>ro</b>
          </td>
          <td>
            このフィールドは、読み込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は、フィールド名と同じです。フィールド名が「foo」の場合は、フィールドアクセッサ名は「foo」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>wo</b>
          </td>
          <td>
            このフィールドは、書き込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は、「set_フィールド名」になります。フィールド名が「foo」の場合は、フィールドアクセッサ名は「set_foo」になります。
          </td>
        </tr>
        <tr>
          <td>
            <b>rw</b>
          </td>
          <td>
            このフィールドは、読み込み用のフィールドアクセッサと書き込み用のフィールドアクセッサを持ちます。読み込み用のフィールドアクセッサ名は「ro」で説明したものと同じです。書き込み用のフィールドアクセッサ名は「wo」で説明したものと同じです。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        「ro」「wo」「rw」のひとつより多くが同時に指定されている場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドアクセッサとは、フィールドにアクセスするためのメソッドのことです。
      </p>
      <p>
        書き込み用のフィールドアクセッサの戻り値は「void型」です。
      </p>
      <p>
        SPVMのソースコードの中からフィールドアクセッサが呼び出された場合は、フィールドアクセッサはインライン展開されます。それ以外の場合は、インライン展開されません。
      </p>
      <p>
        <b>フィールド定義のサンプル</b>
      </p>
      <p>
        フィールド定義のサンプルです。
      </p>
<pre>
package Foo {
  has num1 : byte;
  has num2 : short;
  has num3 : int;
  has num4 : long;
  has num5 : float;
  has num6 : double;

  has num_public : public int;
  has num_ro : ro int;
  has num_wo : wo int;
  has num_rw : rw int;
}
</pre>
      <h3 id="language-field-access">フィールドへのアクセス</h3>
      <p>
        フィールドへのアクセスとは、フィールドにアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
      </p>
<pre>
インボカント->{フィールド名}
</pre>
      <p>
        フィールドへのアクセスは、一種類の構文で、三つの異なる意味を持ちます。
      </p>
      <p>
        <b>1. クラス型のフィールドへのアクセス</b>
      </p>
      <p>
        <a href="#language-type-class">クラス型</a>を元に<a href="#language-expression-new-object">オブジェクトの生成</a>が行われた場合は、オブジェクトからフィールドにアクセスすることができます。
      </p>
<pre>
my $point = new Point;
$point->{x} = 1;
</pre>

      <p>
        クラス型のフィールドの取得については、<a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a>を見てください。
      </p>
      <p>
        クラス型のフィールドの設定については、<a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a>を見てください。
      </p>
      <p>
        <b>2. 複数数値型のフィールドへのアクセス</b>
      </p>
      <p>
        2. <a href="#language-type-multi-numeric">複数数値型</a>におけるフィールドは、複数数値型の変数の宣言をすれば、その変数からフィールドにアクセスできます。これは、レキシカル変数領域におけるアクセスです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
$z->{re} = 1;
$z->{im} = 3;
</pre>
      <p>
        複数数値型のフィールドの取得については、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a>を見てください。
      </p>
      <p>
        複数数値型のフィールドの設定については、<a href="#language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</a>を見てください。
      </p>
      <p>
        <b>3. デリファレンスによる複数数値型のフィールドのアクセス</b>
      </p>
      <p>
        複数数値型の変数に対するリファレンス型から、デリファレンスを行って直接に複数数値型のフィールドにアクセスできます。
      </p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{re} = 1;
$z_ref->{im} = 3;
</pre>
      <p>
        デリファレンスによる複数数値型のフィールドの取得については、<a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの取得</a>を見てください。
      </p>
      <p>
        デリファレンスによる複数数値型のフィールドの設定については、<a href="#language-expression-set-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの設定</a>を見てください。
      </p>

      <h2 id="language-sub">サブルーチン</h2>
      <ul class="list">
        <li><a href="#language-sub-definition">サブルーチンの定義</a></li>
        <li><a href="#language-sub-constant">定数サブルーチン</a></li>
        <li><a href="#language-sub-new-callback-object">コールバックオブジェクトの生成</a></li>
        <li><a href="#language-sub-capture">キャプチャ</a></li>
        <li><a href="#language-sub-method">メソッド</a></li>
        <li><a href="#language-sub-signature">シグネチャ</a></li>
        <li><a href="#language-sub-invocant">インボカント</a></li>
        <li><a href="#language-sub-stack">サブルーチンのコールスタック</a></li>
      </ul>
      <h3 id="language-sub-definition">サブルーチンの定義</h3>
      <p>
        「sub」キーワードを使用してサブルーチンを定義することができます。
      </p>
<pre>
sub サブルーチン名 : 戻り値の型名 (引数名1 : 引数の型名1, 引数名2 : 引数の型名2, 以下続く) {
  
}
</pre>
      <p>
        サブルーチンの定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
      <p>
        サブルーチン名は、1文字以上の「a～z」「A～Z」「0～9」「_」で構成する必要があります。先頭は、数字から始めることはできません。連続した「_」を使用することはできません。
      </p>
      <p>
        サブルーチン名には、<a href="#language-parser-keyword">キーワード</a>と同じ名前を使用することができます。
      </p>
      <p>
        戻りの型名には、「void型」「数値型」「オブジェクト型」を指定することができます。
      </p>
      <p>
        サブルーチンの定義には「戻り値の型名」と「0個以上の引数の定義」が必要です。「引数の定義」は「引数名」と「引数の型名」からなります。
      </p>
      <p>
        引数名は、変数名でなければなりません。
      </p>
      <p>
        引数の型名には、「数値型」「オブジェクト型」「リファレンス型」を指定することができます。
      </p>
      
      <p>
        サブルーチンのブロックの中には、0個以上のステートメントを記述できます。
      </p>
      
      <p>
        サブルーチンの定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
      </p>
<pre>
デスクリプタ名 sub サブルーチン名 : 戻り値の型名 (引数の変数名1 : 引数の型名1, 引数の変数名2 : 引数の型名2, 以下続く) {
  
}
</pre>
      <p>
        <b>サブルーチンデスクリプタ</b>
      </p>
      <p>
        サブルーチンで指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>native</b>
          </td>
          <td>
            このサブルーチンは、ネイティブサブルーチンです。
          </td>
        </tr>
        <tr>
          <td>
            <b>precompile</b>
          </td>
          <td>
            このサブルーチンはプリコンパイルされます。
          </td>
        </tr>
      </table>
      <p>
        「native」と「precompile」の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
      </p>
      
      <p>
        引数の型名の後ろに「...」を続けると、可変長引数となります。最後の引数のみ可変長引数にすることができます。
      </p>
<pre>
# 可変長引数の定義
sub サブルーチン名 : 戻り値の型名 (引数名1 : 引数の型名1, 引数名2 : 引数の型名2...) {
  
}
</pre>
      <p>
        <b>可変長引数のサンプル</b>
      </p>
      <p>
        可変長引数のサンプルです。
      </p>
<pre>
# 可変長引数を持つサブルーチンの定義
sub sprintf : string ($format : string, $values : object[]...) {
  
}

# 可変長引数を持つサブルーチンの呼び出し
foo("aaa %d %f", SPVM::Int->new(1), SPVM::Double->new(2.0));
</pre>
      <p>
        可変長引数を持つサブルーチンに配列を渡すと、配列のまま呼び出す事ができます。
      </p>
<pre>
foo("aaa %d %f", [(object)SPVM::Int->new(1), SPVM::Double->new(2.0)]);
</pre>
      <p>
        もし、配列型の値を、可変長引数の個々の要素として扱いたい場合は、配列型ではない型にキャストしてください。
      </p>
<pre>
foo("aaa %d %f", (object)[(object)SPVM::Int->new(1), SPVM::Double->new(2.0)]);
</pre>
      
      <p>
        定義されたサブルーチンは、呼び出すことができます。サブルーチンの呼び出しについては、<a href="language-expression-callsub">サブルーチンの呼び出し</a>を見てください。
      </p>

      <h3 id="language-sub-constant">定数サブルーチン</h3>
      <p>
        数値型の戻り値を持つサブルーチンで、戻り値が定数であるサブルーチンを定数サブルーチンといいます。
      </p>
<pre>
sub foo : int () { return 5; }
sub foo : long () { return 5L; }
sub foo : float () { return 5.0f; }
sub foo : double () { return 5.0; }
</pre>
      <p>
        定数サブルーチンは、インライン展開されます。
      </p>
      <p>
        SPVMは定数畳み込み最適化を行わないので、定数が演算されている場合は、定数サブルーチンにならず、インライン展開されないことに注意してください。
      </p>
<pre>
# 定数サブルーチンではなくインライン展開されない
sub foo : int () { return 5 + 3; }
</pre>

      <h3 id="language-sub-new-callback-object">コールバックオブジェクトの生成</h3>
      <p>
        コールバックオブジェクトの生成とは、コールバックの用途で、特別な構文を使って、コールバック型に適合するオブジェクトを生成する文法のことです。
      </p>
<pre>
sub : 型名 ($self : self, 引数1, 引数2, ..., 引数n) {
  
}
</pre>
      <p>
        コールバックオブジェクトの生成を行うと、内部的に、パッケージの定義がおこなわれ、そのパッケージを元にしたオブジェクトが生成され、<a href="#language-expression">式</a>として返されます。以下のように変数に代入することが可能です。
      </p>
<pre>
my $cb_obj = sub : 型名 ($self : self, 引数1, 引数2, ..., 引数n) {
  
};
</pre>
      <p>
        コールバックオブジェクトの生成で定義されるサブルーチンは、<a href="#language-sub-method">メソッド</a>でなければなりません。また名前を持たないサブルーチンでなければなりません。
      </p>
      <p>
        <b>コールバックオブジェクトの生成のサンプル</b>
      </p>
<pre>
my $comparator = sub : int ($self : self, $x1 : object, $x2 : object) {
  
}
</pre>
      <p>
        コールバックオブジェクトの生成によって生成されたオブジェクトは、通常のオブジェクトなので、メソッドを呼び出すことができます。コールバックオブジェクトの生成の呼び出しについては、<a href="language-expression-callsub">サブルーチンの呼び出し</a>を見てください。
      <p>

      <h3 id="language-sub-capture">キャプチャ</h3>
      <p>
        コールバックオブジェクトの生成においては、キャプチャという構文を使って、コールバックオブジェクトの生成によって定義されたサブルーチンの外側で定義された変数を、コールバックオブジェクトの生成によって定義されたサブルーチンの内側で使うことができます。
      </p>
<pre>
# キャプチャ
[変数名1 : 型1, 変数名2 : 型2] sub サブルーチン名 : int ($self : self, $x1 : object, $x2 : object) {
  
};
</pre>

キャプチャのサンプル。

<pre>
my $foo = 1;
my $bar = 5L;

my $comparator = [$foo : int, $bar : long] sub : int ($self : self, $x1 : object, $x2 : object) {
  
  print "$foo\n";
  print "$bar\n";
}
</pre>
      <p>
        キャプチャで使用する変数名は、<a href="#language-parser-identifier-field-name">フィールド名</a>の先頭に「$」を付けたものでなければなりません。
      </p>
      <p>
        キャプチャは、実際には、クラスのフィールドとして定義されます。キャプチャは、フィールドの定義と値の設定のシンタックスシュガーです。
      </p>
      <p>
        スコープ内で、キャプチャ変数と同名の<a href="#language-lex-var">レキシカル変数</a>が存在する場合は、レキシカル変数にアクセスします。
      </p>
      <p>
        キャプチャ変数と同名の<a href="#language-package-var">パッケージ変数</a>が存在する場合は、キャプチャ変数にアクセスします。
      </p>
      <p>
        コールバックオブジェクトの生成とキャプチャをシンタックスシュガーを使わないで記述すると次のようになります。
      </p>
<pre>
package ComapartorImpl {
  has foo : int;
  has bar : long;
  
  sub : int ($self : self, $x1 : object, $x2 : object) {
    
    print $self->{foo} . "\n";
    print $self->{bar} . "\n";
  }
}
<pre>

</pre>
my $foo = 1;
my $bar = 5L;

my $comparator = new ComparatorImpl;

$comparator->{foo} = $foo;
$comparator->{bar} = $bar;
</pre>
      
      キャプチャは、このような長い記述を、短く書くための文法です。
      
      <h3 id="language-sub-method">メソッド</h3>
      <p>
        メソッドとは、第一引数に<a href="#language-type-self">self型</a>を持つサブルーチンのことです。
      </p>
<pre>
sub サブルーチン名 : 型名 ($self : self, 引数1 : 型1, 引数2 : 型2, ..., 引数n : 型n) {
  
}
</pre>
      <p>
        メソッドは、<a href="#language-expression-new-object">オブジェクトの生成</a>によって生成されたオブジェクトから呼び出すことができます。メソッドの呼び出しについては、<a href="language-expression-callsub">サブルーチンの呼び出し</a>を見てください。
      </p>

      <h3 id="language-sub-invocant">インボカント</h3>
      <p>
        インボカントとは、self型が指定された第一引数のことをいいます。
      </p>
<pre>
sub サブルーチン名 : 型名 ($self : self, 引数1 : 型1, 引数2 : 型2, ..., 引数n : 型n) {
  
}
</pre>
      <p>
        上記の例では$selfは、インボカントと呼ばれます。
      </p>

      <h3 id="language-sub-signature">シグネチャ</h3>
      <p>
        シグネチャとは、サブルーチンの戻り値と引数を次の規則で並べたものをいいます。引数は、存在しなくても構いません。間に空白を含むことはできません。
      </p>
      <p>
        1. 戻り値の型名
      </p>
      <p>
        2. (
      </p>
      <p>
        3. 引数1,引数2, 引数3, 引数n
      </p>
      <p>
        4. )
      </p>
      <p>
        シグネチャのサンプルです。
      </p>
<pre>
# サブルーチン定義
sub foo : int ($num1 : double, $num2 : long[])

# シグネチャ
int(double,long[])

# サブルーチン定義
sub foo : void ()

# シグネチャ
void()
</pre>
      <p>
        シグネチャは、SPVMを記述しているときには、意識する必要はありません。ネイティブからSPVMのサブルーチンを呼び出すときに使用します。
      </p>
      
      <h3 id="language-sub-stack">サブルーチンのコールスタック</h3>
      <p>
        サブルーチンのコールスタックとは、<a href="#language-expression-callsub">サブルーチンの呼び出し</a>が行われるときに、確保されるメモリ領域のことを指します。
      </p>
      <p>
        サブルーチンのコールスタックには、以下の情報が保存されます。
      </p>
      <p>
        1. <a href="#language-lex-var">レキシカル変数</a>のためのメモリ領域
      </p>
      <p>
        2. モータル変数の場所
      </p>

      <h2 id="language-enum">列挙</h2>
      <ul class="list">
        <li>
          <a href="#language-enum-definition">列挙の定義</a>
        </li>
        <li>
          <a href="#language-enum-call">列挙の呼び出し</a>
        </li>
      </ul>
      <h3 id="language-enum-definition">列挙の定義</h3>
      <p>
        列挙はint型の定数を定義したい場合に利用します。連続したint型の定数を簡単に定義できます。「enum」キーワードを使って定義します。
      </p>
<pre>
enum {
  FLAG1,
  FLAG2,
  FLAG3
}
</pre>
      <p>
        列挙の定義は「<a href="#language-package-definition">パッケージ定義</a>」の直下で行う必要があります。
      </p>
<pre>
package Foo {
  enum {
    FLAG1,
    FLAG2,
    FLAG3
  }
}
</pre>

      <p>
        最初の値は「0」から始まります。値は「1」づつインクリメントされます。この例の場合は「FLAG1」は「0」、「FALG2」は「1」、「FLAG3は「2」になります。
      </p>
      <p>
        列挙の末尾の要素の後ろには「,」をつけることができます。
      </p>
<pre>
enum {
  FLAG1,
  FLAG2,
  FLAG3,
}
</pre>
      <p>
        列挙はint型を戻り値とする「定数サブルーチン」のエイリアスです。次のサブルーチンの定義と等価です。
      </p>
<pre>
sub FLAG1 : int () { return 0; }
sub FLAG2 : int () { return 1; }
sub FLAG3 : int () { return 2; }
</pre>
      <p>
        enumの要素には、int型の値を設定することができます。
      </p>
<pre>
enum {
  FLAG1,
  FLAG2 = 4,
  FLAG3,
}
</pre>
      <p>
        上記の場合は「FLAG1」は「0」、「FALG2」は「4」、「FLAG3」は「5」になります。
      </p>
      <p>
        enumの定義が不正な場合は、コンパイル時エラーが発生します。
      </p>
      
      <p>
        <b>列挙デスクリプタ</b>
      </p>
      <p>
        列挙には、デスクリプタを指定することができます。
      </p>
<pre>
private enum {
  FLAG1,
  FLAG2 = 4,
  FLAG3,
}
</pre>
      <p>
        列挙で指定できるデスクリプタの一覧です。
      </p>
      <table>
        <tr>
          <th>
            デスクリプタ名
          </th>
          <th>
            役割
          </th>
        </tr>
        <tr>
          <td>
            <b>public</b>
          </td>
          <td>
            この列挙は、外部のパッケージからアクセスできます。デフォルトの設定です。
          </td>
        </tr>
        <tr>
          <td>
            <b>private</b>
          </td>
          <td>
            この列挙は、外部のパッケージからアクセスできません。
          </td>
        </tr>
      </table>
      <p>
        「public」と「private」の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
      </p>
      
      <h3 id="language-enum-call">列挙の呼び出し</h3>
      <p>
        列挙は、定数サブルーチンのエイリアスなので、サブルーチン呼び出しとまったく同じ方法で呼び出すことができます。
      </p>
<pre>
my $flag1 = Foo->FLAG1;
my $flag2 = Foo->FLAG2;
my $flag3 = Foo->FLAG3;
</pre>
      <p>
        switch文のcase文において利用することもできます。
      </p>
<pre>
switch ($num) {
  case Foo->FLAG1: {
  
    break;
  }
  case Foo->FLAG2: {
    
    break:
  }
  case Foo->FLAG3: {
  
    break:
  }
  default: {
  
  }
}
</pre>
      <h2 id="language-begin-block">BEGINブロック</h2>
      <p>
        BEGINブロックとは、コンパイル時が終了し、実行時に入る前に、実行されるブロックのことです。
      </p>
      <p>
        BEGINキーワードを使用してBEGINブロックを定義することができます。
      </p>
<pre>
BEGIN {

}
</pre>
      <p>
        BEGINブロックは、パッケージの定義の直下にある必要があります。
      </p>
<pre>
package Foo {
  BEGIN {

  }
}
</pre>
      <p>
        BEGINブロックの中には、0個以上の<a href="#language-statement">文</a>を書くことができます。
      </p>
<pre>
BEGIN {
  my $foo = 1 + 1;
  my $bar;
}
</pre>
      <p>
        return文を書くことはできません。BEGINブロックは、引数がなく、戻り値がvoidのサブルーチンとして定義されます。
      </p>
      <p>
        BEGINブロックは、いくつでも定義できます。
      </p>
      <p>
        BEGINブロックの実行順序は、保証されません。他のパッケージにBEGINブロックが定義されている場合は、そのBEGINブロックが先に実行されることを想定しないでください。
      </p>
      <p>
        BEGINブロックの一般的な用途は、<a href="#language-package-var">パッケージ変数</a>を初期化することです。
      </p>
<pre>
package Foo {
  our $NUM : int;
  our $POINT : Point;
  BEGIN {
    $NUM = 3;
    $POINT = Point->new;
  }
}
</pre>

      <h2 id="language-lex-var">レキシカル変数</h2>
      <ul class="list">
        <li><a href="#language-lex-var-declaration">レキシカル変数の宣言</a></li>
        <li><a href="#language-lex-var-initial-value">レキシカル変数の初期値</a></li>
        <li><a href="#language-lex-var-access">レキシカル変数へのアクセス</a></li>
      </ul>
      <h3 id="language-lex-var-declaration">レキシカル変数の宣言</h3>
      <p>
        レキシカル変数とは、<a href="#language-scope-block">スコープブロック</a>の中で利用できる、<a href="#language-scope">スコープ</a>を持つ変数のことです。C言語のローカル変数に該当します。
      </p>
<pre>
{
  my $num : int;
}
</pre>
      <p>
        レキシカル変数は「my」キーワードによって宣言します。「:」の後ろに「<a href="#language-type">型</a>」を指定する必要があります。
      </p>
<pre>
my $num : int;
</pre>
      <p>
        レキシカル変数は、<a href="#language-lex-var-initial-value">レキシカル変数の初期値</a>によって初期化されます。
      </p>
<pre>
# 0で初期化される
my $num : int;

# 0で初期化される
my $num : double;

# undefで初期化される
my $point : Point;

# reは0, imは0で初期化される
my $z : SPVM::Complex_2d;
</pre>
      <p>
        レキシカル変数の宣言と同時に初期化を行うことができます。
      </p>
<pre>
# 1で初期化される
my $num : int = 1;

# 2.5で初期化される
my $num : double = 2.5;

# Pointオブジェクトで初期化される
my $point : Point = new Point;
</pre>
      <p>
        <a href="#language-type-inference">型推論</a>を使うと、宣言するときに、型の指定を省略することができます。
      </p>
<pre>
# int
my $num = 1;

# double
my $num = 1.0;
</pre>
      <p>
        レキシカル変数の宣言は、レキシカル変数の値を返します。これは、<a href="#language-expression">式</a>として利用できます。
      </p>
<pre>
my $ppp = my $bar = 4;

if (my $bar = 1) {
  
}

while (my $bar = 1) {
  
}
</pre>

      <p>
        レキシカル変数の宣言は、レキシカル変数が<a href="#language-type-object">オブジェクト型</a>であった場合に、レキシカル変数を、モータル変数として、実行時に登録します。モータル変数として登録されたレキシカル変数に代入されているオブジェクトは、<a href="#language-scope">スコープ</a>の末尾で、リファレンスカウントが自動的に1減らされます。
      </p>

      <h3 id="language-lex-var-initial-value">レキシカル変数の初期値</h3>
      <p>
        レキシカル変数は、<a href="#language-type-initial-value">型の初期値</a>で初期化されます。
      </p>

      <h3 id="language-lex-var-access">レキシカル変数へのアクセス</h3>
      <p>
        レキシカル変数へのアクセスとは、レキシカル変数にアクセスして、値を取得したり、設定したりする操作のことです。
      </p>
      <p>
        <b>レキシカル変数の値の取得</b>については、<a href="#language-expression-get-lex-var">レキシカル変数の値の取得</a>を見てください。
      </p>
      <p>
        <b>レキシカル変数の値の設定</b>については、<a href="#language-expression-set-lex-var">レキシカル変数の値の設定</a>を見てください。
      </p>
      <p>
        レキシカル変数と同名の<a href="#language-package-var">パッケージ変数</a>が存在した場合は、レキシカル変数にアクセスします。
      </p>
      
      <h2 id="language-block">ブロック</h2>
      <p>
        「{」と「}」で囲まれた部分のことをブロックと呼びます。
      </p>
<pre>
# ブロック
{

}
</pre>
      <p>
        ブロックの中には、スコープを作る<a href="#language-scope-block">スコープブロック</a>があります。
      </p>

      <h2 id="language-scope">スコープ</h2>
      <ul class="list">
        <li><a href="#language-scope-role">スコープの役割</a>
        <li><a href="#language-scope-block">スコープブロック</a>
      </ul>

      <h3 id="language-scope-role">スコープの役割</h3>
      <p>
        スコープとは<a href="#language-scope-block">スコープブロック</a>に囲まれた範囲のことをいいます。
      </p>
<pre>
# スコープブロック
{

}
</pre>
      <p>
        スコープの中で宣言されたレキシカル変数は、実行時に、宣言されている位置で、モータルなレキシカル変数として登録されます。
      </p>
<pre>
{
  # レキシカル変数をモータルとして登録
  my $num = new Foo;
}
</pre>
      <p>
        モータルなレキシカル変数に代入されたオブジェクトが、未定義値ではない場合は、リファレンスカウントが1増やされます。
      </p>
      <p>
        スコープの終わりに到達すると、モータルなレキシカル変数に代入されているオブジェクトは、未定義値でない場合、リファレンスカウントが1減らされ、0になった場合は、解放されます。
      </p>
      <h3 id="language-scope-block">スコープブロック</h3>
      <p>
        スコープブロックとは、スコープを作るブロックのことです。スコープブロックには、0個以上の<a href="#language-statement">文</a>を記述することができます。
      </p>
<pre>
# スコープブロック
{
  my $num = 1;
  $num++;
}
</pre>
      <p>
        <b>スコープブロックの一覧</b>
      <p>
      <ul class="list">
        <li><a href="#language-block-statement-simple">単純なブロック</a></li>
        <li><a href="#language-block-statement-sub">サブルーチンブロック</a></li>
        <li><a href="#language-block-statement-eval">evalブロック</a></li>
        <li><a href="#language-block-statement-if">ifブロック</a></li>
        <li><a href="#language-block-statement-elsif">elsifブロック</a></li>
        <li><a href="#language-block-statement-else">elseブロック</a></li>
        <li><a href="#language-block-statement-for">forブロック</a></li>
        <li><a href="#language-block-statement-while">whileブロック</a></li>
        <li><a href="#language-block-statement-switch">switchブロック</a></li>
      </ul>

      <h4 id="language-block-statement-simple">単純なブロック</h4>
<pre>
# 単純なブロック
{

}
</pre>

      <h4 id="language-block-statement-sub">サブルーチンブロック</h4>
<pre>
# サブルーチンのブロック
sub foo : int () {

}
</pre>

      <h4 id="language-block-statement-eval">evalブロック</h4>
<pre>
# evalブロック
eval {

}
</pre>

      <h4 id="language-block-statement-if">ifブロック</h4>
<pre>
# ifブロック
if (式) {

}
</pre>

      <h4 id="language-block-statement-elsif">elsifブロック</h4>
<pre>
#elsifブロック
elsif (式) {

}
</pre>

      <h4 id="language-block-statement-else">elseブロック</h4>
<pre>
# elseブロック
else {

}
</pre>

      <h4 id="language-block-statement-for">forブロック</h4>
<pre>
# for ブロック
for (my $i = 0; $i < 3; $i++) {

}
</pre>

      <h4 id="language-block-statement-while">whileブロック</h4>
<pre>
# whileブロック
while (式) {

}
</pre>

      <h4 id="language-block-statement-switch">switchブロック</h4>
<pre>
switch (式) {

}
</pre>
      <h2 id="language-warn">警告</h2>
      <h3 id="language-exception-summary">警告を発生させる</h3>
      <p>
        警告を発生させるにはwarn文を使用します。
      </p>
<pre>
warn 式;
</pre>
      <p>
        式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
      </p>
      <p>
        末尾が改行文字「\n」であった場合は、標準エラー出力に式で指定されている文字列が出力されます。
      </p>
      <p>
        末尾が改行文字でない場合は、末尾にファイル名と行番号が追加され、標準エラー出力されます。
      </p>
      <p>
        式で指定された文字列の長さが0あるいは、未定義値であった場合は、指定されたメッセージが「Warning: something's wrong」であるとしてふるまいます。
      </p>
      <p>
        標準エラー出力のバッファがフラッシュされます。
      </p>

      <h2 id="language-print">print文</h2>
      <p>
        標準出力に文字列を出力するにはprint文を使用します。
      </p>
<pre>
print 式;
</pre>
      <p>
        式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
      </p>
      <p>
        式が未定義値であった場合は、何もしません。
      </p>

      <h2 id="language-exception">例外処理</h2>
      <ul class="list">
        <li><a href="#language-exception-summary">例外処理の概要</a></li>
        <li><a href="#language-exception-occur">例外の発生</a></li>
        <li><a href="#language-exception-catch">例外変数のキャッチ</a></li>
        <li><a href="#language-exception-var">例外変数</a></li>
      </ul>
      
      <h3 id="language-exception-summary">例外処理の概要</h3>
      <p>
        SPVMは例外処理の仕組みを持っています。例外処理は、例外の発生と例外のキャッチからなります。
      </p>

      <h3 id="language-exception-occur">例外の発生</h3>
      <p>
        例外の発生を行うには、die文を使用します。
      </p>
<pre>
die 式;
</pre>
      <p>
        式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
      </p>
      <p>
        die文が実行されると、スタックトレースと式で指定された文字列を表示して、プログラムは終了します。スタックトレースは、パッケージ名、サブルーチン名、ファイル名、行番号を含みます。ファイル名は、モジュールをロードしたパスからの相対ファイル名です。
      </p>
<pre>
Error
  from TestCase::Minimal->sum2 at TestCase/Minimal.spvm line 1640
  from TestCase->main at TestCase.spvm line 1198
</pre>

      <h3 id="language-exception-occur">例外のキャッチ</h3>
      <p>
        例外のキャッチとは、例外がスローされた場合に、プログラムが終了するのを止め、エラーメッセージを取得できる機能のことです。
      </p>
      <p>
        例外のキャッチは、evalブロック文を使って行います。evalブロック文は、末尾にセミコロンが必要なので気をつけてください。
      </p>
<pre>
eval {
  # 例外を投げる可能性のある処理
};
</pre>
      <p>
        evalブロックで例外をキャッチした場合は、プログラムの終了は止められ、<a href="#language-exception-var">例外変数</a>に<a href="#language-exception-occur">例外の発生</a>で指定したメッセージが代入されます。
      </p>
      
      <h3 id="language-exception-var">例外変数</h3>
      <p>
        例外変数は「$@」で表現されるグローバル変数のことです。
      </p>
<pre>
$@
</pre>
      <p>
        例外変数は、本当の意味では、グローバル変数ではありません。例外変数は、実は、スレッド変数です。SPVMはシングルスレッド設計なので、例外変数は、グローバル変数として振舞うように見えます。ネイティブにおいてスレッドを利用する場合に、違いがあります。
      </p>
      <p>
        例外変数の値の取得については、<a href="#language-expression-get-exception-var">例外変数の値の取得</a>を見てください。
      </p>
      <p>
        例外変数の値の設定については、<a href="#language-expression-set-exception-var">例外変数の値の設定</a>を見てください。
      </p>

      <h2 id="language-weak-ref">ウィークリファレンス</h2>
      <p>
        ウィークリファレンスとは、リファレンスカウントを増やさない参照のことです。ウィークリファレンスを使用すると、循環参照の問題を解決することができます。
      </p>
      <p>
        SPVMは、リファレンスカウント型のGCを持ちます。リファレンスカウント型のGCにおいては、リファレンスカウントが0になった場合に、オブジェクトは自動的に開放されますが、循環参照が発生した場合は、リファレンスカウントが0にならず、オブジェクトが自動的に解放されません。
      </p>
      <p>
        オブジェクトのフィールドが、循環参照している場合のサンプルです。
      </p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;

  $foo->{bar} = $bar;
  $bar->{foo} = $foo;
}
</pre>
      <p>
        この場合は、スコープが終了しても、両方のオブジェクトは解放されません。なぜなら、循環参照が発生しており、リファレンスカウントが0にならないためです。
      </p>
      <p>
        ウィークリファレンスは、リファレンスカウントGCを持つプログラミング言語において、循環参照が発生した場合に、オブジェクトの破棄を正しく行うための機能です。
      </p>
      <p>
        このような場合は、ひとつのフィールドを、<a href="#language-statement-weaken">weaken文</a>を使って、ウィークリファレンスに設定することで、正しく解放することができます。
      </p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;

  $foo->{bar} = $bar;
  $bar->{foo} = $foo;
  
  weaken $foo->{bar};
}
</pre>
      <p>
        weaken文が実行される前の、$fooのリファレンスカウントは2、$barのリファレンスカウントは2です。
      </p>
      <p>
        もしweaken文がない場合は、スコープが終了したとしても、$fooのリファレンスカウントも、$barのリファレンスカウントも0にならず、解放されません。
      </p>
      <p>
        weaken文が実行されるとは、$fooのリファレンスカウントは2、$barのリファレンスカウントは1になります。
      </p>
      <p>
        スコープが終了すると、$barのリファレンスカウントが1減らされ0になるので、正しく解放されます。
      </p>
      <p>
        3つの循環参照の場合でも、ひとつのフィールドにウィークリファレンスを設定すれば、正しく解放できます。
      </p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;
  my $baz = new Baz;

  $foo->{bar} = $bar;
  $bar->{baz} = $baz;
  $baz->{foo} = $foo;
  
  weaken $foo->{bar};
}
</pre>
      <p>
        ウィークリファレンス関連の文法として、ウィークリファレンスを解除できる<a href="#language-statement-weaken">weaken文</a>と、フィールドがウィークリファレンスかどうかを確認できる<a href="#language-operator-isweak">isweak演算子</a>があります。
      </p>
      
      <h2 id="language-callback">コールバック</h2>
      <p>
        SPVMにおけるコールバック型とは、実装を持たない名前のないメソッドが一つだけ定義されたパッケージ型のことをいいます。<a href="#language-package-definition">パッケージの定義</a>においてcallback_tデスクリプタを指定すると、コールバック型になります。
      </p>
      <p>
        コールバック型の目的は、異なるオブジェクトが、同じメソッド定義を持つときに、どちらも代入できる型を提供することにあります。C言語の関数ポインタに該当する機能をSPVMにおいて実現するものと考えてください。
      </p>
<pre>
package Foo1 {
  sub new : Foo1 () {
    new Foo1;
  }
  sub : int ($self : self, $num : int) {
    return 1 + $num;
  }
}

package Foo2 {
  sub new : Foo2 () {
    new Foo2;
  }
  sub : int ($self : self, $num : int) {
    return 2 + $num;
  }
}

package FooCallback : callback_t {
  sub : int ($self : self, $num : int);
}
</pre>
      
      <p>
        Foo1とFoo2は同じメソッド定義「sub : int ($self : self, $num : int)」を持ちます。ここで、選択的にFoo1またはFoo2のメソッドを呼び出したいとします。
      </p>
      <p>
        この場合に、同じメソッド定義を持つコールバック型FooCallbackを定義すると、この型にどちらのオブジェクトも代入できます。そして、このオブジェクトから、メソッドを呼び出すことができます。
      </p>
<pre>
my $foo1 = Foo1->new;
my $foo2 = Foo2->new;

my $foo : FooCallback;

my $flag = 1;
if ($flag) {
  $foo = $foo1;
}
else {
  $foo = $foo2;
}

my $ret = $foo->(5);
</pre>
      <p>
        $flagが1の場合は、Foo1の無名メソッドが、そうでない場合はFoo2の無名メソッドが呼び出されます。
      </p>
      <p>
        コールバック型の詳細については、<a href="#language-type-callback">コールバック型</a>を見てください。
      </p>
      
      <h3 id="language-exception-summary">例外処理の概要</h3>
      
      <h2 id="language-array">配列</h2>
      <ul class="list">
        <li><a href="#language-array-summary">配列の概要</a></li>
        <li><a href="#language-array-new">配列の生成</a></li>
        <li><a href="#language-array-access">配列へのアクセス</a></li>
      </ul>
      <h3 id="language-array-summary">配列の概要</h3>
      <p>
        配列とは、複数の値の連続領域を表現するためのデータ構造です。
      </p>
      <p>
        配列には次の種類があります。
      </p>
      <ul class="list">
        <li>
          数値型の配列
        </li>
        <li>
          オブジェクト型の配列
        </li>
        <li>
          複数数値型の配列
        </li>
      </ul>
      <p>
        数値型の配列とは、<a href="#language-type-numeric">数値型</a>の値が連続に並んだ配列のことです。
      </p>
      <p>
        オブジェクト型の配列とは、<a href="#language-type-object">オブジェクト型</a>の値が連続に並んだ配列のことです。
      </p>
      <p>
        複数数値型の配列とは、<a href="#language-type-multi-numeric">複数数値型</a>の値が連続に並んだ配列のことです。
      </p>
      
      <h3 id="language-array-summary">配列の生成</h3>
      <p>
        配列を生成については、<a href="#language-expression-new-array">配列の生成</a>を見てください。
      </p>
      
      <h3 id="language-array-access">配列へのアクセス</h3>
      <p>
        配列へのアクセスとは、配列にアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
      </p>
<pre>
配列->[添え字]
</pre>

      <p>
        配列の取得については、<a href="#language-expression-get-array-element">配列の要素の値の取得</a>を見てください。
      </p>
      <p>
        配列の設定については、<a href="#language-expression-set-set-array-element">配列の要素の値の設定</a>を見てください。
      </p>

      <h2 id="language-value">値</h2>
      <ul class="list">
        <li><a href="#language-value-definition">複数数値型の定義</a></li>
        <li><a href="#language-value-usage">複数数値型の使用</a></li>
        <li><a href="#language-value-access">複数数値型のフィールドへのアクセス</a></li>
      </ul>
      
      <h3 id="language-value-definition">複数数値型の定義</h2>
      <p>
        SPVMには、他の言語ではあまり見ることのない値というものがあります。
      </p>
      <p>
        値は、連続した数値を表現します。たとえば、連続した32bit符号付整数が3つであるとか、連続した倍精度浮動小数点が2つなどです。3次元の点、複素数、四元数などを表現することが想定されています。
      </p>
      <p>
        値を使用するには、最初に、複数数値型を定義します。複数数値型は、<a href="#language-package-definition">パッケージの定義</a>において、mulnum_tデスクリプタを指定することで定義できます。
      </p>
<pre>
# 連続した32bit符号付整数が3つ
package Point_3i : mulnum_t {
  has x : int;
  has y : int;
  has z : int;
}

連続した倍精度浮動小数点が2つ
package Complex_2d : mulnum_t {
  re : double;
  im : double;
}
</pre>
      <p>
        すべてのフィールドは同じ<a href="#language-type-numeric">数値型</a>でなければなりません。
      </p>
      <p>
        複数数値型の末尾は「_」「フィールドの個数」「複数数値型のサフィックス」でなければなりません。
      </p>
      <p>
        <b>複数数値型のサフィクスの一覧</b>
      </p>
      <table>
        <tr>
          <th>
            <b>数値型</b>
          </th>
          <th>
            サフィックス
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            b
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            s
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            i
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            l
          </td>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            f
          </td>
        </tr>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            d
          </td>
        </tr>
      </table>
      <p>
        サフィックスは、実際に定義されている数値型と対応している必要があります。
      </p>
      <p>
        数値型の定義において、フィールドの個数の最大は16です。
      </p>
      <p>
        不正な複数数値型の定義の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        複数数値型は、<a href="#language-lex-var-declaration">レキシカル変数の宣言</a>の型として利用することができます。
      </p>
      <p>
        複数数値型は、<a href="#language-sub-definition">サブルーチンの定義</a>における引数の型として利用することができます。
      </p>
      <p>
        複数数値型は、<a href="#language-sub-definition">サブルーチンの定義</a>における戻り値の型として利用することができます。
      </p>
      <p>
        複数数値型は<a href="#language-type-array">配列型</a>の<a href="#language-type-basic">基本型</a>として利用することができます。
      </p>
<pre>
my $points = new Point_3i[5];
</pre>
      <p>
        複数数値型は、フィールドの型として利用することはできません。
      </p>
      <p>
        複数数値型は、パッケージ変数の型として利用することはできません。
      </p>
      <p>
        複数数値型の値に対しては、リファレンスを生成することができます。
      </p>
<pre>
my $point : Point_3i;
my $point_ref = \$point;
</pre>
      <p>
        複数数値型の値に、未定義値を代入することはできません。代入しようとした場合は、コンパイル時エラーが発生します。
      </p>

      <h2 id="language-value-array">値の配列</h2>
      <ul class="list">
        <li><a href="language-array-summary">値の配列の概要</a></li>
        <li><a href="language-array-access">値の配列へのアクセス</a></li>
      </ul>
      
      <h3 id="language-array-summary">値の配列の概要</h3>
      <p>
        複数数値型の値は、<a href="#language-array">配列</a>にすることができます。
      </p>
<pre>
my $points = new Point_3i[5];

my $zs = new Complex_2d[5];
</pre>
      <p>
        値の配列は、複数数値型の値が、連続したデータ構造をとります。配列の要素は、オブジェクトではなく、数値がメモリ上に一直線に並んで、配置されます。
      </p>
      <p>
        たとえば、Point_3i型の5の長さの配列であれば、Point_3i型は、int型の数値が3つ並んだ型で、長さが5なので、「5 * 3 = 15」個のint型の数値が、メモリ上に一直線に並んだデータになります。
      </p>
      <p>
        値の配列の型は、<a href="#language-type-array">配列型</a>です。
      </p>
      <p>
        値の配列の要素の型は、<a href="#language-type-multi-numeric">複数数値型</a>です。
      </p>
      
      <h3 id="language-array-access">値の配列へのアクセス</h3>
      <p>
        値の配列へのアクセスとは、値の配列にアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
      </p>
<pre>
配列->[添え字]
</pre>
      <p>
        値の配列へのアクセスは、配列のアクセスと同じ構文で行うことができます。
      </p>
      <p>
        配列の取得については、<a href="#language-expression-get-array-element">配列の要素の値の取得</a>を見てください。
      </p>
      <p>
        配列の設定については、<a href="#language-expression-set-set-array-element">配列の要素の値の設定</a>を見てください。
      </p>

      <h3 id="language-value-usage">複数数値型の使用</h2>
      <p>
        複数数値型を使用するにはuse文を使って、モジュールをロードします。
      </p>
<pre>
use Point_3i;
use Complex_2d;
</pre>
      <p>
        次に、レキシカル変数の宣言を行います。レキシカル変数の宣言を行うと、連続した領域が、<a href="#language-sub-stack">サブルーチンのコールスタック</a>上に確保されます。フィールドのすべての値は、<a href="language-type-initial-value">型の初期値</a>で初期化されます。
      </p>
<pre>
my $point : Point_3i;
my $z : Complex_2d;
</pre>
      <p>
        複数数値型の値は、オブジェクトではないので、<a href="#language-expression-new-object">オブジェクトの生成</a>の構文では生成できないことに注意してください。
      </p>

      <h3 id="language-value-access">複数数値型のフィールドへのアクセス</h2>
      <p>
        複数数値型のフィールドへのアクセスとは、複数数値型のフィールドにアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
      </p>
<pre>
インボカント->{フィールド名}
</pre>
      <p>
        複数数値型のフィールドの取得については、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a>を見てください。
      </p>
      <p>
        複数数値型のフィールドの設定については、<a href="#language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</a>を見てください。
      </p>
      <p>
        <b>複数数値型のフィールドの値の取得・設定のサンプル</b>
      </p>
      <p>
        複数数値型のフィールドの値の取得・設定のサンプルです。
      </p>
<pre>
$ival2->{x} = 1;
my $y = $ival2->{y};

$dval4->{t} = 2.5;
my $z = $dval4->{z};
</pre>

      <h2 id="language-ref">リファレンス</h2>
      <ul>
        <li><a href="language-ref-summary">リファレンスの概要</a></li>
        <li><a href="language-ref-deref">デリファレンス</a></li>
      </ul>
      
      <h3 id="language-ref">リファレンスの概要</h3>
      <p>
        リファレンスとは、レキシカル変数のアドレスのことをいいます。リファレンスは、C言語のポインタに該当する機能を実現するために、設計されました。
      </p>
      <p>
        レキシカル変数のアドレスは、<a href="#language-operator-ref">リファレンス演算子</a>を使用して取得できます。<a href="#language-type-ref">リファレンス型</a>は、<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-multi-numeric">複数数値型</a>の後ろに「&」を続けたものになります。
      </p>
<pre>
# 数値型の変数のリファレンス
my $num : int;
my $num_ref : int& = \$num;

# 複数数値型の変数のリファレンス
my $point : Point_3d;
my $point_ref : Point_3d& = \$point;
</pre>
      <p>
        $num_refの値は、レキシカル変数「$num」のアドレスになります。$point_refの値は、レキシカル変数「$point」のアドレスになります。
      </p>
      <p>
        リファレンス演算子の対象は、<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-multi-numeric">複数数値型</a>の値が格納された変数だけです。オブジェクト型の変数や定数に対して、使うことはできません。
      </p>
      <p>
        <a href="#language-type-ref">リファレンス型</a>の値は、サブルーチンの引数として利用することができます。
      </p>
<pre>
# サブルーチンの定義
sub sum : void ($out_ref : int&, $in1 : int, $in2 : int) {
  $$out_ref = $in1 + $in2;
}

# サブルーチンの利用
my $num1 = 1;
my $num2 = 2;
my $out : int;
my $out_ref = \$out;
sum($out_ref, $num1, $num2);
</pre>

      <h3 id="language-ref-deref">デリファレンス</h3>
      <p>
        デリファレンスとは、アドレスの場所にあるレキシカル変数の値を取得・設定する操作をいいます。
      </p>
      <p>
        デリファレンスすることで、アドレスを通して値を取得したり、変更することができます。
      </p>
<pre>
# 数値型の値を取得
my $num2 = $$num_ref;

# 数値型の値を変更
$$num_ref = 3;

# 複数数値型の値を取得
my $point2 = $$point_ref;

# 複数数値型の値を設定
$$point_ref = $point2;
</pre>

      <p>
        リファレンス型の対象が複数数値型であった場合に、複数数値型のフィールドの設定と取得は、アロー演算子で行うことができます。
      </p>
<pre>
# リファレンス型の対象が複数数値型であった場合に、複数数値型のフィールドを取得
my $x = $point_ref->{x};

# リファレンス型の対象が複数数値型であった場合に、複数数値型のフィールドを設定
$point_ref->{x} = 1;
</pre>

      <h3 id="language-type-ref-numeric">数値のリファレンス型</h3>
      <p>
        数値のリファレンス型とは、<a href="#language-type-numeric">数値型</a>の変数に対する<a href="#language-type-ref">リファレンス型</a>のことをいいます。
      </p>
      <h3 id="language-type-ref-multi-numeric">複数数値のリファレンス型</h3>
      <p>
        複数数値のリファレンス型とは、<a href="#language-type-multi-numeric">複数数値型</a>の変数に対する<a href="#language-type-ref">リファレンス型</a>のことをいいます。
      </p>
      
      </p>
      
      <h2 id="language-expression">式</h2>
      <ul class="list">
        <li class="language-expression-summary">式とは</li>
        <li class="language-expression-current-package">現在のパッケージ名の取得</li>
        <li class="language-expression-current-file">現在のファイル名の取得</li>
        <li class="language-expression-current-line">現在の行番号の取得</li>
      </ul>
      
      <h3 id="language-expression">式とは</h3>
      <p>
        式とは、値の評価が可能な<a href="#language-expresssion">式</a>のことです。
      </p>
      <p>
        <b>式の一覧</b>
      </p>
      <ul class="list">
        <li><a href="#language-expression-get-lex-var">レキシカル変数の値の取得</a></li>
        <li><a href="#language-expression-set-lex-var">レキシカル変数の値の設定</a></li>
        <li><a href="#language-expression-get-package-var">パッケージ変数の値の設定</a></li>
        <li><a href="#language-expression-set-package-var">パッケージ変数の値の取得</a></li>
        <li><a href="#language-expression-get-exception-var">例外変数の値の設定</a></li>
        <li><a href="#language-expression-set-exception-var">例外変数の値の取得</a></li>
        <li><a href="#language-literal">リテラル</a></li>
        <li><a href="#language-undef">未定義値</a></li>
        <li><a href="#language-expression-callsub">サブルーチンの呼び出し</a></li>
        <li><a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a></li>
        <li><a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a></li>
        <li><a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a></li>
        <li><a href="#language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</a></li>
        <li><a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの取得</a></li>
        <li><a href="#language-expression-set-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの設定</a></li>
        <li><a href="#language-expression-get-array-element">配列の要素の値の取得</a></li>
        <li><a href="#language-expression-set-array-element">配列の要素の値の設定</a></li>
        <li><a href="#language-expression-typecast">型キャスト</a></li>
        <li><a href="#language-expression-new-object">オブジェクトの生成</a></li>
        <li><a href="#language-expression-new-array">配列の生成</a></li>
        <li><a href="#language-expression-release-object">オブジェクトの解放</a></li>
        <li><a href="#language-expression-array-init">配列の初期化</a></li>
        <li><a href="#language-operator-array-length">配列長演算子</a></li>
        <li><a href="#language-operator-string-length">文字列長演算子</a></li>
        <li><a href="#language-operator-arithmetic">算術演算子</a></li>
        <li><a href="#language-operator-bit">ビット演算子</a></li>
        <li><a href="#language-operator-shift">シフト演算子</a></li>
        <li><a href="#language-operator-concat">文字列連結演算子</a></li>
        <li><a href="#language-operator-ref">リファレンス演算子</a></li>
        <li><a href="#language-operator-deref">リファレンス演算子</a></li>
        <li><a href="#language-operator-assign">代入演算子</a></li>
        <li><a href="#language-operator-array-length">配列長演算子</a></li>
        <li><a href="#language-operator-string-length">文字列長演算子</a></li>
        <li><a href="#language-operator-scalar">スカラ演算子</a></li>
        <li><a href="#language-expression-current-package">現在のパッケージ名の取得</a></li>
        <li><a href="#language-expression-current-file">現在のファイル名の取得</a></li>
        <li><a href="#language-expression-current-line">現在の行番号の取得</a></li>
        <li>(式)</li>
      </ul>
      
      <h3 id="language-expression-get-lex-var">レキシカル変数の値の取得</h3>
      <p>
        レキシカル変数の値の取得をするには、レキシカル変数自体を記述します。
      </p>
<pre>
$var
</pre>
      <p>
        レキシカル変数の値の取得は、<a href="#language-expression">式</a>です。
      </p>

      <h3 id="language-expression-set-lex-var">レキシカル変数の値の設定</h3>
      <p>
        レキシカル変数の値の設定を行うには、<a href="#language-operator-assign">代入演算子</a>を使用します。
      </p>
<pre>
$var = 右式
</pre>
      <p>
        代入が<a href="#language-type-compatible">型の互換性</a>を満たさない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        レキシカル変数の値の設定は、設定後の値を返します。
      </p>
      <p>
        レキシカル変数の値の設定は、<a href="#language-expression">式</a>です。
      </p>
      <p>
        右式が、オブジェクト型であった場合は、オブジェクトのリファレンスカウントが1増やされます。
      </p>
      <p>
        代入前に、すでに$varにオブジェクトが代入されていた場合は、そのオブジェクトのリファレンスカウントが1減らされます。
      </p>
      
      <h3 id="language-expression-get-package-var">パッケージ変数の値の取得</h3>
      <p>
        パッケージ変数の値を取得するには以下の構文を使用します。
      </p>
<pre>
$クラス名::パッケージ変数名
</pre>
      <p>
        自分自身のパッケージに属するパッケージ変数の場合は「クラス名::」を省略できます。
      </p>
<pre>
$パッケージ変数名
</pre>
      <p>
       パッケージ変数の値の取得は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        定義されていないパッケージ変数の値を取得しようとした場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        パッケージの外側からプライベートなパッケージ変数にアクセスしようとした場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>パッケージ変数の値の取得のサンプル</b>
      </p>
<pre>
package Foo {
  our $VAR : int;
  
  sub bar : int () {
    my $var1 = $Foo::VAR;
    my $var2 = $VAR;
  }
}
</pre>

      <h3 id="language-expression-set-package-var">パッケージ変数の値の設定</h3>
      <p>
        パッケージ変数の値を設定するには以下の構文を使用します。
      </p>
<pre>
$クラス名::パッケージ変数名 = 右式
</pre>
        自分自身のパッケージに属するパッケージ変数の場合は「クラス名::」を省略できます。
      </p>
<pre>
$パッケージ変数名 = 右式
</pre>
      <p>
        パッケージ変数設定は、<a href="#language-expression">式</a>を返します。返される結果は、代入後のパッケージ変数の値です。
      </p>
      <p>
        定義されていないパッケージ変数の値を設定しようとした場合は、コンパイル時エラーが設定します。
      </p>
      <p>
        パッケージの外側からプライベートなパッケージ変数にアクセスしようとした場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>パッケージ変数の値の設定のサンプル</b>
      </p>
<pre>
package Foo {
  our $VAR : int;
  
  sub bar : int () {
    $Foo::VAR = 1;
    $VAR = 3;
  }
}
</pre>

      <h3 id="language-expression-get-exception-var">例外変数の値の取得</h3>
      <p>
        例外変数の値を取得するには以下の構文を使用します。
      </p>
<pre>
$@
</pre>
      <p>
       例外変数の値の取得は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
       例外変数の値の取得は、<a href="#language-type-string">文字列型</a>の値を返します。
      </p>
      <p>
        <b>例外変数の値の取得のサンプル</b>
      </p>
      <p>
        例外変数の値の取得のサンプルです。
      </p>
<pre>
eval {
  foo();
};

if (my $message = $@) {
  
}
</pre>

      <h3 id="language-expression-set-exception-var">例外変数の値の設定</h3>
      <p>
        例外変数の値を設定するには以下の構文を使用します。
      </p>
<pre>
$@ = 右式
</pre>
      <p>
        右式は<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
      </p>
      <p>
       例外変数の値の設定は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
       例外変数の値の設定は、設定後の例外変数の値を返します。これは、<a href="#language-type-string">文字列型</a>です。
      </p>
      <p>
        <b>例外変数の値の設定のサンプル</b>
      </p>
      <p>
        例外変数の値の設定のサンプルです。
      </p>
<pre>
$@ = "Error";
</pre>

      <h3 id="language-expression-get-field-class">クラス型のフィールドの値の取得</h3>
      <p>
        クラス型のフィールドの値の取得は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名}
</pre>
      <p>
        インボカント式は、<a href="#language-type-class">クラス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-multi-numeric">複数数値型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a>になり、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの取得</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        クラス型のフィールドの値の取得は、オブジェクトに保存されているフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>クラス型のフィールドの値の取得のサンプル</b>
      </p>
      <p>
        クラス型のフィールドの値の取得のサンプルです。
      </p>
<pre>
my $point = Point->new;
my $x = $point->{x};
</pre>
      
      <h3 id="language-expression-set-field-class">クラス型のフィールドの値の設定</h3>
      <p>
        クラス型のフィールドの値の設定は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名} = 右式
</pre>
      <p>
        インボカント式は、<a href="#language-type-class">クラス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-multi-numeric">複数数値型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の設定</a>になり、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの設定</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        右式の型は、フィールドの型と同じでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        クラス型のフィールドの値の設定は、設定後のオブジェクトに保存されているフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        右式が、オブジェクト型であった場合は、オブジェクトのリファレンスカウントが1増やされます。
      </p>
      <p>
        代入前に、すでにフィールドにオブジェクトが代入されていた場合は、そのオブジェクトのリファレンスカウントが1減らされます。
      </p>
      <p>
        <b>クラス型のフィールドの値の設定のサンプル</b>
      </p>
      <p>
        クラス型のフィールドの値の設定のサンプルです。
      </p>
<pre>
my $point = Point->new;
$point->{x} = 1;
</pre>
      
      <h3 id="language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</h3>
      <p>
        複数数値型のフィールドの値の取得は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名}
</pre>
      <p>
        インボカント式は、<a href="#language-type-class">複数数値型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a>になり、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの取得</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        複数数値型のフィールドの値の取得は、<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>複数数値型のフィールドの値の取得のサンプル</b>
      </p>
      <p>
        複数数値型のフィールドの値の取得のサンプルです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
my $re = $z->{re};
</pre>

      <h3 id="language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</h3>
      <p>
        複数数値型のフィールドの値の設定は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名} = 右式
</pre>
      <p>
        インボカント式は、<a href="#language-type-class">複数数値型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a>になり、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値であった場合は、<a href="#language-expression-set-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの設定</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        右式の型は、フィールドの型と同じでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        複数数値型のフィールドの値の設定は、設定後の<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>複数数値型のフィールドの値の設定のサンプル</b>
      </p>
      <p>
        複数数値型のフィールドの値の設定のサンプルです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
$z->{re} = 2.5;
</pre>

      <h3 id="language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの値の取得</h3>
      <p>
        デリファレンスによる複数数値型のフィールドの値の取得は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名}
</pre>
      <p>
        インボカント式は、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a>になり、<a href="#language-type-multi-numeric">複数数値型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デリファレンスによる複数数値型のフィールドの値の取得は、<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>デリファレンスによる複数数値型のフィールドの値の取得のサンプル</b>
      </p>
      <p>
        デリファレンスによる複数数値型のフィールドの値の取得のサンプルです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
my $re = $z_ref->{re};
</pre>

      <h3 id="language-expression-set-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの値の設定</h3>
      <p>
        デリファレンスによる複数数値型のフィールドの値の設定は、次のように記述します。
      </p>
<pre>
インボカント式->{フィールド名} = 右式
</pre>
      <p>
        インボカント式は、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a>になり、<a href="#language-type-multi-numeric">複数数値型</a>の値であった場合は、<a href="#language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名が、存在しない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        右式の型は、フィールドの型と同じでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デリファレンスによる複数数値型のフィールドの値の設定は、設定後の<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <p>
        返される値の型は、フィールドの型です。
      </p>
      <p>
        <b>デリファレンスによる複数数値型のフィールドの値の設定のサンプル</b>
      </p>
      <p>
        デリファレンスによる複数数値型のフィールドの値の設定のサンプルです。
      </p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{re} = 2.5;
</pre>
      
      <h3 id="language-expression-get-array-element">配列の要素の値の取得</h3>
      <p>
        配列の要素の値を取得するには、次のように記述します。
      </p>
<p>
配列式->[インデックス式]
</p>
      <p>
        配列式は、<a href="#language-type-array">配列型</a>の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        インデックス式は、int型の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        配列の要素の値を取得は、指定したインデックスの要素の値を返します。これは、式です。
      </p>
      <p>
        実行時に、配列式の値が、未定義値である場合は、実行時例外が発生します。
      </p>
      <p>
        実行時に、インデックスの値が、0より小さい場合、あるいは、配列の最大のインデックスを超えている場合は、実行時例外が発生します。
      </p>
      <p>
        <b>配列の要素の値の取得のサンプル</b>
      </p>
      <p>
        配列の要素の値の取得のサンプルです。
      </p>
<pre>
my $nums = new int[3];
my $num = $nums->[1];

my $points = new Point[3];
my $point = $points->[1];

my $objects : oarray = $points;
my $object = (Point)$objects->[1];
</pre>
      
      <h3 id="language-expression-set-array-element">配列の要素の値の設定</h3>
      <p>
        配列の要素の値を設定するには、次のように記述します。
      </p>
<p>
配列式->[インデックス式] = 右式
</p>
      <p>
        配列式は、<a href="#language-type-array">配列型</a>の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        インデックス式は、int型の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        右式の型は、配列の要素の型と<a href="#language-type-compatible">型の互換性</a>がなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        配列の要素の値を設定は、設定後の値を返します。これは、式です。
      </p>
      <p>
        実行時に、配列式の値が、未定義値である場合は、実行時例外が発生します。
      </p>
      <p>
        実行時に、インデックスの値が、0より小さい場合、あるいは、配列の最大のインデックスを超えている場合は、実行時例外が発生します。
      </p>
      <p>
        右式が、オブジェクト型であった場合は、オブジェクトのリファレンスカウントが1増やされます。
      </p>
      <p>
        代入前に、すでに配列の要素にオブジェクトが代入されていた場合は、そのオブジェクトのリファレンスカウントが1減らされます。
      </p>
      <p>
        <b>配列の要素の値の設定のサンプル</b>
      </p>
      <p>
        配列の要素の値の設定のサンプルです。
      </p>
<pre>
my $nums = new int[3];
$nums->[1] = 3;

my $points = new Point[3];
$points->[1] = Point->new(1, 2);

my $objects : oarray = $points;
$objects->[2] = Point->new(3, 5);;
</pre>

      <h3 id="language-expression-new-object">オブジェクトの生成</h3>
      <p>
        オブジェクトを生成するには、newキーワードと以下の構文をを使用します。
      </p>
<pre>
my $object = new パッケージ名;
</pre>
      <p>
        指定されたパッケージは、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドは、すべて<a href="language-type-initial-value">型の初期値</a>で初期化されます。
      </p>
      <p>
        オブジェクトの生成は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        生成直後のオブジェクトのリファレンスカウントは、0です。代入が実行されるタイミングで、リファレンスカウントが1増やされます。明示的な代入が行われない場合でも、一時変数が作成され、そこに代入されます。
      </p>
      <p>
        <b>オブジェクトの生成のサンプル</b>
      </p>
<pre>
my $object = new Foo;
</pre>
      <p>
        生成されたオブジェクトは内部的に次の情報を持っています。
      </p>
      <ul class="list">
        <li>リファレンスカウント</li>
        <li>ウィークリファレンスのバックリファレンス</li>
        <li>基本型のID</li>
        <li>型の次元(常に0)</li>
      </ul>
      
      <h3 id="language-expression-new-array">配列の生成</h3>
      <p>
        配列を作成するには、newキーワードと以下の構文をを使用します。
      </p>
<pre>
my $object = new 型[要素数式];
</pre>
      <p>
        型には、<a href="#language-type-numeric">数値型</a>、<a href="#language-type-object">オブジェクト型</a>、<a href="#language-type-multi-numeric">複数数値型</a>が指定できます。それ以外の型を指定した場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        要素数式は、int型以下の<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        要素数式に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        要素数式で指定された長さの配列が生成されます。
      </p>
      <p>
        配列の要素は、すべて<a href="language-type-initial-value">型の初期値</a>で初期化されます。
      </p>
      <p>
        配列において、要素は、メモリ上に連続していることが保証されます。
      </p>
      <p>
        配列の生成は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        配列は、<a href="#language-type-object">オブジェクト型</a>です。
      </p>
      <p>
        <b>配列の生成のサンプル</b>
      </p>
<pre>
my $nums = new int[3];
my $objects = new Foo[3];
my $objects = new object[3];
my $values = new Complex_2d[3]
</pre>
      <p>
        生成された配列は、内部的に次の情報を持っています。
      </p>
      <ul class="list">
        <li>リファレンスカウント</li>
        <li>基本型のID</li>
        <li>型の次元(1以上の値)</li>
        <li>配列の長さ</li>
      </ul>
      <p>
        多次元配列は、上記の構文を使用して、作成できます。要素は、<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
      </p>
<pre>
my $nums = new int[][3];
my $nums = new int[][][3];
</pre>
      <p>
        多次元配列の次元数の最大は、255です。
      </p>
      
      <h3 id="language-expression-array-init">配列の初期化</h3>
      <p>
        SPVMには、配列の生成を簡単にするための配列の初期化の構文があります。式はなくてもかまいません。
      </p>
<pre>
[]
[式1, 式2, 式3]
</pre>
      <p>
        配列の初期化は、式の要素数の長さを持った配列を返します。
      </p>
      <p>
        配列の型は、式1の型を配列型にしたものです。要素が指定されない場合は、<a href="#language-type-any-object">汎用オブジェクト型</a>を配列型にしたものになります。
      </p>
      <p>
        式2以降が、<a href="#language-type-compatible">型の互換性</a>を満たさない場合は、コンパイルエラーになります。
      </p>

      <h3 id="language-expression-callsub">サブルーチンの呼び出し</h3>
      <p>
        <a href="#language-sub-definition">サブルーチンの定義</a>によって定義されたサブルーチンは呼び出すことができます。呼び出しには、2種類あって、<b>関数の呼び出し</b>と<b>メソッドの呼び出し</b>があります。
      </p>
      
      <h4 id="language-expression-callsub-func">関数の呼び出し</h4>
      <p>
        関数の呼び出しとは、<a href="#language-sub-method">メソッド</a>ではないサブルーチンを呼び出す方法のことをいいます。メソッドかどうかの判断は、<a href="#language-sub-definition">サブルーチンの定義</a>において、第一引数に<a href="#language-type-self">self型</a>の引数が指定されていた場合が、メソッドになります。
      </p>
      <p>
        関数の呼び出しは以下の方法で行うことができます。引数は、なくても構いません。最大で255個の引数を指定できます。
      </p>
<pre>
パッケージ名->サブルーチン名(引数1, 引数2, 引数3, ..., 引数n);
</pre>
      <p>
        Perlにおいてクラスメソッドの呼び出しと呼ばれているものが、SPVMでは、関数の呼び出しと呼ばれていることに注意してください。
      </p>
      <p>
        関数の呼び出しでは、パッケージ名を省略することもできます。
      </p>
<pre>
サブルーチン名(引数1, 引数2, 引数3, ..., 引数n);
</pre>
      <p>
        どのパッケージのサブルーチンが呼び出されるかは、以下の順番によって決まります。
      </p>
      <p>
        1. 現在のパッケージで定義されているサブルーチン、または現在のパッケージにインポートされたサブルーチン
      </p>
      <p>
        2. 標準関数 - COREパッケージで定義されているサブルーチン
      </p>
      
      <p>
        関数の呼び出しは、引数を受け取ります。引数の個数が、サブルーチンの定義で定義されている引数の個数と一致しない場合は、コンパイル時エラーが発生します。それぞれの引数の型が、サブルーチン定義で定義されている引数の型と<a href="#language-type-compatible">型の互換性</a>がない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        関数の呼び出しは、戻り値がvoid型以外の場合は、戻り値を返します。
      </p>
      <p>
        関数の呼び出しは、<a href="#language-expression">式</a>です。
      <p>
      <p>
        <b>サブルーチン呼び出しのサンプル</b>
      </p>
      <p>
        サブルーチン呼び出しのサンプルです。
      </p>
<pre>
my $ret = Foo->bar(1, 2, 3);
my $ret = bar(1, 2, 3);
</pre>

      <h4 id="language-expression-callsub-method">メソッドの呼び出し</h4>
      <p>
        メソッドの呼び出しとは、<a href="#language-sub-method">メソッド</a>であるサブルーチンを呼び出す方法のことをいいます。メソッドかどうかの判断は、<a href="#language-sub-definition">サブルーチンの定義</a>において、第一引数に<a href="#language-type-self">self型</a>の引数が指定されていた場合が、メソッドになります。
      </p>
      <p>
        メソッドの呼び出しは、<a href="#language-expression-new-object">オブジェクトの生成</a>によって生成されたオブジェクトを使って以下の構文で行うことができます。
      </p>
<pre>
オブジェクト->サブルーチン名(引数1, 引数2, 引数3, ..., 引数n);
</pre>
      <p>
        メソッドの呼び出しは、引数を受け取ります。引数の個数が、サブルーチンの定義で定義されている引数の個数と一致しない場合は、コンパイル時エラーが発生します。それぞれの引数の型が、サブルーチン定義で定義されている引数の型と<a href="#language-type-compatible">型の互換性</a>がない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        メソッドの呼び出しは、戻り値がvoid型以外の場合は、戻り値を返します。
      </p>
      <p>
        メソッドの呼び出しは、<a href="#language-expression">式</a>です。
      <p>
      <p>
        <b>メソッドの呼び出しのサンプル</b>
      </p>
      <p>
        メソッドの呼び出しのサンプルです。
      </p>
<pre>
my $point = new Point;
$point->set_x(3);
</pre>
      <p>
        <a href="#language-sub-new-callback-object">コールバックオブジェクトの生成</a>で作成されたオブジェクトは、通常のオブジェクトなのでメソッドを呼び出すことができます。
      </p>
<pre>
オブジェクト->(引数1, 引数2, 引数3, ..., 引数n);
</pre>

      <p>
        <b>コールバックオブジェクトの生成で生成されたオブジェクトからメソッドを呼び出すサンプル</b>
      </p>
      <p>
        コールバックオブジェクトの生成で生成されたオブジェクトからメソッドを呼び出すサンプルです。
      </p>
<pre>
my $cb_obj = sub : int ($self: self, $num1 : int, $num2 : int) {
  return $num1 + $num2;
};

my $ret = $cb_obj->(1, 2);
</pre>

      <h3 id="language-operator-deref-get">デリファレンスによる値の取得</h3>
      <p>
        デリファレンスによる値の取得とは、リファレンスから実際の値を取得するための操作のことです。C言語の関節演算子「*」を実現するために設計されました。
      </p>
<pre>
$変数
</pre>
      <p>
        変数の型は、リファレンス型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デリファレンスによる値の取得は、<a href="#language-expression">式</a>を返します。
      </p>
      <pre>
        <b>デリファレンスによる値の取得のサンプル</b>
      </pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
my $num_deref : int = $$num_ref;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
my $z_deref : SPVM::Complex_2d = $$z_ref;
</pre>

      <h3 id="language-operator-deref-set">デリファレンスによる値の設定</h3>
      <p>
        デリファレンスによる値の設定とは、リファレンスから実際の値を設定するための操作のことです。C言語の関節演算子「*」を実現するために設計されました。
      </p>
<pre>
$変数 = 式
</pre>
      <p>
        変数の型は、リファレンス型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        式の型は、デリファレンスされた場合の変数の型に一致していなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デリファレンスによる値の設定は、設定された値を返します。これは<a href="#language-expression">式</a>です。
      </p>
      <pre>
        <b>デリファレンスによる値の設定のサンプル</b>
      </pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
$$num_ref = 1;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;

my $z2 : SPVM::Complex_2d;

$$z_ref = $z2;
</pre>

      <h3 id="language-expression-current-package">現在のパッケージ名の取得</h3>
      <p>
        現在のパッケージ名の取得を行う「__PACKAGE__」キーワードを使用します。
      </p>
<pre>
__PACKAGE__
</pre>
      <p>
        現在のパッケージ名の取得は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>現在のパッケージ名の取得のサンプル</b>
      </p>
<pre>
package Foo::Bar {
  sub baz : void () {
    # Foo::Bar
    my $package_name == __PACKAGE__;
  }
}
</pre>
      <h3 id="language-expression-current-package">現在のファイル名の取得</h3>
      <p>
        現在のファイル名の取得を行う「__FILE__」キーワードを使用します。
      </p>
<pre>
__FILE__
</pre>
      <p>
        現在のファイル名の取得は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        現在のファイル名とは、モジュールの読み込みパスを基準とした、ファイルの相対パスのことをいいます。たとえば、ファイルの読み込みパスが「/mypath」でモジュール名が「Foo::Bar」であった場合は、絶対パスは「/mypath/Foo/Bar.spvm」で、相対パスは「Foo/Bar.spvm」です。相対パスである「Foo/Bar.spvm」が、現在のファイル名になります。
      </p>
      <p>
        <b>現在のファイル名の取得のサンプル</b>
      </p>
<pre>
# Foo/Bar.spvm
package Foo::Bar {
  sub baz : void () {
    # Foo/Bar.spvm
    my $file_name == __FILE__;
  }
}
package Foo::Bar2 {
  sub baz : void () {
    # Foo/Bar.spvm
    my $file_name == __FILE__;
  }
}
</pre>
      <h3 id="language-expression-current-package">現在の行番号の取得</h3>
      <p>
        現在の行番号の取得を行う「__LINE__」キーワードを使用します。
      </p>
<pre>
__LINE__
</pre>
      <p>
        現在の行番号の取得は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>現在の行番号の取得のサンプル</b>
      </p>
<pre>
package Foo::Bar {
  sub baz : void () {
    # 4
    my $line == __LINE__;
  }
}
</pre>

      <h2 id="language-expression-release-object">オブジェクトの解放</h2>
      <p>
        オブジェクトは、リファレンスカウントが0になるとメモリから解放されます。
      </p>
      <p>
        オブジェクトが、オブジェクト型の値を要素として持つ配列だった場合は、オブジェクトの解放の前に、未定義値ではないすべての配列の要素のリファレンスカウントが1減らされます
      </p>
      <p>
        オブジェクトが、クラス型で、オブジェクト型のフィールドを持つときは、オブジェクトの解放の前に、未定義値ではないすべてのオブジェクト型のフィールドが所有するオブジェクトのリファレンスカウントが1減らされます。フィールドに保存されているオブジェクトにウィークリファレンスが設定されていた場合は、リファレンスカウントが1減らされる前に、ウィークリファレンスが解除されます。
      </p>
      <p>
        オブジェクトがウィークリファレンスのバックリファレンスを持つときは、バックリファレンスとして登録されているフィールドすべてに、未定義値を代入し、バックリファレンスをすべて削除します。
      </p>
      <p>
        上記の処理は、再帰的に行われます。
      </p>

      <h2 id="language-literal">リテラル</h2>
      <ul class="list">
        <li><a href="#language-literal-integer">整数リテラル</a></li>
        <li><a href="#language-literal-floating-point">浮動小数点リテラル</a></li>
        <li><a href="#language-literal-character">文字リテラル</a></li>
        <li><a href="#language-literal-string">文字列リテラル</a></li>
        <li><a href="#language-literal-string-variable-expansion">変数展開</a></li>
      </ul>
      <h3 id="language-literal-integer">整数リテラル</h2>
      <p>
        <b>10進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は「0～9」の1つ以上の連続した文字で表現されます。
      </p>
      <p>
        先頭に「+」あるいは「-」の符号をつけることができます。
      </p>
      <p>
        整数リテラルの型は、デフォルトでは「int型」になります。
      </p>
      <p>
        整数リテラルがint型で表現できる数値の範囲を超えている場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        末尾に「L」あるいは「l」のサフィックスをつけることで「long型」の整数リテラルを表現できます。
      </p>
      <p>
        long型の整数リテラルの場合は、long型で表現できる数値の範囲を超えている場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        区切り文字として「_」を使用することができます。区切り文字は意味を持ちません。
      </p>
      <p>
        不正な整数リテラルの表現はコンパイル時エラーが発生します。
      </p>
      <p>
        整数リテラルがbyte型の変数に代入される場合、あるいはbyte型のサブルーチンの引数として渡される場合で、byte型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>によって、byte型に自動的に変換されます。範囲を超えている場合は、コンパイル時エラーとなります。
      </p>
      <p>
        整数リテラルがshort型の変数に代入される場合、あるいはshort型のサブルーチンの引数として渡される場合で、short型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>によって、short型に自動的に変換されます。範囲を超えている場合は、コンパイル時エラーとなります。
      </p>
      <p>
        整数リテラルのサンプルです。
      </p>
<pre>
123
+123
-123
123L
123l
123_456_789
-123_456_789L
</pre>
      <p>
        <b>16進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>16進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を16進数を使って表現するときは「0x」から始めます。
      </p>
      <p>
        その後ろに「0～9」「a～f」「A～F」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な16進数表現は、コンパイル時エラーが発生します。
      </p>
      <p>
        整数リテラルを16進数で表現したサンプルです。
      </p>
<pre>
0x3b4f
-0x3F1A
0xDeL
0xFFFFFFFF_FFFFFFFF
</pre>

      <p>
        <b>8進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>8進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を8進数を使って表現するときは「0」から始めます。
      </p>
      <p>
        その後ろに「0～7」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な8進数表現は、コンパイル時エラーが発生します。
      </p>
      <p>
        整数リテラルを8進数で表現したサンプルです。
      </p>
<pre>
0755
-0644
0666L
0655_755
</pre>
      <p>
        <b>2進数表現</b>
      </p>
      <p>
        整数リテラルの数値部は<b>2進数</b>を使って表現することができます。
      </p>
      <p>
       数値部を2進数を使って表現するときは「0b」から始めます。
      </p>
      <p>
        その後ろに「0」か「1」のひとつ以上の連続した文字が続きます。
      </p>
      <p>
        不正な2進数表現は、コンパイル時エラーが発生します。
      </p>
      <p>
        整数リテラルを2進数で表現したサンプルです。
      </p>
<pre>
0b0101
-0b1010
0b110000L
0b10101010_10101010
</pre>


      <h3 id="language-literal-floating-point">浮動小数点リテラル</h2>
      <p>
        浮動小数点リテラルは「符号部」「数値部」「指数部」「サフィックス」から構成されます。
      <p>
      <p>
        浮動小数点リテラルには「10進数浮動小数点リテラル」と「16進数浮動小数点リテラル」があります。
      </p>
      <p>
        「符号部」は「+」か「-」で表現されます。「符号部」の存在は、任意です。「符号部」が存在する場合は、先頭にある必要があります。
      </p>
      <p>
        「10進数浮動小数点リテラル」は、数値部が「一桁以上の10進数字」で始まる必要があります。
      </p>
      <p>
        「10進数字」とは「0～9」のことです。
      </p>
      <p>
        「10進数浮動小数点リテラル」は、数値部に「小数点」が含まれているか、含まれていない場合は「指数部」あるいは「サフィックス」が必要です。
      </p>
      <p>
        「小数点」とは「.」のことです。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、数値部が「0x」あるいは「0X」で始まり、その後ろに「一桁以上の16進数字」が続く必要があります。
      </p>
      <p>
        16進数字とは「0～9」「a～f」「A～F」のことです。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、「数値部」に「小数点」を含むことができます。
      </p>
      <p>
        「数値部」はアンダーライン「_」を含むことができます。これは単なる区切り文字で、無視されます。
      </p>
      <p>
        「16進数浮動小数点リテラル」は、「指数部」が必要です。
      </p>
      <p>
        「指数部」は「指数表現」と「符号付10進整数」で構成されます。
      </p>
      <p>
        「指数表現」は「10進数浮動小数点リテラル」の場合は「e」あるいは「E」、「16進数浮動小数点リテラル」の場合は「p」あるいは「P」になります。
      </p>
      <p>
        「指数部」の意味は「10進数浮動小数点リテラル」の場合は、10進数による桁移動、「16進数浮動小数点リテラル」の場合は、2進数による桁移動になります。
      </p>
      <p>
        末尾に「f」あるいは「F」のサフィックスをつけると、浮動小数点リテラルの型は「float型」になります。
      </p>
      <p>
        末尾に「d」あるいは「D」のサフィックスをつけると、浮動小数点リテラルの型は「double型」になります。
      </p>
      <p>
        サフィックスが省略された場合は、浮動小数点リテラルの型は「double型」になります。
      </p>
      <p>
        浮動小数点リテラルが「float型」の場合はC標準の「strtof関数」を使って、文字列からfloat型への変換が行われます。変換が失敗した場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        浮動小数点リテラルが「double型」の場合はC標準の「strtod関数」を使って、文字列からdouble型への変換が行われます。変換が失敗した場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        無限大を表現する浮動小数点リテラルはありません。標準関数である「<a href="#stdfunc-INFINITY">INFINITY関数</a>」「<a href="#stdfunc-INFINITYF">INFINITYF関数</a>」を使用してください。
      </p>
      <p>
        非値を表現する浮動小数点リテラルはありません。標準関数である「<a href="#stdfunc-NAN">NAN関数</a>」「<a href="#stdfunc-NANF">NANF関数</a>」を使用してください。
      </p>
      <p>
        浮動小数点リテラルのサンプルです
      </p>
<pre>
1.32
-1.32
1.32f
1.32F
1.32e3
1.32e-3
1.32E+3
1.32E-3
0x3d3d.edp0
0x3d3d.edp3
0x3d3d.edP3
0x3d3d.edP-3f
</pre>

      <h3 id="language-literal-character">文字リテラル</h2>
      <p>
        文字リテラルは、シングルクォート「'」で囲まれます。
      </p>
      <p>
        文字リテラルの内容は「ひとつのAsciiの印字可能文字」あるいは「ひとつのエスケープ文字」です。
      </p>
      <p>
        文字リテラルの型は「byte型」になります。
      </p>
      <p>
        不正な文字リテラルの場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>エスケープ文字</b>
      </p>
      <table class="toc">
        <tr>
          <th>
            エスケープ文字
          </th>
          <th>
            説明
          </th>
        </tr>
        <tr>
          <td>
            <b>\0</b>
          </td>
          <td>
            Asciiコードの0「NUL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\a</b>
          </td>
          <td>
            Asciiコードの7「BEL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\b</b>
          </td>
          <td>
            Asciiコードの8「BS」
          </td>
        </tr>
        <tr>
          <td>
            <b>\t</b>
          </td>
          <td>
            Asciiコードの9「HT」
          </td>
        </tr>
        <tr>
          <td>
            <b>\n</b>
          </td>
          <td>
            Asciiコードの10「LF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\f</b>
          </td>
          <td>
            Asciiコードの12「FF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\r</b>
          </td>
          <td>
            Asciiコードの13「CR」
          </td>
        </tr>
        <tr>
          <td>
            <b>\"</b>
          </td>
          <td>
            Asciiコードの34「"」
          </td>
        </tr>
        <tr>
          <td>
            <b>\'</b>
          </td>
          <td>
            Asciiコードの39「'」
          </td>
        </tr>
        <tr>
          <td>
            <b>\\</b>
          </td>
          <td>
            Asciiコードの92「\」
          </td>
        </tr>
        <tr>
          <td>
            <b>\xの後ろに二桁の16進数</b>
          </td>
          <td>
            直接Asciiコードを指定します。16進数は「0～9」「a～f」「A～F」で表現します。
          </td>
        </tr>
      </table>
      
      <p>
        <b>文字リテラルのサンプル</b>
      </p>
      <p>
        文字リテラルのサンプルです。
      </p>
<pre>
# 文字リテラル
'a'
'x'

# エスケープ文字を使った文字リテラル
'\a'
'\b'
'\t'
'\n'
'\f'
'\r'
'\"'
'\''
'\\'
'\x0D'
'\x0A'
</pre>
      
      <h3 id="language-literal-string">文字列リテラル</h2>
      <p>
        文字列リテラルは、ダブルクォート「"」で囲まれます。
      </p>
      <p>
        文字列リテラルの内容は「0個以上のAsciiの印字可能文字あるいはエスケープ文字」です。
      </p>
      <p>
        文字列リテラルの型は「string型」になります。
      </p>
      <p>
        不正な文字列リテラルの場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>エスケープ文字</b>
      </p>
      <table class="toc">
        <tr>
          <th>
            エスケープ文字
          </th>
          <th>
            説明
          </th>
        </tr>
        <tr>
          <td>
            <b>\0</b>
          </td>
          <td>
            Asciiコードの0「NUL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\a</b>
          </td>
          <td>
            Asciiコードの7「BEL」
          </td>
        </tr>
        <tr>
          <td>
            <b>\b</b>
          </td>
          <td>
            Asciiコードの8「BS」
          </td>
        </tr>
        <tr>
          <td>
            <b>\t</b>
          </td>
          <td>
            Asciiコードの9「HT」
          </td>
        </tr>
        <tr>
          <td>
            <b>\n</b>
          </td>
          <td>
            Asciiコードの10「LF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\f</b>
          </td>
          <td>
            Asciiコードの12「FF」
          </td>
        </tr>
        <tr>
          <td>
            <b>\r</b>
          </td>
          <td>
            Asciiコードの13「CR」
          </td>
        </tr>
        <tr>
          <td>
            <b>\"</b>
          </td>
          <td>
            Asciiコードの34「"」
          </td>
        </tr>
        <tr>
          <td>
            <b>\'</b>
          </td>
          <td>
            Asciiコードの39「'」
          </td>
        </tr>
        <tr>
          <td>
            <b>\\</b>
          </td>
          <td>
            Asciiコードの92「\」
          </td>
        </tr>
        <tr>
          <td>
            <b>\xの後ろに二桁の16進数</b>
          </td>
          <td>
            直接Asciiコードを指定します。16進数は「0～9」「a～f」「A～F」で表現します。
          </td>
        </tr>
        <tr>
          <td>
            <b>\N{}の中の複数桁の16進数</b>
          </td>
          <td>
            Unicodeのコードポイントを16進数で指定します。UTF-8に変換されます。16進数は「0～9」「a～f」「A～F」で表現します。
          </td>
        </tr>
        <tr>
          <td>
            <b>\s</b>
          </td>
          <td>
            Asciiコードの92、115の並び「\s」
          </td>
        </tr>
        <tr>
          <td>
            <b>\S</b>
          </td>
          <td>
            Asciiコードの92、83の並び「\S」
          </td>
        </tr>
        <tr>
          <td>
            <b>\d</b>
          </td>
          <td>
            Asciiコードの92、100の並び「\d」
          </td>
        </tr>
        <tr>
          <td>
            <b>\D</b>
          </td>
          <td>
            Asciiコードの92、68の並び「\D」
          </td>
        </tr>
        <tr>
          <td>
            <b>\w</b>
          </td>
          <td>
            Asciiコードの92、119の並び「\w」
          </td>
        </tr>
        <tr>
          <td>
            <b>\W</b>
          </td>
          <td>
            Asciiコードの92、87の並び「\W」
          </td>
        </tr>
        <tr>
          <td>
            <b>\の後ろに「a～z」「A～Z」「0-9」「"」「'」「\」「$」以外のAsciiコードがきた場合</b>
          </td>
          <td>
            Asciiコードの92、アスキーコードで表現される文字の並び。たとえば「\-」の場合は「\-」。
          </td>
        </tr>
      </table>
      <p>
        Unicodeのコードポイントを指定するエスケープ文字以外は、<a href="#language-literal-character">文字リテラル</a>のエスケープ文字と共通です。
      </p>
      <p>
        <b>文字列リテラルのサンプル</b>
      </p>
      <p>
        文字列リテラルのサンプルです。
      </p>
<pre>
# 文字列リテラル
"abc"
"あいう"

# エスケープ文字を使った文字列リテラル
"abc\tdef\n"
"\x0D\x0A"
"\N{U+3042}\N{U+3044}\N{U+3046}"
</pre>

      <h3 id="language-literal-string-variable-expansion">変数展開</h2>
      <p>
        文字列リテラル中のレキシカル変数、パッケージ変数、デリファレンス、フィールドアクセス、定数の添え字の配列アクセス、例外変数の場合は、変数展開が行われます。
      </p>
<pre>
"AAA $foo BBB"
"AAA $FOO BBB"
"AAA $$foo BBB"
"AAA $foo->{x} BBB"
"AAA $foo->[3] BBB"
"AAA $foo->{x}[3] BBB"
"AAA $@ BBB"
</pre>
      <p>
        上記は、以下のように展開されます。
      </p>
<pre>
"AAA" . $foo . "BBB"
"AAA" . $FOO . "BBB"
"AAA" . $$foo . "BBB"
"AAA" . $foo->{x} . "BBB"
"AAA" . $foo->[3] . "BBB"
"AAA" . $foo->{x}[3] . "BBB"
"AAA" . $@ . "BBB"
</pre>
      
      <p>
        変数名の終わりを表すために「{」と「}」で変数名を囲むことができます。
      </p>
<pre>
"AAA ${foo}_ccc BBB"
</pre>
      <p>
        上記は、以下のように展開されます。
      </p>
<pre>
"AAA " . ${foo} . "_ccc BBB"
</pre>
      <p>
        「{」と「}」の囲みがない場合は、変数名として正しい文字列までを変数として解釈します。デリファレンスの場合も同じです。
      </p>
      <p>
        変数名の後ろに「->」が続いた場合は、フィールドアクセス、あるいは、配列アクセスと解釈します。
      </p>
      <p>
        1. その後ろに、続く文字が「a-z」「A-Z」「0-9」「_」「{」「[」であった場合は、解釈を進めます。
      </p>
      <p>
        2. 「1.」の後ろに続く文字が「}」「]」であった場合は、その次の文字が「->」「{」「[」であった場合は、解釈を進め、1に戻ります。そうでない場合は、解釈を止めます。
      </p>
      <p>
        末尾の$は変数展開の開始としては扱われず「$」として扱われます。
      </p>
<pre>
"AAA$"
</pre>

      <h2 id="language-string">文字列</h2>
      <p>
        SPVMの文字列のデータ表現は、byte型の配列です。特別な内部表現を持たない、単なるバイト列です。
      </p>
<pre>
my $string = new byte[3];
$string->[0] = 'a';
$string->[1] = 'b';
$string->[2] = 'c';
</pre>
      <p>
        byte型の配列は、<a href="#language-type-string">文字列型</a>に代入できます。文字列型は、コンパイル時には要素を変更できない型ですが、実行時はbyte型の配列になります。
      </p>
<pre>
my $string_const : string = $string;
</pre>
      <p>
        <a href="#language-literal-string">文字列リテラル</a>を代入することによって、文字列を作成できます。文字列リテラルを元にしたstring型の新しい文字列を返します。
      </p>
<pre>
my $string_const = "abc";
</pre>
      <p>
        byte[]はC言語の「char*」、文字列型はC言語の「const char*」に該当するように設計されています。
      </p>
      
      <h2 id="language-undef">未定義値</h2>
      <p>
        未定義は「undef」で表現されます。
      </p>
<pre>
undef
</pre>

      <h2 id="language-fat-comma">ファットカンマ</h2>
      <p>
        ファットカンマは「=>」で表現されます。
      </p>
<pre>
=>
</pre>
      <p>
        ファットカンマは「,」のエイリアスです。「,」が使える場所ではいつでも代わりに、ファットカンマが使えます。
      </p>
<pre>
# カンマ
["a", "b", "c", "d"]

# カンマの代わりにファットカンマを使う
["a" => "b", "c" => "d"]
</pre>
      <p>
        ファットカンマの左型に置かれたパッケージ変数名、レキシカル変数名以外の識別子は、<a href="#language-literal-string">文字列リテラル</a>として扱われます。
      </p>

<pre>
# カンマの代わりにファットカンマを使う
["a" => "b", "c" => "d"]

# ファットカンマの左型に置かれた識別子は、文字列リテラルになる。上記と同じ意味
[a => "b", c => "d"]
</pre>

      <p>
        未定義値は、任意のオブジェクト型の変数に代入することができます。
      </p>
      <p>
        未定義値はオブジェクト型の値と「==」「!=」演算子を使用して、比較することができます。未定義値は、生成されたオブジェクトと等しくない事が保証されます。
      </p>
      <p>
        未定義は条件部で使われた場合は、偽になります。
      </p>
      <p>
        未定義値は、エクステンションにおいてC言語の値として利用された場合は、0と等しくなることが保証されます。
      </p>
      <h2 id="language-operator">演算子</h2>
      <ul class="list">
        <li><a href="#language-operator-summary">演算子の概要</a></li>
        <li><a href="#language-operator-unary">単項演算子</a></li>
        <li><a href="#language-operator-binary">二項演算子</a></li>
        <li><a href="#language-operator-sequential">順次演算子</a></li>
        <li><a href="#language-operator-arithmetic">算術演算子</a></li>
        <li><a href="#language-operator-unary-plus">単項プラス演算子</a></li>
        <li><a href="#language-operator-unary-minus">単項マイナス演算子</a></li>
        <li><a href="#language-operator-add">加算演算子</a></li>
        <li><a href="#language-operator-subtract">減算演算子</a></li>
        <li><a href="#language-operator-multiply">乗算演算子</a></li>
        <li><a href="#language-operator-divide">除算演算子</a></li>
        <li><a href="#language-operator-remainder">剰余演算子</a></li>
        <li><a href="#language-operator-inc">インクリメント演算子</a></li>
        <li><a href="#language-operator-dec">デクリメント演算子</a></li>
        <li><a href="#language-operator-bit">ビット演算子</a></li>
        <li><a href="#language-operator-bit-and">ビットAND演算子</a></li>
        <li><a href="#language-operator-bit-or">ビットOR演算子</a></li>
        <li><a href="#language-operator-bit-not">ビット否定演算子</a></li>
        <li><a href="#language-operator-shift">シフト演算子</a></li>
        <li><a href="#language-operator-left-shift">左シフト演算子</a></li>
        <li><a href="#language-operator-arithmetic-right-shift">算術右シフト演算子</a></li>
        <li><a href="#language-operator-logical-right-shift">論理右シフト演算子</a></li>
        <li><a href="#language-operator-comparison">比較演算子</a></li>
        <li><a href="#language-operator-comparison-numeric">数値比較演算子</a></li>
        <li><a href="#language-operator-comparison-string">文字列比較演算子</a></li>
        <li><a href="#language-operator-isa">isa演算子</a></li>
        <li><a href="#language-operator-logical">論理演算子</a></li>
        <li><a href="#language-operator-logical-and">論理AND演算子</a></li>
        <li><a href="#language-operator-logical-or">論理OR演算子</a></li>
        <li><a href="#language-operator-logical-not">論理NOT演算子</a></li>
        <li><a href="#language-operator-concat">文字列連結演算子</a></li>
        <li><a href="#language-operator-assign">代入演算子</a></li>
        <li><a href="#language-operator-assign-special">特殊代入演算子</a></li>
        <li><a href="#language-operator-ref">リファレンス演算子</a></li>
        <li><a href="#language-operator-array-length">配列長演算子</a></li>
        <li><a href="#language-operator-string-length">文字列長演算子</a></li>
        <li><a href="#language-operator-scalar">スカラ演算子</a></li>
        <li><a href="#language-operator-isweak">isweak演算子</a></li>
      </ul>
      
      <h3 id="language-operator-summary">演算子の概要</h3>
      <p>
        演算子は、<a href="#language-operator-unary">単項演算子</a>、<a href="#language-operator-binary">二項演算子</a>、<a href="#language-operator-inc">インクリメント演算子</a>、<a href="#language-operator-dec">デクリメント演算子</a>、<a href="#language-operator-comparison">比較演算子</a>、<a href="#language-operator-logical">論理演算子</a>、<a href="#language-operator-assign">代入演算子</a>からなります。
      </p>
      
      <h3 id="language-operator-unary">単項演算子</h3>
      <p>
        単項演算子とは、<a href="#language-expresssion">式</a>の前に置かれる演算子のことをいいます。
      </p>
<pre>
単項演算子 式
</pre>
      <p>
        単項演算子には、<a href="#language-operator-unary-plus">単項プラス演算子</a>、<a href="#language-operator-unary-minus">単項マイナス演算子</a>、<a href="#language-operator-bit-not">ビット否定演算子</a>、<a href="#language-operator-logical-not">論理否定演算子</a>、<a href="#language-operator-array-legnth">配列長演算子</a>、<a href="#language-operator-string-legnth">文字列長演算子</a>があります。
      </p>
      <p>
        インクリメント演算子とデクリメント演算子は、単項演算子には含まれません。
      </p>

      <h3 id="language-operator-binary">二項演算子</h3>
      <p>
        二項演算子とは、左式と右式の間に置かれる演算子のことをいいます。項については、<a href="#language-expresssion">式</a>を参考にしてください。
      </p>
<pre>
左式 二項演算子 右式
</pre>

      <p>
        二項演算子には、<a href="#language-operator-add">加算演算子</a>、<a href="#language-operator-subtract">減算演算子</a>、<a href="#language-operator-multiply">乗算演算子</a>、<a href="#language-operator-divide">除算演算子</a>、<a href="#language-operator-remainder">剰余演算子</a>、<a href="#language-operator-bit-and">ビットAND演算子</a>、<a href="#language-operator-bit-or">ビットOR演算子</a>、<a href="#language-operator-logical-and">論理AND演算子</a>、<a href="#language-operator-logical-or">論理OR演算子</a>、<a href="#language-operator-shift">シフト演算子</a>、<a href="#language-operator-concat">文字列連結演算子</a>があります。
      </p>
 
      <h3 id="language-operator-sequential">順次演算子</h3>
      <p>
        順次演算子とは、複数の<a href="#language-expression">式</a>を並べて記述でき、最後の値を返す演算子のことです。
      </p>
<pre>
(式1, 式2, 式3)
</pre>
      <p>
        式は左から実行されます。最後の値が返されます。
      <p>
      <p>
        順次演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>順次演算子のサンプル</b>
      </p>
      <p>
        順次演算子のサンプルです。
      </p>
<pre>
# $fooには3が代入される。
my $foo = (1, 2, 3);

# $xは3、$retは5になる
my $x = 1;
my $y = 2;
my $ret = ($x += 2, $x + $y);
</pre>

      <li><a href="#language-operator-sequential">順次演算子</a></li>

      <h3 id="language-operator-arithmetic">算術演算子</h3>
      <p>
        算術演算子は、算術を行う演算子のことで、<a href="#language-operator-add">加算演算子</a>、<a href="#language-operator-subtract">減算演算子</a>、<a href="#language-operator-multiply">乗算演算子</a>、<a href="#language-operator-divide">除算演算子</a>、<a href="#language-operator-remainder">剰余演算子</a>、<a href="#language-operator-unary-plus">単項プラス演算子</a>、<a href="#language-operator-unary-minus">単項マイナス演算子</a>、<a href="#language-operator-inc">インクリメント演算子</a>、<a href="#language-operator-dec">デクリメント演算子</a>からなります。
      </p>

      <h3 id="language-operator-unary-plus">単項プラス演算子</h3>
      <p>
        単項プラス演算子は「+」で表現される<a href="#language-operator-unary">単項演算子</a>です。
      </p>
<pre>
+式
</pre>
      <p>
        式は<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <a href="#language-expression">式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、単項プラス演算子は、与えられた値をコピーして返します。
      </p>
      <p>
        単項プラス演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        単項プラス演算子の戻り値の型は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
      </p>
      <p>
        単項プラス演算子は例外を発生させません。
      </p>
      <p>
        <b>単項プラス演算子のサンプル</b>
      </p>
<pre>
my $num = +10;
</pre>
      <h3 id="language-operator-unary-minus">単項マイナス演算子</h3>
      <p>
        単項マイナス演算子は「-」で表現される<a href="#language-operator-unary">単項演算子</a>です。
      </p>
<pre>
-式
</pre>
      <p>
        式は<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <a href="#language-expression">式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、単項マイナス演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
-x
</pre>
      <p>
        単項マイナス演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        単項マイナス演算子の戻り値の型は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
      </p>
      <p>
        単項マイナス演算子は例外を発生させません。
      </p>
      <p>
        <b>単項マイナス演算子のサンプル</b>
      </p>
<pre>
my $num = -10;
</pre>
      <h3 id="language-operator-add">加算演算子</h3>
      <p>
        加算演算子は「+」で表現される、加算を行うための<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 + 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、加算演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
x + y;
</pre>
      <p>
        加算演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        加算演算子の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        加算演算子は、例外を発生させません。
      </p>
      <h3 id="language-operator-subtract">減算演算子</h3>
      <p>
        減算演算子は「-」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 - 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、減算演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
x - y;
</pre>
      <p>
        減算演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        減算演算子の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        減算演算子は、例外を発生させません。
      </p>
      <h3 id="language-operator-multiply">乗算演算子</h3>
      <p>
        乗算演算子は「*」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 * 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、乗算演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
x * y;
</pre>
      <p>
        乗算演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        乗算演算子の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        乗算演算子は、例外を発生させません。
      </p>
      <h3 id="language-operator-divide">除算演算子</h3>
      <p>
        除算演算子は「/」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 / 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、除算演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
      </p>
<pre>
x / y;
</pre>
      <p>
        除算演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        除算演算子の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        整数型に対する演算の場合には、除算演算子は、右辺が0であった場合に、例外が発生します。
      </p>
      <p>
        浮動小数点型に対する演算の場合には、除算演算子は、例外を発生させません。
      </p>
      
      <h3 id="language-operator-remainder">剰余演算子</h3>
      <p>
        剰余演算子は「%」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 % 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、剰余演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x % y;
</pre>
      <p>
        剰余演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        剰余演算子の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        剰余演算子は、右辺が0であった場合に、例外が発生します。
      </p>

      <h3 id="language-operator-inc">インクリメント演算子</h3>
      <p>
        インクリメント演算子は、値を1加算する演算子です。インクリメント演算子が前置されるか、後置されるかで、意味が変わります。
      </p>
<pre>
# 前置のインクリメント
++レキシカル変数
++パッケージ変数
++フィールドへのアクセス
++配列へのアクセス
++デリファレンス

# 後置のインクリメント
レキシカル変数++
パッケージ変数++
フィールドへのアクセス++
配列へのアクセス++
デリファレンス++
</pre>
      <p>
        インクリメント演算子の対象は、<a href="#language-lex-var">レキシカル変数</a>、<a href="#language-package-var">パッケージ変数</a>、<a href="#language-field-access">フィールドへのアクセス</a>、<a href="#language-array-access">配列へのアクセス</a>、<a href="#language-deref">デリファレンス</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        インクリメント演算子の対象の型は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイルエラーが発生します。
      </p>
      <p>
        <b>前置のインクリメント演算子</b>
      </p>
      <p>
        前置のインクリメント演算子は、インクリメントを行った後に、インクリメントされた値を返します。
      </p>
      <p>
        前置のインクリメント演算子は、次の式と等価です。対象に1が加算された後に、元の型で型キャストが行われ、対象に代入されます。
      </p>
<pre>
(対象 = (型キャスト)(対象 + 1))
</pre>
      <p>
        たとえば、byte型の値の前置のインクリメントは、次の式と等価です。
      </p>

<pre>
($num = (byte)($num + 1))
</pre>
      <p>
        <b>後置のインクリメント演算子</b>
      </p>
      <p>
        後置のインクリメント演算子は、インクリメントを行った後に、インクリメントする前の値を返します。
      </p>
      <p>
        後置のインクリメント演算子は、順次演算子を使った、次の式と等価です。対象が一時変数に保存され、対象に1が足された後に、元の型で型キャストが行われ、対象に代入されます。その後、一時変数が返されます。
      </p>
<pre>
(my 一時変数 = 対象, 対象 = (型キャスト)(対象 + 1), 一時変数)
</pre>
      <p>
        たとえば、byte型の値の後置のインクリメントは、次の式と等価です。
      </p>

<pre>
(my $tmp = $num, $num = (byte)($num + 1), $tmp)
</pre>

      <h3 id="language-operator-dec">デクリメント演算子</h3>
      <p>
        デクリメント演算子は、値を1減算する演算子です。デクリメント演算子が前置されるか、後置されるかで、意味が変わります。
      </p>
<pre>
# 前置のデクリメント
--レキシカル変数
--パッケージ変数
--フィールドへのアクセス
--配列へのアクセス
--デリファレンス

# 後置のデクリメント
レキシカル変数--
パッケージ変数--
フィールドへのアクセス--
配列へのアクセス--
デリファレンス--
</pre>
      <p>
        デクリメント演算子の対象は、<a href="#language-lex-var">レキシカル変数</a>、<a href="#language-package-var">パッケージ変数</a>、<a href="#language-field-access">フィールドへのアクセス</a>、<a href="#language-array-access">配列へのアクセス</a>、<a href="#language-deref">デリファレンス</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        デクリメント演算子の対象の型は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイルエラーが発生します。
      </p>
      <p>
        <b>前置のデクリメント演算子</b>
      </p>
      <p>
        前置のデクリメント演算子は、デクリメントを行った後に、デクリメントされた値を返します。
      </p>
      <p>
        前置のデクリメント演算子は、次の式と等価です。対象に1が減算された後に、元の型で型キャストが行われ、対象に代入されます。
      </p>
<pre>
(対象 = (型キャスト)(対象 - 1))
</pre>
      <p>
        たとえば、byte型の値の前置のデクリメントは、次の式と等価です。
      </p>

<pre>
($num = (byte)($num - 1))
</pre>
      <p>
        <b>後置のデクリメント演算子</b>
      </p>
      <p>
        後置のデクリメント演算子は、デクリメントを行った後に、デクリメントする前の値を返します。
      </p>
      <p>
        後置のデクリメント演算子は、順次演算子を使った、次の式と等価です。対象が一時変数に保存され、対象に1が足された後に、元の型で型キャストが行われ、対象に代入されます。その後、一時変数が返されます。
      </p>
<pre>
(my 一時変数 = 対象, 対象 = (型キャスト)(対象 - 1), 一時変数)
</pre>
      <p>
        たとえば、byte型の値の後置のデクリメントは、次の式と等価です。
      </p>

<pre>
(my $tmp = $num, $num = (byte)($num - 1), $tmp)
</pre>

      <h3 id="language-operator-bit">ビット演算子</h3>
      <p>
        ビット演算子は、ビット演算を行う演算子のことで、><a href="#language-operator-bit-and">ビットAND演算子</a>、<a href="#language-operator-bit-or">ビットOR演算子</a>、<a href="#language-operator-bit-not">ビット否定演算子</a>からなります。
      </p>
      
      <h3 id="language-operator-bit-and">ビットAND演算子</h3>
      <p>
        ビットANDは「&」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 & 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、ビットAND演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x & y;
</pre>
      <p>
        ビットAND演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        ビットAND演算子の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        ビットAND演算子は、例外を発生させません。
      </p>

      <h3 id="language-operator-bit-or">ビットOR演算子</h3>
      <p>
        ビットORは「|」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 | 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、ビットOR演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x | y;
</pre>
      <p>
        ビットOR演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        ビットOR演算子の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
      </p>
      <p>
        ビットOR演算子は、例外を発生させません。
      </p>
      
      <h3 id="language-operator-bit-not">ビット否定演算子</h3>
      <p>
        ビット否定演算子は「~」で表現される<a href="#language-operator-unary">単項演算子</a>です。
      </p>
<pre>
~式
</pre>
      <p>
        式は<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <a href="#language-expression">式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、ビット否定演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
~x
</pre>
      <p>
        ビット否定演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        ビット否定演算子の戻り値の型は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
      </p>
      <p>
        ビット否定演算子は例外を発生させません。
      </p>
      <p>
        <b>ビット否定演算子のサンプル</b>
      </p>
<pre>
my $num = ~0xFF0A;
</pre>

      <h3 id="language-operator-shift">シフト演算子</h3>
      <p>
        シフト演算子は、ビットシフトを行う演算子で、<a href="#language-operator-left-shift">左シフト演算子</a>、<a href="#language-operator-arithmetic-right-shift">算術右シフト演算子</a>、<a href="#language-operator-logical-right-shift">論理右シフト演算子</a>からなります。
      </p>
      <h3 id="language-operator-left-shift">左シフト演算子</h3>
      <p>
        左シフトは「<<」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 << 右式
</pre>
      <p>
        左式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        最初に<a href="#language-expression">左式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        右式は、int型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        左シフト演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x << y;
</pre>
      <p>
        左シフト演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        左シフト演算子は、例外を発生させません。
      </p>

      <h3 id="language-operator-arithmetic-right-shift">算術右シフト演算子</h3>
      <p>
        算術右シフトは「>>」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 >> 右式
</pre>
      <p>
        左式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        最初に<a href="#language-expression">左式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        右式は、int型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        算術右シフト演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。xに対して、<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
x >> y;
</pre>
      <p>
        算術右シフト演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        算術右シフト演算子は、例外を発生させません。
      </p>

      <h3 id="language-operator-logical-right-shift">論理右シフト演算子</h3>
      <p>
        論理右シフトは「>>>」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 >>> 右式
</pre>
      <p>
        左式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        最初に<a href="#language-expression">左式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        右式は、int型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      <p>
      <p>
        論理右シフト演算子の演算結果は、C99における以下の演算と完全に一致する演算を行います。xに対して、<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
      </p>
<pre>
(符号付整数型キャスト)((符号なし整数型キャスト)x >> y);
</pre>
      <p>
        論理右シフト演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        論理右シフト演算子は、例外を発生させません。
      </p>

      <h3 id="language-operator-comparison">比較演算子</h3>
      <p>
        比較演算子とは、左式と右式の間に置かれる演算子で、<a href="#language-expression">式</a>を返す演算子のことをいいます。
      </p>
<pre>
左式 比較演算子 右式
</pre>
      <p>
        比較演算子には、<a href="#language-operator-comparison-numeric">数値比較演算子</a>、<a href="#language-operator-comparison-string">文字列比較演算子</a>、isa演算子があります。
      </p>
      
      <h3 id="language-operator-comparison-numeric">数値比較演算子</h3>
      <p>
        数値比較演算子とは、数値あるいはオブジェクトのアドレスを比較するために、左式と右式の間に置かれる演算子で、<a href="#language-expression">式</a>を返す演算子のことをいいます。
      </p>
<pre>
左式 数値比較演算子 右式
</pre>
      <p>
        数値比較演算子の一覧です。
      </p>
      <table>
        <tr>
          <th>演算子</th>
          <th>比較可能な型</th>
          <th>解説</th>
        </tr>
        <tr>
          <td>
            左式 == 右式
          </td>
          <td>
            左式と右式が数値型、左式と右式がオブジェクト型(未定義値を含む)
          </td>
          <td>
            左式と右式が等しい
          </td>
        </tr>
        <tr>
          <td>
            左式 != 右式
          </td>
          <td>
            左式と右式が数値型、左式と右式がオブジェクト型(未定義値を含む)
          </td>
          <td>
            左式と右式が等しくない
          </td>
        </tr>
        <tr>
          <td>
            左式 > 右式
          </td>
          <td>
            左式と右式が数値型
          </td>
          <td>
            左式は右式より大きい
          </td>
        </tr>
        <tr>
          <td>
            左式 >= 右式
          </td>
          <td>
            左式と右式が数値型
          </td>
          <td>
            左式は右式より大きいまたは等しい
          </td>
        </tr>
        <tr>
          <td>
            左式 < 右式
          </td>
          <td>
            左式と右式が数値型
          </td>
          <td>
            左式は右式より小さい
          </td>
        </tr>
        <tr>
          <td>
            左式 <= 右式
          </td>
          <td>
            左式と右式が数値型
          </td>
          <td>
            左式は右式より小さいまたは等しい
          </td>
        </tr>
      </table>
      <p>
        左辺と右辺の型は、比較可能な型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        数値型の比較の場合は、左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
      </p>
      <p>
        その後、数値比較演算子は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型、オブジェクト型における演算が定義されます。
      </p>
<pre>
# 数値型の比較、オブジェクト型の比較
(int32_t)(x == y);
(int32_t)(x != y);

# 数値型の比較
(int32_t)(x > y);
(int32_t)(x >= y);
(int32_t)(x < y);
(int32_t)(x <= y);
</pre>
      <p>
        数値比較演算子の戻り値の型は、int型です。
      </p>
      <p>
        数値比較演算子は、例外を発生させません。
      </p>

      <h3 id="language-operator-comparison-string">文字列比較演算子</h3>
      <p>
        文字列比較演算子とは、文字列を比較するために、左式と右式の間に置かれる演算子で、<a href="#language-expression">式</a>を返す演算子のことをいいます。
      </p>
<pre>
左式 文字列比較演算子 右式
</pre>
      <p>
        左式と右式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
      </p>
      <p>
        文字列比較演算子の一覧です。
      </p>
      <table>
        <tr>
          <th>演算子</th>
          <th>解説</th>
        </tr>
        <tr>
          <td>
            左式 eq 右式
          </td>
          <td>
            左式と右式が等しい
          </td>
        </tr>
        <tr>
          <td>
            左式 ne 右式
          </td>
          <td>
            左式と右式が等しくない
          </td>
        </tr>
        <tr>
          <td>
            左式 gt 右式
          </td>
          <td>
            左式は右式より辞書式順序で比較して大きい
          </td>
        </tr>
        <tr>
          <td>
            左式 ge 右式
          </td>
          <td>
            左式は右式より辞書式順序で比較して大きいまたは等しい
          </td>
        </tr>
        <tr>
          <td>
            左式 lt 右式
          </td>
          <td>
            左式は右式より辞書式順序で比較して小さい
          </td>
        </tr>
        <tr>
          <td>
            左式 le 右式
          </td>
          <td>
            左式は右式より辞書式順序で比較して小さいまたは等しい
          </td>
        </tr>
      </table>
      <p>
        文字列比較演算子の戻り値の型は、int型です。条件が満たされた場合は1を、そうでない場合は0を返します。
      </p>
      <h3 id="language-operator-isa">isa演算子</h3>
      <p>
        数値比較演算子とは、数値あるいはオブジェクトのアドレスを比較するために、左式と右式の間に置かれる演算子で、<a href="#language-expression">式</a>を返す演算子のことをいいます。
      </p>
      <p>
        isa演算子とはは、型の適合性をチェックするための演算子で、<a href="#language-expression">式</a>を返します。
      </p>
<pre>
左式 isa 右型
</pre>
      <p>
        isa演算子は、右型に応じて、3種類の動作をします。
      </p>
      <p>
        1. 右型が、<a href="#language-type-numeric">数値型</a>、<a href="#language-type-multi-numeric">複数数値型</a>、<a href="#language-type-any-object">汎用オブジェクト型</a>、<a href="#language-type-ref">リファレンス型</a>の場合は、コンパイル時に左式の型が右型と同一のものであるかをチェックします。同一であった場合はint型で1を、そうでない場合は0を返します。
      </p>
      <p>
        2. 右型が、<a href="#language-type-class">クラス型</a>であった場合は、実行時に左式の型が、クラス型と一致するかをチェックします。一致した場合はint型で1を、そうでない場合は0を返します。左式の型は、オブジェクト型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        3. 右型が、<a href="#language-type-callback">コールバック型</a>であった場合は、実行時に左式の型がクラス型であり、そのクラスがコールバック型を満たすかどうかをチェックします。満たした場合はint型の1を、そうでない場合は0を返します。左式の型は、オブジェクト型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      
      <h3 id="language-operator-logical">論理演算子</h3>
      <p>
        論理演算子は、論理演算を行う演算子のことで、><a href="#language-operator-logical-and">論理AND演算子</a>、<a href="#language-operator-logical-or">論理OR演算子</a>、<a href="#language-operator-logical-not">論理否定演算子</a>からなります。
      </p>
      <p>
        論理演算子は、<a href="#language-expression">式</a>を返します。
      </p>
      
      <h3 id="language-operator-logical-and">論理AND演算子</h3>
      <p>
        論理AND演算子とは、論理AND演算を行うために、「&&」で表現される、<a href="#language-expresssion">式</a>をオペランドとする<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 && 右式
</pre>
      <p>
        論理AND演算子の戻り値の型は、int型です。
      </p>
      <p>
        論理AND演算子は次のように動作します。
      </p>
      <p>
        1. 左式に<a href="#language-type-convertion-bool">ブール型変換</a>を実行します。
      </p>
      <p>
        2. 左式の値が0以外であれば、右式に対して、<a href="#language-type-convertion-bool">ブール型変換</a>を実行し、その値を返します。
      </p>
      <p>
        3. 左式の値が0であれば、その値を返します。
      </p>
      <p>
        論理AND演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        論理AND演算子は、例外を発生させません。
      </p>
      
      <h3 id="language-operator-logical-and">論理OR演算子</h3>
      <p>
        論理OR演算子とは、論理OR演算を行うために、「||」で表現される、<a href="#language-expresssion">式</a>をオペランドとする<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 || 右式
</pre>
      <p>
        論理OR演算子は次のように動作します。
      </p>
      <p>
        論理OR演算子の戻り値の型は、int型です。
      </p>
      <p>
        1. 左式に<a href="#language-type-convertion-bool">ブール型変換</a>を実行します。
      </p>
      <p>
        2. 左式の値が0あれば、右式に対して、<a href="#language-type-convertion-bool">ブール型変換</a>を実行し、その値を返します。
      </p>
      <p>
        3. 左式の値が0以外であれば、その値を返します。
      </p>
      <p>
        論理OR演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        論理OR演算子は、例外を発生させません。
      </p>

      <h3 id="language-operator-logical-and">論理NOT演算子</h3>
      <p>
        論理NOT演算子とは、論理NOT演算を行うために、式の左に置かれる演算子で、「!」で表現される<a href="#language-expression">式</a>を返す<a href="#language-operator-binary">単項演算子</a>です。式については、<a href="#language-expresssion">式</a>を参考にしてください。
      </p>
<pre>
!式
</pre>
      <p>
        論理NOT演算子の戻り値の型は、int型です。
      </p>
      <p>
        論理NOT演算子は、式に<a href="#language-type-convertion-bool">ブール型変換</a>を実行し、その値が0の場合は1を、0以外の値の場合は、0を返します。
      </p>
      <p>
        論理NOT演算子は<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        論理NOT演算子は、例外を発生させません。
      </p>
      
      <h3 id="language-operator-concat">文字列連結演算子</h3>
      <p>
        文字列連結演算子は「.」で表現される<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 . 右式
</pre>
      <p>
        左式あるいは右式が、<a href="#language-type-numeric">数値型</a>であった場合は、<a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a>によって文字列に変換されます。
      </p>
      <p>
        左式と右式はどちらも<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。そうでない場合は、コンパイルエラーになります。
      </p>
      <p>
        文字列連結演算子は、左式と右式で表現される<a href="#language-string">文字列</a>を連結し、新しい文字列を返します。
      </p>
      <p>
        文字列連結演算子は<a href="#language-expression">式</a>を返し、型は<a href="#language-type-string">文字列型</a>です。
      </p>
      <p>
        左式と右式の両方が、<a href="#language-literal-string">文字列リテラル</a>であった場合は、コンパイル時に連結された文字列リテラルが生成されます。パフォーマンスのコストを意識せずに、文字列連結演算子で、文字列リテラルを連結できます。
      </p>
      <p>
        実行時に、左式あるいは右式が<a href="#language-undef">未定義値</a>だった場合は、例外が発生します。
      </p>
      <p>
        <b>文字列連結演算子のサンプル</b>
      </p>
<pre>
my $str = "abc" . "def";
my $str = "def" . 34;
my $str = 123 . 456;
</pre>
      <h3 id="language-operator-assign">代入演算子</h3>
      <p>
        代入演算子は「=」で表現される、代入を行うための<a href="#language-operator-binary">二項演算子</a>です。
      </p>
<pre>
左式 = 右式
</pre>
      <p>
        代入演算子は、右辺と左辺によって、複数の意味を持ちます。各項目を参考にしてください。
      </p>
      <p>
        代入演算子においては、右式が評価された後に、左式が評価されます。これは、原則として、式は左から右へ実行されるということの例外です。
      </p>
      
      <ul>
        <li><a href="#language-expression-set-lex-var">レキシカル変数の値の設定</a></li>
      </ul>
      
      <h3 id="language-operator-assign-special">特殊代入演算子</h3>
      <p>
        特殊代入演算子とは、<a href="#language-operator-binary">二項演算子</a>と<a href="#language-operator-assign">代入演算子</a>の組み合わせで表現される特殊な代入を行う<a href="#language-operator-binary">二項演算子</a>のことです。
      </p>
<pre>
左式 特殊代入演算子 右式
</pre>
      <p>
        左式と右式が<a href="#language-type-compatible">型の互換性</a>を満たさない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <b>特殊代入演算子の一覧</b>
      </p>
      <p>
        特殊代入演算子の一覧です。
      </p>
      <table>
        <tr>
          <td>加算代入演算子</td>
          <td>+=</td>
        </tr>
        <tr>
          <td>減算代入演算子</td>
          <td>-=</td>
        </tr>
        <tr>
          <td>乗算代入演算子</td>
          <td>*=</td>
        </tr>
        <tr>
          <td>除算代入演算子</td>
          <td>/=</td>
        </tr>
        <tr>
          <td>剰余代入演算子</td>
          <td>%=</td>
        </tr>
        <tr>
          <td>ビットAND代入演算子</td>
          <td>&=</td>
        </tr>
        <tr>
          <td>ビットOR代入演算子</td>
          <td>|=</td>
        </tr>
        <tr>
          <td>左シフト代入演算子</td>
          <td><<=</td>
        </tr>
        <tr>
          <td>算術右シフト代入演算子</td>
          <td>>>=</td>
        </tr>
        <tr>
          <td>論理右シフト代入演算子</td>
          <td>>>>=</td>
        </tr>
      </table>
      <p>
        特殊代入演算子は、次のように展開されます。
      </p>
<pre>
# 展開前
左式 特殊代入演算子 右式

# 展開後
左式 代入演算子 (左式の型によるキャスト)(左式 指定された演算子 右式)
</pre>
      <p>
        たとえば、加算代入演算子の場合は、次のように展開されます。
      </p>
<pre>
# 展開前 xはbyte型
$x += 1;

# 展開後
$x = (byte)($x + 1)
</pre>
      <p>
        <b>特殊代入演算子のサンプル</b>
      </p>
      <p>
        特殊代入演算子のサンプルです。
      </p>
<pre>
$x += 1;
$x -= 1;
$x *= 1;
$x /= 1;
$x &= 1;
$x |= 1;
$x ^= 1;
$x %= 1;
$x <<= 1;
$x >>= 1;
$x >>>= 1;
</pre>
      <h3 id="language-operator-ref">リファレンス演算子</h3>
      <p>
        リファレンス演算子は、<a href="#language-type-numeric">数値型</a>または<a href="#language-type-multi-numeric">複数数値型</a>の変数のアドレスを取得する演算子です。C言語のアドレス演算子「&」を実現するために設計されました。
      </p>
<pre>
\変数
</pre>
      <p>
        変数が数値型または複数数値型でなかった場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        リファレンス演算子は式を返します。返される型は、<a href="#language-type-ref">リファレンス型</a>です。
      </p>
      <pre>
        <b>リファレンス演算子のサンプル</b>
      </pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
</pre>
      <p>
        リファレンスの詳しい解説については、<a href="#language-ref">リファレンス</a>を見てください。
      </p>

      <h3 id="language-operator-array-length">配列長演算子</h3>
      <p>
        配列長演算子は、<a href="#language-array">配列</a>の長さを取得するための「@」で表現される<a href="#language-operator-binary">単項演算子</a>です。
      </p>
<pre>
@右式
</pre>
      <p>
        右式は、配列型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        配列長演算子は、配列の長さをint型の値で返します。
      </p>
      <p>
        配列長演算子は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>配列長演算子のサンプル</b>
      </p>
      <p>
        配列長演算子のサンプルです。
      </p>
<pre>
my $nums = new byte[10];
my $length = @$nums;
</pre>
      <p>
        SPVMにはPerlにおけるコンテキストという考え方はなく、配列長演算子は、常に配列の長さを返すことに注意してください。
      </p>

      <h3 id="language-operator-string-length">文字列長演算子</h3>
      <p>
        文字列長演算子は、<a href="#language-string">文字列</a>の長さを取得するための「length」で表現される<a href="#language-operator-binary">単項演算子</a>です。
      </p>
<pre>
length 右式
</pre>
      <p>
        右式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        文字列長演算子は、文字列の長さをint型の値で返します。文字列長演算子が返す文字列の長さは、バイト列としてみたときの長さでです。
      </p>
      <p>
        文字列長演算子は、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        <b>文字列長演算子のサンプル</b>
      </p>
      <p>
        文字列長演算子のサンプルです。
      </p>
<pre>
my $nums = "abcde";
my $length = length $nums;
</pre>

      <h3 id="language-operator-scalar">スカラ演算子</h3>
      <p>
        スカラ演算子は、何もしないで、与えられた値そのものを返す演算子です。<a href="language-operator-array-length">配列長演算子</a>の意味を分かりやすくするためだけに用意されています。
      </p>
<pre>
scalar 右式
</pre>
      <p>
        右式は<a href="language-operator-array-length">配列長演算子</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        スカラ演算子は、式を返します。
      </p>
      <p>
        <b>スカラ演算子のサンプル</b>
      </p>
      <p>
        スカラ演算子のサンプルです。
      </p>
<pre>
my $nums = new int[3];
foo(scalar @$nums);
</pre>

      <h3 id="language-operator-isweak">isweak演算子</h2>
      <p>
        isweak演算子は、フィールドが、<a href="#language-weak-ref">ウィークリファレンス</a>かを確認する演算子です。
      </p>
<pre>
isweak 変数->{フィールド名};
</pre>
      <p>
        オブジェクト式の型は、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名は、存在するフィールド名でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドに保存される値の型は、<a href="#language-type-object">オブジェクト型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>だった場合は、偽を返します。これは、<a href="#language-expression">式</a>です。
      </p>
      <p>
        isweak演算子は、フィールドがウィークリファレンスの場合は、int型の1を、そうでない場合は0を返します。これは、<a href="#language-expression">式</a>です。
      </p>

      <h2 id="language-operator-precedence">演算子の優先順位</h2>
      <p>
        演算子の優先順位は、以下の通りです。下にいくほど、優先順位が高くなります。
      </p>
      <table>
        <tr>
          <th>結合方向</th>
          <th>演算子</th>
        </tr>
        <tr>
          <td>
            右結合
          </td>
          <td>
            <ul>
            代入演算子「=」<br>
            加算代入演算子「+=」<br>
            減算代入演算子「-=」<br>
            乗算代入演算子「*=」<br>
            除算代入演算子「/=」<br>
            剰余代入演算子「%=」<br>
            ビットAND代入演算子「&=」<br>
            ビットOR代入演算子「|=」<br>
            ビット排他OR代入演算子「^=」<br>
            左シフト代入演算子「<<=」<br>
            算術右シフト代入演算子「>>=」<br>
            論理右シフト演算子「>>>=」<br>
            文字列結合代入演算子「.=」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            論理OR演算子「||」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            論理AND演算子 「&&」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            ビットOR演算子「|」<br>
            ビットXOR演算子 「^」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            ビットAND演算子「&」
          </td>
        </tr>
        <tr>
          <td>
            非結合
          </td>
          <td>
            数値等価演算子「==」<br>
            数値非等価演算子「!=」<br>
            文字列等価演算子「eq」<br>
            文字列非等価演算子「ne」<br>
          </td>
        </tr>
        <tr>
          <td>
            非結合
          </td>
          <td>
            数値大なり演算子「>」<br>
            数値小なり演算子「<」<br>
            数値大なり等価演算子「>=」<br>
            数値小なり等価演算子「<=」<br>
            文字列大なり演算子「gt」<br>
            文字列大なり等価演算子「ge」<br>
            文字列小なり演算子「lt」<br>
            文字列小なり等価演算子「le」<br>
            isa演算子「isa」
          </td>
        </tr>
        <tr>
          <td>
            左結合 
          </td>
          <td>
            左シフト演算子 「<<」<br>
            符号付き右シフト演算子「>>」<br>
            符号なし右シフト演算子「>>>」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            加算演算子「+」<br>
            減算演算子「-」<br>
            文字列連結演算子「.」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            乗算演算子「*」<br>
            除算演算子「/」<br>
            剰余演算子「%」
          </td>
        </tr>
        <tr>
          <td>
            右結合
          </td>
          <td>
            論理NOT演算子「!」<br>
            ビットNOT演算子「~」<br>
            リファレンス演算子「\」<br>
            プラス演算子「+」<br>
            マイナス演算子「-」<br>
            配列長取得演算子「@」<br>
            デリファレンス演算子「$」<br>
            型キャスト「(型名)」
            スカラ演算子「scalar」<br>
            文字列長取得演算子「length」<br>
            require演算子「require」<br>
          </td>
        </tr>
        <tr>
          <td>
            非結合
          </td>
          <td>
            前置インクリメント演算子「++」<br>
            後置インクリメント演算子「++」<br>
            前置デクリメント演算子「--」<br>
            後置デクリメント演算子「--」
          </td>
        </tr>
        <tr>
          <td>
            左結合
          </td>
          <td>
            アロー演算子「->」<br>
          </td>
        </tr>
      </table>
      <p>
        演算子の優先順位は「()」を使うことによって、最優先にすることができます。
      </p>
<pre>
# a * b が先
a * b + c

# b + c が先
a * (b + c)
</pre>
      
      <h2 id="language-statement">文</h2>
      <p>
        文は、ひとつの処理のことで「<a href="#language-scope-block">スコープブロック</a>」の中に複数記述することができます。<a href="#language-expression">式</a>のように値として評価されることはありません。
      </p>
      <p>
        <b>文の一覧</b>
      </p>
      <p>
        文の一覧です。
      </p>
      <ul class="list">
        <li><a href="#language-statement-if">if文</a></li>
        <li><a href="#language-statement-switch">switch文</a></li>
        <li><a href="#language-statement-case">case文</a></li>
        <li><a href="#language-statement-while">while文</a></li>
        <li><a href="#language-statement-for">for文</a></li>
        <li><a href="#language-statement-default">default文</a></li>
        <li><a href="#language-statement-block-simple">単純ブロック</a></li>
        <li><a href="#language-statement-eval">eval文</a></li>
        <li><a href="#language-statement-ifrequire">if require文</a></li>
        <li><a href="#language-statement-next">next文</a></li>
        <li><a href="#language-statement-last">last文</a></li>
        <li><a href="#language-statement-break">break文</a></li>
        <li><a href="#language-statement-return">return文</a></li>
        <li><a href="#language-statement-die">die文</a></li>
        <li><a href="#language-statement-weaken">weaken文</a></li>
        <li><a href="#language-statement-unweaken">unweaken文</a></li>
        <li><a href="#language-statement-expression">式文</a></li>
        <li><a href="#language-statement-empty">空文</a></li>
      </ul>
      
      <h3 id="language-statement-if">if文</h2>
      <p>
        if文は、条件分岐を行うための文です。
      </p>
<pre>
if (式) {
  
}
</pre>
      <p>
        式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され、値が0以外の場合に、ブロックが実行されます。
      </p>
      <p>
        条件を複数書きたい場合には「elsif文」を続けることができます。 条件判定は上から実行され、それぞれの式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され、値が0以外の場合に対応するブロックが実行されます。
      </p>
<pre>
if (式) {
  
}
elsif(式) {
  
}
</pre>
      <p>
        「else文」を使って、if文あるいは、elsif文が条件を満たさなかった場合の処理を記述することができます。if文とelsif文の条件判定がすべて偽であった場合にelseのブロックの内部の文が実行されます。elsif文は、なくてもかまいません。
      </p>
<pre>
if (式) {
  
}
elsif(式) {
  
}
else {
  
}
</pre>
      <p>
        <b>if文のサンプル</b>
      </p>
      <p>
        if文のサンプルです。
      </p>
<pre>
my $flag = 1;

if ($flag == 1) {
  print "One\n";
}
elsif ($flag == 2) {
  print "Tow\n";
}
else {
  print "Other";
}
</pre>
      <p>
        if文は、内部的には、目には見えない単純なブロックで囲まれています。
      </p>
<pre>
{
  if (式) {
    
  }
}
</pre>
      <p>
        elsifは、内部的には、if文とelse文に展開されます。
      </p>
<pre>
# 展開前
if (式1) {

}
elsif (式2) {

}
else {

}

# 展開後
if (式1) {
}
else {
  if (式2) {
  
  }
  else {
  
  }
}
</pre>
      <p>
        if文の条件部で、変数宣言を行うときは、目には見えない<a href="#language-block-statement-simple">単純なブロック</a>で囲まれていることと、elsifは、内部的には、if文とelse文に展開されるということを、意識してください。
      </p>
<pre>
# 展開前
my $num = 1;
if (my $num = 2) {
  
}
elsif (my $num = 3) {
  
}
else {
  
}

# 展開後
my $num = 1;
{
  if (my $num = 2) {
    
  }
  else {
    {
      if (my $num = 3) {
        
      }
      else {
        
      }
    }
  }
}
</pre>

      <h3 id="language-statement-switch">switch文</h3>
      <p>
        switch文は、int型の整数を条件にして、条件分岐を行うための文です。条件がint型の整数で、たくさんの分岐がある場合は、if文よりも高速です。
      </p>
<pre>
switch (条件式) {
  case 定数1: {
    
    break;
  }
  case 定数2: {
    
    break;
  }
  case 定数n: {
    break;
  }
  default: {
  
  }
}
</pre>
      <p>
        条件式は、<a href="#language-expression">式</a>を指定できます。条件式には、<a href="#language-type-convertion-bool">ブール型変換</a>が実行されます。
      </p>
      <p>
        case文で指定される定数は、byte型かint型の定数でなければなりません。byte型の定数の場合は、コンパイル時に、int型に型変換されます。enum型の値や、int型の定数サブルーチンは、int型の定数として、構文解析時に展開されるので、利用することができます。
      </p>
      <p>
        case文に指定される定数は、重複してはいけません。重複している場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        条件式で指定された値が、case文で指定された値にマッチした場合は、そのcase文の位置にジャンプします。
      </p>
      <p>
        マッチしなかった場合でdefault文が指定されている場合は、default文の位置にジャンプします。default文が指定されていなかった場合は、switchブロックは実行されません。
      </p>
      <p>
        switch文には、少なくともひとつのcase文が必要です。そうでない場合は、コンパイルエラーが発生します。
      </p>
      <p>
        default文は省略可能です。
      </p>
      <p>
        switchブロックの直下に記述できるのはcase文とdefault文だけです。
      </p>
      <p>
        caseとdefaultのブロックは省略することができます。
      </p>
<pre>
switch (条件式) {
  case 定数1:
  case 定数2:
  {
    break;
  }
  default:
}
</pre>
      <p>
        break文を使用した場合は、switchブロックから抜けることができます。
      </p>

<pre>
switch (条件式) {
  case 定数1: {
    break;
  }
  case 定数2: {
    break;
  }
  case 定数n: {
    break;
  }
  default: {
  
  }
}
</pre>
      <p>
        caseのブロックが存在する場合は、最後の文はbreak文あるいは、return文でなければなりません。そうでない場合は、コンパイルエラーが発生します。
      </p>

      <p>
        <b>switch文のサンプル</b>
      </p>
      <p>
        switch文のサンプルです。
      </p>
<pre>
my $code = 2;
switch ($code) {
  case 1: {
    print "1\n";
    break;
  }
  case 2: {
    print "2\n";
    break;
  }
  case 3: {
    print "3\n";
    break;
  }
  case 4:
  case 5:
  {
    print "4 or 5\n"; {
    break;
  }
  default: {
    print "Other\n";
  }
}
</pre>

      <h3 id="language-statement-switch">case文</h3>
      <p>
        case文は、switchブロックの中で使うことができる、条件を指定するための文です。case文についての詳細は、<a href="#language-statement-switch">switch文</a>の解説を見てください。
      </p>

      <h3 id="language-statement-switch">default文</h3>
      <p>
        default文は、switchブロックの中で使うことができる、デフォルトの条件を指定するための文です。default文についての詳細は、<a href="#language-statement-switch">switch文</a>の解説を見てください。
      </p>

      <h3 id="language-statement-while">while文</h3>
      <p>
        while文は、繰り返しを行うための文です。
      </p>
<pre>
while (条件式) {
  
}
</pre>
      <p>
        条件式に、<a href="#language-expresssion">式</a>を記述できます。条件式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され、値が0以外の場合に、ブロックが実行されます。そうでない場合は、ブロックを抜けます。
      </p>
      <p>
        <b>while文のサンプル</b>
      </p>
      <p>
        while文のサンプルです。
      </p>
<pre>
my $i = 0;
while ($i < 5) {
  
  print "$i\n";
  
  $i++;
}
</pre>
      <p>
        whileブロックの内部では、<a href="#language-statement-last">last文</a>を使って、whileブロックを抜けることができます。
      </p>
<pre>
while (1) {
  last;
}
</pre>

      <p>
        whileブロックの内部では、<a href="#language-statement-next">next文</a>を使って、次に実行される条件式の直前に移動することができます。
      </p>
<pre>
my $i = 0;
while ($i < 5) {
  
  if ($i == 3) {
    $i++;
    next;
  }
  
  print "$i\n";
  $i++;
}
</pre>
      
      <p>
        while文は、内部的には、目には見えない<a href="#language-block-statement-simple">単純なブロック</a>で囲まれています。
      </p>
<pre>
{
  while (条件式) {
    
  }
}
</pre>
      <p>
        while文の条件部で、変数宣言を行うときは、目には見えない<a href="#language-block-statement-simple">単純なブロック</a>で囲まれていることを意識してください。
      </p>
<pre>
# 展開前
my $num = 5;
while (my $num = 3) {
  
  $i++;
}

# 展開後
my $num = 5;
{
  while (my $num = 3) {
    
    $i++;
  }
}
</pre>

      <h3 id="language-statement-for">for文</h3>
      <p>
        for文は、繰り返しを行うための文です。
      </p>
<pre>
for (初期化式; 条件式; インクリメント式) {
  
}
</pre>
      <p>
        初期化式には、<a href="#language-expression">式</a>を記述できます。一般的には、ループ変数の初期化などの式を記述します。初期化式は省略することが可能です。
      </p>
      <p>
        条件式、<a href="#language-expresssion">式</a>を記述できます。条件式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され、値が0以外の場合に、ブロックが実行されます。そうでない場合は、ブロックを抜けます。
      </p>
      <p>
        インクリメント式には、<a href="#language-expression">式</a>を記述できます。一般的には、ループ変数のインクリメントの式を記述します。インクリメント式は省略することが可能です。
      </p>
      <p>
        for文は以下のwhile文と同じ意味を持ちます。インクリメント式は、ブロックの最後に実行されます。初期化式は、<a href="#language-block-statement-simple">単純なブロック</a>に囲まれています。
      </p>
<pre>
{
  初期化式;
  while (条件式) {
    
    
    
    インクリメント式;
  }
}
</pre>
      <p>
        <b>for文のサンプル</b>
      </p>
      <p>
        for文のサンプルです。
      </p>
<pre>
for (my $i = 0; $i < 5; $i++) {
  
  print "$i\n";
}
</pre>
      <p>
        forブロックの内部では、<a href="#language-statement-last">last文</a>を使って、forブロックを抜けることができます。
      </p>

<pre>
for (初期化式; 条件式; インクリメント式) {
  
}
</pre>
      
      <p>
        forブロックの内部では、<a href="#language-statement-next">next文</a>を使って、次に実行されるインクリメント式の直前に移動することができます。
      </p>
<pre>
for (my $i = 0; $i < 5; $i++) {
  
  if ($i == 3) {
    next;
  }
}
</pre>

      <h3 id="language-statement-return">return文</h3>
      <p>
        return文を使うと、サブルーチンから脱出します。モータル変数に代入されているオブジェクトは、自動的に解放されます。
      </p>
<pre>
return;
</pre>
      <p>
        戻り値がある場合は、<a href="#language-expression">式</a>を指定することができます。
      </p>
<pre>
return 式;
</pre>
      <p>
        <a href="#language-sub-definition">サブルーチンの定義</a>において戻り値の型が「void型」である場合は、式が存在してはいけません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        <a href="#language-sub-definition">サブルーチンの定義</a>において戻り値の型が「void型」以外の場合は、式の型と一致していなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>

      <h3 id="language-statement-die">die文</h3>
      <p>
        die文は、例外を発生させるための文です。
      </p>
<pre>
die 式;
</pre>
      <p>
        式は、文字列互換型でなければなりません。
      </p>
      <p>
        die文の詳しい解説については、<a href="#language-exception">例外処理</a>を見てください。
      </p>
      
      <h3 id="language-statement-weaken">weaken文</h3>
      <p>
        weaken文は、フィールドに対して、<a href="#language-weak-ref">ウィークリファレンス</a>を設定する文です。
      </p>
<pre>
weaken 変数->{フィールド名};
</pre>
      <p>
        オブジェクト式の型は、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名は、存在するフィールド名でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドに保存される値の型は、<a href="#language-type-object">オブジェクト型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>だった場合は、weaken文は、何もしません。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>でない場合は、次のことが行われます。
      </p>
      <p>
        1. フィールドに保存されているオブジェクトのリファレンスカウントを1減らします。
      </p>
      <p>
        2. フィールドに、ウィークリファレンスフラグを設定します。
      </p>
      <p>
        3. フィールドに保存されているオブジェクトのバックリファレンスに、フィールドを追加します。
      </p>
      <p>
        ウィークリファレンスフラグは、フィールドに保存されているオブジェクトに設定されるのではなく、フィールド自体に設定されることに注意してください。
      </p>
      <p>
        フィールドに保存されているオブジェクトのリファレンスカウントが、0になってしまった場合は、ウィークリファレンスは作成されず、フィールドに保存されているオブジェクトは解放されます。
      </p>
      <p>
        バックリファレンスとは、フィールドに保存されているオブジェクトが持つデータで、ウィークリファレンスフラグが設定されたフィールドを知るために、追加されます。これは、複数存在することがあります。
      </p>
<pre>
# バックリファレンスが、複数あるサンプル
my $foo = new Foo;
my $bar = new Bar;
my $baz = new Baz;

$foo->{bar} = $bar;
$foo->{baz} = $baz;

$bar->{foo} = $foo;
$baz->{foo} = $foo;

weaken $bar->{foo};
weaken $baz->{foo};
</pre>
      <p>
        上記の例では「$bar->{foo}」と「$baz->{foo}」に、ウィークリファレンスフラグが立ちます。$fooで表現されるオブジェクトは、バックリファレンス「$bar->{foo}」と「$baz->{foo}」を持ちます。
      </p>
      <p>
        バックリファレンスの情報が必要なのは、<a href="#language-expression-release-object">オブジェクトの解放</a>が行われるときに、バックリファレンスが指すフィールドに未定義値を代入する必要があるからです。
      </p>

      <h3 id="language-statement-unweaken">unweaken文</h3>
      <p>
        unweaken文は、フィールドに対して、<a href="#language-weak-ref">ウィークリファレンス</a>を解除する文です。
      </p>
<pre>
unweaken 変数->{フィールド名};
</pre>
      <p>
        オブジェクト式の型は、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールド名は、存在するフィールド名でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        フィールドに保存される値の型は、<a href="#language-type-object">オブジェクト型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>だった場合は、unweaken文は、何もしません。
      </p>
      <p>
        実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>でない場合は、次のことが行われます。
      </p>
      <p>
        1. フィールドに保存されているオブジェクトのリファレンスカウントを1増やします。
      </p>
      <p>
        2. フィールドのウィークリファレンスフラグを解除します。
      </p>
      <p>
        3. フィールドに保存されているオブジェクトのバックリファレンスから、フィールドを削除します。
      </p>

      <h3 id="language-statement-next">next文</h3>
      <p>
        「next文」は、次のループの先頭に移動するための文です。<a href="#language-block-statement-while">whileブロック</a>、<a href="#language-block-statement-for">forブロック</a>の中で使うことができます。
      </p>
<pre>
next;
</pre>
      <p>
        実際の動作については<a href="#language-statement-while">while文</a>、<a href="#language-statement-for">for文</a>の解説を見てください。
      </p>

      <h3 id="language-statement-last">last文</h3>
      <p>
        「last文」は、ループを脱出するための文です。<a href="#language-block-statement-while">whileブロック</a>、<a href="#language-block-statement-for">forブロック</a>の中で使うことができます。
      </p>
      <p>
        実際の動作については<a href="#language-statement-while">while文</a>、<a href="#language-statement-for">for文</a>の解説を見てください。
      </p>
<pre>
last;
</pre>

      <h3 id="language-statement-break">break文</h3>
      <p>
        「break文」は、switchブロックを脱出するための文です。<a href="#language-block-statement-switch">switchブロック</a>の中で使うことができます。
      </p>
      <p>
        実際の動作については<a href="#language-statement-switch">switch文</a>の解説を見てください。
      </p>
<pre>
break;
</pre>

      <h3 id="language-statement-expression">式文</h3>
      <p>
        式文は「<a href="#language-expression">式</a>」と「;」で構成される文のことです。
      </p>
<pre>
式;
</pre>

      <p>
        式文のサンプルです。
      </p>
<pre>
1;
$var;
1 + 2;
foo();
my $num = 1 + 2;
</pre>

      <h3 id="language-statement-empty">空文</h3>
      <p>
        空文は「;」だけで終わる文のことです。
      </p>
<pre>
;
</pre>

      <h2 id="language-type">型</h2>
      <ul class="list">
        <li><a href="#language-type-summary">型の概要</a></li>
        <li><a href="#language-type-initial-value">型の初期値</a></li>
        <li><a href="#language-type-void">void型</a></li>
        <li><a href="#language-type-numeric">数値型</a></li>
        <li><a href="#language-type-integral">整数型</a></li>
        <li><a href="#language-type-byte">byte型</a></li>
        <li><a href="#language-type-short">short型</a></li>
        <li><a href="#language-type-int">int型</a></li>
        <li><a href="#language-type-long">long型</a></li>
        <li><a href="#language-type-floating-point">浮動小数点型</a></li>
        <li><a href="#language-type-float">float型</a></li>
        <li><a href="#language-type-double">double型</a></li>
        <li><a href="#language-type-package">パッケージ型</a></li>
        <li><a href="#language-type-object">オブジェクト型</a></li>
        <li><a href="#language-type-numeric-object">数値オブジェクト型</a></li>
        <li><a href="#language-type-undef">未定義型</a></li>
        <li><a href="#language-type-class">クラス型</a></li>
        <li><a href="#language-type-callback">コールバック型</a></li>
        <li><a href="#language-type-any-object">汎用オブジェクト型</a></li>
        <li><a href="#language-type-self">self型</a></li>
        <li><a href="#language-type-array">配列型</a></li>
        <li><a href="#language-type-array-numeric">数値配列型</a></li>
        <li><a href="#language-type-array-byte">byte[]型</a></li>
        <li><a href="#language-type-array-object">オブジェクト配列型</a></li>
        <li><a href="#language-type-array-value">値配列型</a></li>
        <li><a href="#language-type-any-object-array">汎用オブジェクト配列型</a></li>
        <li><a href="#language-type-string">文字列型</a></li>
        <li><a href="#language-type-string-compatible">文字列互換型</a></li>
        <li><a href="#language-type-multi-numeric">複数数値型</a></li>
        <li><a href="#language-type-ref">リファレンス型</a></li>
        <li><a href="#language-type-ref-numeric">数値のリファレンス型</a></li>
        <li><a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a></li>
      </ul>
      <h3 id="language-type-summary">型の概要</h2>
      <p>
        SPVMは、静的型言語です。すべてのデータは静的な型を持ちます。
      </p>
      <p>
        レキシカル変数の宣言、フィールドの定義、パッケージ変数の定義、サブルーチンの定義の引数と戻り値において、型が指定される必要があります。
      </p>
      <p>
        レキシカル変数の宣言においては、型推論を利用して、暗黙的に型を指定することもできます。
      </p>
      <h3 id="language-type-initial-value">型の初期値</h2>
      <p>
        レキシカル変数の初期値、<a href="#language-package-var-initial-value">パッケージ変数の初期値</a>、オブジェクトの生成におけるフィールドの初期値は、型の初期値によって決まります。
      </p>
      <p>
        型の初期化値の一覧です。データにおけるすべてのビット列は0に設定されます。
      </p>
      </p>
      <table>
        <tr>
          <th>
            <b>型名</b>
          </th>
          <th>
            初期値
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            0
          </td>
        </tr>
        <tr>
          <td>
            <b>オブジェクト型</b>
          </td>
          <td>
            undef
          </td>
        </tr>
        <tr>
          <td>
            <b>複数数値型</b>
          </td>
          <td>
            すべてのフィールドが0
          </td>
        </tr>
      </table>
      
      <h3 id="language-type-numeric">数値型</h2>
      <p>
        数値型は「<a href="#language-type-integral">整数型</a>」と「<a href="#language-type-floating-point">浮動小数点型</a>」からなります。
      </p>
      
      <h3 id="language-type-integral">整数型</h2>
      <p>
        SPVMの整数型は以下の4つです。
      </p>
      <table>
        <tr>
          <th>
            <b>型名</b>
          </th>
          <th>
            説明
          </th>
          <th>
            サイズ
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            8bit符号付整数型
          </td>
          <td>
            1バイト
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            16bit符号付整数型
          </td>
          <td>
            2バイト
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            32bit符号付整数型
          </td>
          <td>
            4バイト
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            64bit符号付整数型
          </td>
          <td>
            8バイト
          </td>
        </tr>
      </table>
      <p>
        SPVMの整数型には、符号なし整数型は存在しません。
      </p>
      <p>
        整数の計算規則については、<a href="#language-operator-arithmetic">算術演算子</a>を参考にしてください。
      </p>
      <h3 id="language-type-byte">byte型</h2>
      <p>
        byte型は、符号付8bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint8_t型と同じ型です。
      </p>
      <h3 id="language-type-short">short型</h2>
      <p>
        byte型は、符号付16bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint16_t型と同じ型です。
      </p>
      <h3 id="language-type-int">int型</h2>
      <p>
        int型は、符号付32bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint32_t型と同じ型です。
      </p>
      <h3 id="language-type-long">long型</h2>
      <p>
        long型は、符号付64bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint64_t型と同じ型です。
      </p>
      
      <h3 id="language-type-floating-point">浮動小数点型</h2>
      <p>
        SPVMの浮動小数点型は以下の2つです。
      </p>
      <table>
        <tr>
          <th>
            <b>型名</b>
          </th>
          <th>
            説明
          </th>
          <th>
            サイズ
          </th>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            単精度浮動小数点型 - 32bitで浮動小数点を表現します
          </td>
          <td>
            4バイト
          </td>
        </tr>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            倍精度浮動小数点型 - 64bitで浮動小数点を表現します
          </td>
          <td>
            8バイト
          </td>
        </tr>
      </table>
      <p>
        浮動小数点の計算規則については、<a href="#language-operator-arithmetic">算術演算子</a>を参考にしてください。
      </p>
      
      <h3 id="language-type-float">float型</h2>
      <p>
        float型は、単精度浮動小数点(32bit)を表現する<a href="#language-type-floating-point">浮動小数点型</a>です。C99のfloat型と同じ型です。
      </p>
      
      <h3 id="language-type-double">double型</h2>
      <p>
        double型は、倍精度浮動小数点(64bit)を表現する<a href="#language-type-floating-point">浮動小数点型</a>です。C99のdouble型と同じ型です。
      </p>
      
      <h3 id="language-type-package">パッケージ型</h3>
      <p>
        パッケージ型とは「<a href="#language-package-definition">パッケージの定義</a>」によって定義される型のことをいいます。
      </p>
<pre>
package Foo {

}
</pre>
      <p>
        パッケージ型は「<a href="#language-type-class">クラス型</a>」「<a href="#language-type-callback">コールバック型</a>」「<a href="#language-type-multi-numeric">複数数値型</a>」からなります。
      </p>
<pre>
# クラス型
package Foo {

}

# コールバック型
package Foo : callback_t {

}

# 複数数値型
package Foo : mulnum_t {

}
</pre>
      <p>
        <a href="#language-type-pointer">ポインタ型</a>は、クラス型でもあるので、ポインタ型もパッケージ型になります。
      </p>
<pre>
# ポインタ型
package Foo : pointer_t {

}
</pre>

      <h3 id="language-type-object">オブジェクト型</h3>
      <p>
        オブジェクト型とは「<a href="#language-type-class">クラス型</a>」「<a href="#language-type-callback">コールバック型</a>」「<a href="#language-type-array">配列型</a>」「<a href="#language-type-string">文字列型</a>」「<a href="#language-type-any-object">汎用オブジェクト型</a>」を合わせたものをいいます。「複数数値型」「リファレンス型」は含みません。
      </p>
      <p>
        オブジェクト型の値は「汎用オブジェクト型」に代入できます。
      </p>
<pre>
my $object : object = new Foo;
my $object : object = new Foo[];
my $object : object = "abc";
</pre>
      <p>
        オブジェクト型のサイズはC99における「sizeof(void*)」の値と一致していなければなりません。
      </p>

      <h3 id="language-type-numeric-object">数値オブジェクト型</h3>
      <p>
        SPVMには、数値オブジェクト型として以下の型があります。
      </p>
      <table>
        <tr>
          <th>
            <b>数値型</b>
          </th>
          <th>
            対応する数値オブジェクト型
          </th>
        </tr>
        <tr>
          <td>
            <b>byte</b>
          </td>
          <td>
            SPVM::Byte
          </td>
        </tr>
        <tr>
          <td>
            <b>short</b>
          </td>
          <td>
            SPVM::Short
          </td>
        </tr>
        <tr>
          <td>
            <b>int</b>
          </td>
          <td>
            SPVM::Int
          </td>
        </tr>
        <tr>
          <td>
            <b>long</b>
          </td>
          <td>
            SPVM::Long
          </td>
        </tr>
        <tr>
          <td>
            <b>float</b>
          </td>
          <td>
            SPVM::Float
          </td>
        </tr>
        <tr>
          <td>
            <b>double</b>
          </td>
          <td>
            SPVM::Double
          </td>
        </tr>
      </table>

      <h3 id="language-type-undef">未定義型</h3>
      <p>
        未定義型とは、<a href="#language-undef">未定義値</a>が持っている型のことです。明示的に利用することはできません。
      </p>
      <p>
        未定義型の値は<a href="#language-undef">未定義値</a>のみです。
      </p>
      <p>
        未定義型の値は、オブジェクト型に代入できます。他の型に代入した場合は、コンパイル時エラーが発生します。
      </p>
      
      <h3 id="language-type-class">クラス型</h3>
      <p>
        クラス型とは「<a href="#language-package-definition">パッケージの定義</a>」によって定義される型で「複数数値型」「コールバック型」ではない型のことをいいます。
      </p>
<pre>
packag Foo {
  
}
</pre>
      <p>
        クラス型はnew演算子によって、オブジェクトを生成することができます。
      </p>
<pre>
my $foo = new Foo;
</pre>
      <p>
        クラス型は<a href="#language-type-object">オブジェクト型</a>です。
      </p>
      <p>
        クラス型は<a href="#language-type-package">パッケージ型</a>です。
      </p>
      <p>
        「<a href="#language-type-pointer">ポインタ型</a>はクラス型です。
      </p>

      <h3 id="language-type-pointer">ポインタ型</h3>
      <p>
        ポインタ型とは「<a href="#language-package-definition">パッケージの定義</a>」において「pointer_t デスクリプタ」が指定されたものをいいます。
      </p>
<pre>
package Foo : pointer_t {
  
}
</pre>
      <p>
        ポインタ型は、クラス型の一種です。
      </p>
      <p>
        ポインタ型のデータには、C言語のポインタを保存することができます。
      </p>
      <p>
        ポインタ型には、フィールドを定義することはできません。定義されていた場合は、コンパイル時エラーが発生します。
      </p>
      <h3 id="language-type-callback">コールバック型</h3>
      <p>
        コールバック型とは「<a href="#language-package-definition">パッケージの定義</a>」において「callback_t デスクリプタ」が指定されたものをいいます。
      </p>
<pre>
package SPVM::Comparator : callback_t {
  sub : int ($self : self, $x1 : object, $x2 : object);
}
</pre>
      <p>
        コールバック型は、C言語における関数ポインタに該当する機能を提供するために設計されました。
      </p>
      <p>
        コールバック型は、サブルーチンの定義を一つだけ持ちます。サブルーチンは、<a href="#language-sub-method">メソッド</a>でなければなりません。
      </p>
      <p>
        コールバック型のサブルーチン名は、無名でなければなりません。
      </p>
      <p>
        コールバック型は「<a href="#language-field-definition">フィールドの定義</a>」「<a href="#language-package-var-definition">パッケージ変数の定義</a>」を持つことはできません。
      </p>
      <p>
        コールバック型の値を、new演算子によって実体化することはできません。
      </p>
      <p>
        コールバック型は「パッケージ型」です。
      </p>
      <p>
        コールバック型は「オブジェクト型」です。
      </p>
      <p>
        コールバック型には、コールバックを満たしたクラス型のオブジェクトを代入できます。この場合、クラス型はコールバック型に適合するといいます。クラス型がコールバック型を満たすのは次の二つの場合です。
      </p>
      <p>
        1. コールバック型として定義されたサブルーチンと同一の名前とシグネチャを持つクラス型のオブジェクトは、コールバック型に代入できます。
      </p>
<pre>
# コールバック型の定義
package SPVM::Comparator : callback_t {
  sub : int ($self : self, $x1 : object, $x2 : object);
}

# クラスの定義
package SomeComparator {
  sub new : int () {
    return new SomeComparator;
  }
  
  sub : int ($self : self, $x1 : object, $x2 : object) {
    
  }
}

# コールバック型への代入
my $comparator : SPVM::Comparator = SomeComparator->new;
</pre>
      <p>
        2. コールバック型として定義されたサブルーチンと同一のシグネチャを持つコールバックオブジェクトの生成を行うと、コールバック型に代入できます。
      </p>
<pre>
# コールバック型の定義
package SPVM::Comparator : callback_t {
  sub : int ($self : self, $x1 : object, $x2 : object);
}

# コールバック型への代入
my $comparator : SPVM::Comparator = sub : int ($self : self, $x1 : object, $x2 : object) {
  
}
</pre>

      <h3 id="language-type-any-object">汎用オブジェクト型</h3>
      <p>
        汎用オブジェクト型は「object」で表現します。C言語の「void*」型を表現するために設計されました。
      </p>
<pre>
my $object : object;
</pre>
      <p>
        汎用オブジェクト型には「オブジェクト型」の値を代入できます。
      </p>
<pre>
my $object : object = new Foo;
my $object : object = "abc";
my $object : object = new Foo[3];
</pre>

      <h3 id="language-type-self">self型</h3>
      <p>
        self型とは、自身の属するパッケージ型を表現し、引数がインボカントであることを示します。
      </p>
      <p>
        <a href="#language-sub-definition">サブルーチンの定義</a>において第一引数の型としてのみ利用できます。
      </p>
      
      <h3 id="language-type-void">void型</h3>
      <p>
        void型とは、<a href="#language-sub-definition">サブルーチンの定義</a>において戻り値の型としてだけ利用できる、存在しないことを示す特別な型です。
      </p>
      
      <h3 id="language-type-basic">基本型</h3>
      <p>
        次元を持たない型を基本型と呼びます。<a href="#language-type-numeric">数値型</a>、<a href="#language-type-package">パッケージ型</a>、<a href="#language-type-any-object">汎用オブジェクト型</a>、<a href="#language-type-string">文字列型</a>は、基本型です。
      </p>
      
      <h3 id="language-type-array">配列型</h3>
      <p>
        配列型は、連続した複数のデータ領域を表現します。<a href="#language-type-basic">基本型</a>は、配列にすることができます。
      </p>
<pre>
int[]
double[]
Point[]
object[]
string[]
</pre>
      <p>
        配列は次元を持ち最大255次元まで表現できます。
      </p>
<pre>
# 二次元
int[][]

# 三次元
int[][][]
</pre>
      <p>
        配列型は、<a href="#language-type-object">オブジェクト型</a>です。
      </p>
      <p>
        配列を作成するには、new演算子を使用します。以下の例では、要素数が3のint型の配列を作成しています。
      </p>
<p>
my $nums = new int[3];
</p>
      <p>
        多次元配列を作成するときも、new演算子を使用します。以下の例では、要素数が3のint[]型の配列を作成しています。
      </p>
<p>
my $nums = new int[][3];
</p>
      <h3 id="language-type-array-numeric">数値の配列型</h3>
      <p>
        数値の配列型とは、<a href="#language-type-numeric">数値型</a>の値を要素に持つ<a href="#language-type-array">配列型</a>のことです。
      </p>
      <p>
        <b>数値の配列型の一覧</b>
      </p>
      <ul class="list">
        <li>
          byte[]
        </li>
        <li>
          short[]
        </li>
        <li>
          int[]
        </li>
        <li>
          long[]
        </li>
        <li>
          float[]
        </li>
        <li>
          double[]
        </li>
      </ul>
      <p>
        数値の配列型によって表現されるデータは、要素が<a href="#language-type-numeric">数値型</a>のサイズで、配列の長さの個数で連続していなければなりません。
      </p>
      <p>
        数値の配列型のすべての要素は、配列の生成が行われたときに<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
      </p>
      <h3 id="language-type-array-byte">byte[]型</h3>
      <p>
        SPVMにおいては、byte[]型は<a href="#language-type-string-compatible">文字列互換型</a>であるという点において特別な型です。
      </p>
<pre>
byte[]
</pre>
      <p>
        <a href="#language-type-string">文字列型</a>は、コンパイル時には文字列型として扱われますが、実行時にはbyte[]型になります。
      </p>

      <h3 id="language-type-array-object">オブジェクトの配列型</h3>
      <p>
        オブジェクトの配列型とは、<a href="#language-type-object">オブジェクト型</a>の値を要素に持つ<a href="#language-type-array">配列型</a>のことです。
      </p>
      <p>
        <b>オブジェクトの配列型のサンプル</b>
      </p>
      <ul class="list">
        <li>
          Foo[]
        </li>
        <li>
          Foo[][]
        </li>
        <li>
          Comparable[]
        </li>
        <li>
          object[]
        </li>
      </ul>
      <p>
        オブジェクトの配列型によって表現されるデータは、要素が<a href="#language-type-object">オブジェクト型</a>のサイズで、配列の長さの個数で連続していなければなりません。
      </p>
      <p>
        オブジェクトの配列型のすべての要素は、配列の生成が行われたときに<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
      </p>

      <h3 id="language-type-array-value">値の配列型</h3>
      <p>
        値の配列型とは、<a href="#language-type-multi-numeric">複数数値型</a>の値を要素に持つ<a href="#language-type-array">配列型</a>のことです。
      </p>
      <p>
        <b>値の配列型のサンプル</b>
      </p>
      <ul class="list">
        <li>
          Complex_2d[]
        </li>
        <li>
          Complex_2f[]
        </li>
      </ul>
      <p>
        値の配列型によって表現されるデータは、要素が<a href="#language-type-numeric">複数数値型</a>のサイズで、配列の長さの個数で連続していなければなりません。
      </p>
      <p>
        値の配列型のすべての要素は、配列の生成が行われたときに<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
      </p>

      <h3 id="language-type-any-object-array">汎用オブジェクト配列型</h3>
      <p>
        汎用オブジェクト配列型とは、oarrayで表現される、<a href="#language-type-object">オブジェクト型</a>の値を要素として持つ任意の<a href="#language-type-array">配列型</a>の値を代入できる型です。C言語のqsort関数の第一引数には、任意の配列型をvoid*型にキャストして渡すことができますが、これに該当する機能を実現するために、汎用オブジェクト配列型は設計されました。
      </p>
<pre>
my $array : oarray = new Point[3];
my $array : oarray = new object[3];
</pre>
      <p>
        オブジェクト型以外の型を持つ値が代入された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        「oarray型」は「object[]型」と異なる型であることに注意してください。oarray型は、オブジェクト型の値を要素として持つ任意の配列型の値を代入できる型であるのに対して、「object[]型」は、「object型の値を要素に持つ配列」を表現する型で、任意の配列型の値を代入することはできません。
      </p>
      <p>
        汎用オブジェクト配列型は、<a href="#language-type-array">配列型</a>です。<a href="#language-operator-array-length">配列長演算子</a>によって長さを取得すること、<a href="#language-expression-set-array-element">配列の要素の値の設定</a>、<a href="#language-expression-get-array-element">配列の要素の値の取得</a>ができます。
      </p>
<pre>
my $array : oarray = new SPVM::Int[3];

# 汎用オブジェクト配列型の要素の長さを取得
my $legnth = @$array;

# 汎用オブジェクト配列型の要素の値の取得
my $num = (SPVM::Int)$array->[0];

# 汎用オブジェクト配列型の要素の値の設定
$array->[0] = SPVM::Int->new(5);
</pre>
      <p>
        汎用オブジェクト配列型の要素の値の設定においては、要素の型が、配列の型の次元よりも1だけ小さくなっているかの実行時チェックが入ります。チェックに失敗した場合は、例外が発生します。汎用オブジェクト配列型は、実行時型安全性を保証します。
      </p>

      <h3 id="language-type-string">文字列型</h3>
      <p>
        文字列型は、文字列を表現する型です。stringによって表現します。C言語の「const char*」を表現するために設計されました。
      </p>
<pre>
my $str : string;
</pre>
      <p>
        文字列リテラルによって、生成された文字列オブジェクトを代入できます。
      </p>
<pre>
my $str : string = "abc";
</pre>
      <p>
        SPVMの文字列は、要素を変更できないバイト型の配列です。配列アクセスを行って、文字を取得することができます。
      </p>
<pre>
# 文字の取得
my $ch = $str->[1];
</pre>
      <p>
        要素を変更しようとした場合は、コンパイル時エラーが発生します。
      </p>
<pre>
# 要素の変更はコンパイルエラー
$str->[1] = 'd';
</pre>
      <p>
        文字列型は、コンパイルが終わった後は、バイト型の配列とまったく同じものになります。たとえば、一つ目の表現は、二つ目の表現として扱われます。
      </p>
<pre>
# isa 文字列型
if ($str isa string) {
  
}

# isa バイト型の配列
if ($str isa byte[]) {
  
}
</pre>
      <p>
        SPVMの文字列は、変更不可ですが、これは、コンパイル時チェックであることに注意してください。
      </p>
      <p>
        文字列型は、byte[]型に、キャストすることができ、実行時に文字列を変更することができます。
      </p>
<pre>
my $bytes = (byte[])$str;
$bytes->[1] = 'd';
</pre>
      <p>
        文字列は、常に変更が可能であるものとして、扱ってください。
      </p>

      <h3 id="language-type-string-compatible">文字列互換型</h3>
      <p>
        文字列互換型とは、<a href="#language-type-string">文字列型</a>と<a href="#language-type-array-byte">byte[]型</a>のことを言います。
      </p>
      <p>
        文字列互換型の値が生成される場合には、値のために確保されたメモリ領域の最後のひとつ後ろは「\0」になることが保証されます。(たとえば「abc」であれば「c」の後ろは「\0」)SPVM言語から見た場合、この「\0」は意味を持ちませんが、ネイティブAPIを使う場合は、文字列互換型を、C言語の文字列として扱うことができます。
      </p>
      
      <h3 id="language-type-multi-numeric">複数数値型</h3>
      <p>
        複数数値型とは、連続した数値を表現できる型です。
      </p>
      <p>
        パッケージの定義において「mulnum_t」デスクリプタを指定することで、複数数値型を定義できます。
      </p>
<pre>
package Point_3i : mulnum_t {
  has x : int;
  has y : int;
  has z : int;
}
</pre>
      <p>
        複数数値型の詳しい解説については、<a href="#language-value">値</a>を見てください。
      </p>

      <h3 id="language-type-ref">リファレンス型</h3>
      <p>
        リファレンス型とは、変数のアドレスが格納できる型のことです。<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-multi-numeric">複数数値型</a>の後ろに「&」を付けることで定義できます。
      </p>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $point : Point_3i;;
my $point_ref : Point_3i& = \$point;
</pre>
      <p>
        リファレンス型の値に代入できるのは、<a href="#language-operator-ref">リファレンス演算子</a>で取得したレキシカル変数のアドレスだけです。
      </p>
      <p>
        リファレンス型のレキシカル変数の宣言だけが行われた場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        リファレンス型は、<a href="#language-lex-var-declaration">レキシカル変数の宣言</a>の型として利用できます。必ずリファレンス演算子によって、レキシカル変数のアドレスが格納される必要があります。レキシカル変数の宣言だけの場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        リファレンス型は、<a href="#language-sub-definition">サブルーチンの定義</a>における引数の型として利用できます。
      </p>
      <p>
        リファレンス型は、<a href="#language-sub-definition">サブルーチンの定義</a>における戻り値の型として利用できません。
      </p>
      <p>
        リファレンス型は、<a href="#language-package-definition">パッケージの定義</a>におけるフィールドの型として利用できません。
      </p>
      <p>
        リファレンス型は、<a href="#language-package-definition">パッケージの定義</a>におけるパッケージ変数の型として利用できません。
      </p>
      <p>
        不正な場所で、リファレンス型が使用された場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        リファレンスの詳しい解説については、<a href="#language-ref">リファレンス</a>を見てください。
      </p>

      <h2 id="language-type-inference">型推論</h2>
      <p>
        型推論によって、<a href="#language-lex-var-declaration">レキシカル変数の宣言</a>するときに、<a href="#language-type">型</a>の指定を省略することができます。型推論は、常に代入演算子の右辺の型によって、行われます。
      </p>
<pre>
# int
my $num = 1;

# double
my $num = 1.0;

# Foo
my $foo = new Foo;
</pre>
      <h2 id="language-type-compatible">型の互換性</h2>
      <p>
        型に互換性があるというのは、<a href="#language-expression-typecast">型キャスト</a>を行わないで、値が移動ができる型のことです。
      </p>
      <p>
        型に互換性があるのは次の場合です。
      </p>
      <p>
        <b>移動元と移動先の型が同一の場合</b>
      </p>
      <p>
        移動元と移動先の型が同一の場合は、型の互換性があります。
      </p>
<pre>
my $num1 : int;
my $num2 : int;
$num1 = $num2;
</pre>
      <p>
        <b>移動元の型がbyte[]型で、移動先の型が文字列型の場合</b>
      </p>
      <p>
        移動元の型がbyte[]型で、移動先の型が文字列型の場合は、型の互換性があります。
      </p>
<pre>
my $bytes = new byte[3];
my $str : string;
$str = $bytes;
</pre>
      <p>
        <b>移動元の型がオブジェクト型で、移動先の型が汎用オブジェクト型の場合</b>
      </p>
<pre>
my $foo : Foo = new Foo;
my $object : object;
$object = $foo;
</pre>
      <p>
        <b>移動元の型と移動先の型が、汎用オブジェクト型あるいは、汎用オブジェクト型の配列で、移動元の型の次元数が、移動先の型の次元数以上の場合</b>
      </p>
<pre>
my $objects_dim2_src : object[];
my $objects_dim1_dist : object;
$objects_dim1_dist = $objects_dim2_src;
</pre>
      <p>
        注意点として、汎用オブジェクトの配列と基本型の配列には互換性はありません。
      </p>
<pre>
# コンパイルエラー
my $objets : object[] = new int[3];
</pre>
      <p>
        型に互換性がない場合は、<a href="#language-type-convertion-implicite">暗黙的な型変換</a>が試みられます。暗黙の型変換に失敗した場合は、コンパイル時エラーが発生します。
      </p>
      
      <h2 id="language-type-convertion">型変換</h2>
      <ul class="list">
        <li><a href="#language-type-convertion-typecast">型キャスト</a></li>
        <li><a href="#language-type-convertion-typecast">数値型の型変換</a></li>
        <li><a href="#language-type-convertion-implicite">暗黙的な型変換</a></li>
        <li><a href="#language-type-convertion-numeric-type-order">数値型の順序</a></li>
        <li><a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a></li>
        <li><a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a></li>
        <li><a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a></li>
        <li><a href="#language-type-convertion-numeric-widening">数値拡大型変換</a></li>
        <li><a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a></li>
        <li><a href="#language-type-convertion-boxing">ボクシング変換</a></li>
        <li><a href="#language-type-convertion-unboxing">アンボクシング変換</a></li>
        <li><a href="#language-type-convertion-bool">ブール型変換</a></li>
      </ul>
      
      <h3 id="language-type-convertion-typecast">型キャスト</h3>
      <p>
        型キャストとは、明示的に記述して行う型変換のことを言います。
      </p>
<pre>
# 型キャスト
(型)式
</pre>
      <p>
        int型の値をlong型に変換するサンプルは以下のようになります。
      </p>
<pre>
my $num = (long)3;
</pre>
      <p>
        型キャストは、<a href="#language-expression">式</a>を返します。
      </p>
      <p>
        移動元の型と指定した型が同一の場合は、単に値のコピーになります。
      </p>
<pre>
my $num : int = (int)4;
</pre>
      <p>
        <b>型キャストにおける型変換の一覧</b>
      </p>
      <p>
        型キャストにおける型変換の一覧です。この表にない型キャストが行われた場合は、コンパイル時エラーが発生します。
      </p>
      <table>
        <tr>
          <th>
            <b>指定した型</b>
          </th>
          <th>
            <b>移動元の型</b>
          </th>
          <th>
            変換の内容
          </th>
        </tr>
        <tr>
          <td>
            <b>byte[]</b>
          </td>
          <td>
            <b>string</b>
          </td>
          <td>
            アドレス値がコピーされます。
          </td>
        </tr>
        <tr>
          <td>
            <b>string</b>
          </td>
          <td>
            <b>byte[]</b>
          </td>
          <td>
            アドレス値がコピーされます。
          </td>
        </tr>
        <tr>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <a href="#language-type-convertion-numeric-widening">数値型の型変換</a>が行われます。
          </td>
        </tr>
        <tr>
          <td>
            <b>数値オブジェクト型</b>
          </td>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。数値型と数値オブジェクト型が表現する数値型は、同じでなければなりません。たとえば、数値型がintの場合は、数値オブジェクト型はSPVM::Int型でなければなりません。
          </td>
        </tr>
        <tr>
          <td>
            <b>汎用オブジェクト型</b>
          </td>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。
          </td>
        </tr>
        <tr>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <b>数値オブジェクト型</b>
          </td>
          <td>
            <a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。数値型と数値オブジェクト型が表現する数値型は、同じでなければなりません。たとえば、数値型がintの場合は、数値オブジェクト型はSPVM::Int型でなければなりません。
          </td>
        </tr>
        <tr>
          <td>
            <b>数値型</b>
          </td>
          <td>
            <b>汎用オブジェクト型</b>
          </td>
          <td>
            <a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。
          </td>
        </tr>
        <tr>
          <td>
            <b>文字列型</b>
          </td>
          <td>
            <b>数値型</b>
          </td>
          <td>
            数値が、C標準のsprintf関数の「%g」フォーマットを使って、文字列化されます。
          </td>
        </tr>
      </table>

      <h3 id="language-type-convertion-numeric">数値型の型変換</h3>
      <p>
        数値型の型変換とは、<a href="#language-type-numeric">数値型</a>から<a href="#language-type-numeric">数値型</a>への変換のことです。
      </p>
      <p>
        数値型の型変換は、対応するC言語における数値型による型変換と全く同じ処理を行います。例えば、SPVMにおけるintからlongへの型変換は、C言語のint32_t型からint64_t型への型変換と同じ処理を行います。
      </p>
<pre>
# SPVMの変換
my $src : int = 5;
my $dist = (long)$src;

# C言語における対応
int32_t src = 5;
int64_t dist = (int64_t)src;
</pre>
      <p>
        型の対応については、<a href="#language-c99-type">C99との型の対応</a>を見てください。
      </p>
      <p>
        大きな型から小さな型に変換した場合や、浮動小数点から整数型に変換した場合は、正しい情報が保持されない場合があります。SPVMでは、C99に対応する型変換をそのまま行っているので、正しい情報が保持されない場合に、どの値に変換されるかは、C99の仕様と同じです。
      </p>
      
      <h3 id="language-type-convertion-implicite">暗黙的な型変換</h3>
      <p>
        暗黙的な型変換とは、SPVMによって行われる自動的な型変換のことです。次の箇所が、暗黙的な型変換が行われる可能性のある個所です。
      </p>
      <ul class="list">
        <li>異なる型に代入する場合</li>
        <li>異なる型のサブルーチンの引数に渡す場合</li>
        <li>戻り値とは異なる型を返却する場合</li>
      </ul>
      <p>
        次の場合に暗黙的な型変換が行われます。
      </p>
      <p>
        移動元と移動先の型がどちらも数値型で、移動元の型よりも移動先の型が大きい場合は、<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>が行われます。
      </p>
<pre>
# 暗黙の拡大型変換
my $num : long = 123;
my $num : double = 12.5f;
</pre>
      <p>
        移動元と移動先の型がどちらも数値型で、移動元の型よりも移動先の型が小さい場合で、移動元の値が、整数リテラルかつ移動先の型の値の範囲で表現できる場合は、<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>が行われます。
      </p>
<pre>
# 暗黙の縮小型変換
my $num : byte = 123;
my $num : short = 134;
</pre>
      <p>
        移動元の型が数値型で、移動先の型が汎用オブジェクト型の場合は、対応する数値オブジェクト型への<a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。以下の場合の例では、SPVM::Int型のオブジェクトに変換されたものが、汎用オブジェクトに代入されます。
      </p>
<pre>
# object型への暗黙のボクシング変換
my $num = 123;
my $object : object = $num;
</pre>
      <p>
        移動元の型が数値型で、移動先の型が対応する数値オブジェクト型の場合は、対応する数値オブジェクト型への<a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。
      </p>
<pre>
# object型への暗黙のボクシング変換
my $num = 123;
my $object : SPVM::Int = $num;
</pre>
      <p>
        移動元の型が汎用オブジェクト型で、移動先の型が数値型の場合は、対応する数値型における<a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。以下の場合の例では、SPVM::Int型のオブジェクトからint型への変換が試みられます。
      </p>
<pre>
# object型からの暗黙のアンボクシング変換 - 
my $object : object;
my $num : int = $object;
</pre>
      <p>
        移動元の型が数値オブジェクト型で、移動先の型が対応する数値型の場合は、対応する数値型における<a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。
      </p>
<pre>
# 数値オブジェクト型からの暗黙のアンボクシング変換
my $num_obj = SPVM::Int->new(3);
my $num : int = $num_obj;
</pre>
        移動元の型が数値型で、移動先の型が、文字列型の場合は、<a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a>が行われます。以下の場合の例では、数値の「123」が文字列「"123"」に変換されたものが代入されます。
      </p>
<pre>
# 文字列型への暗黙のボクシング変換
my $num = 123;
my $str : string = $num;
</pre>
      
      <h3 id="language-type-convertion-numeric-type-order">数値型の順序</h3>
      <p>
        <a href="#language-type-numeric">数値型</a>は、型の順序を持ちます。型の順序は小さい方から「byte」「short」「int」「long」「float」「double」です。
      </p>
      <h3 id="language-type-convertion-unary-numeric-widening">単項数値拡大型変換</h3>
      <p>
        単項数値拡大型変換とは、<a href="#language-expression">式</a>がbyte型あるいはshort型であった場合に、int型へ<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>を行うことをいいます。
      </p>
      <p>
        単項数値拡大型変換が行われるのは以下の場合です。
      </p>
      <ul class="list">
        <li>配列のインデックス</li>
        <li>配列を作成する場合の次元</li>
        <li>単項プラス演算子のオペランド</li>
        <li>単項マイナス演算子のオペランド</li>
        <li>シフト演算子「<<」「>>」「>>>」の左右のオペランド</li>
      </ul>
      <h3 id="language-type-convertion-binary-numeric-widening">二項数値拡大型変換</h3>
      <p>
        二項数値拡大型変換とは、左辺と右辺に数値型をとる二項演算子において、左式と右式に適用される<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>のことをいいます。
      </p>
      <p>
        次のルールが適用されます。
      </p>
      <p>
        1. 一方の式が、double型の場合は、他方の型はdouble型に変換されます。
      </p>
      <p>
        2. 一方の式が、float型の場合は、他方の型はfloat型に変換されます。
      </p>
      <p>
        3. 一方の式が、long型の場合は、他方の型はlong型に変換されます。
      </p>
      <p>
        4. それ以外の場合は、int型に変換されます。
      </p>
      <p>
        二項数値拡大型変換が行われるのは以下の場合です。
      </p>
      <ul class="list">
        <li><a href="#language-operator-add">加算演算子</a></li>
        <li><a href="#language-operator-subtract">減算演算子</a></li>
        <li><a href="#language-operator-multiply">乗算演算子</a></li>
        <li><a href="#language-operator-divide">除算演算子</a></li>
        <li><a href="#language-operator-remainder">剰余演算子</a></li>
        <li><a href="#language-operator-bit-and">ビットAND演算子</a></li>
        <li><a href="#language-operator-bit-or">ビットOR演算子</a></li>
        <li><a href="#language-operator-comparison-numeric">数値比較演算子</a></li>
      </ul>

      <h3 id="language-type-convertion-numeric-narrowing">数値縮小型変換</h3>
      <p>
        数値縮小型変換とは、<a href="#language-type-numeric">数値型</a>において大きい型から小さい型への変換が行われる場合に適用される変換の規則のことです。
      </p>
      
      <h3 id="language-type-convertion-numeric-widening">数値拡大型変換</h3>
      <p>
        数値拡大型変換とは、<a href="#language-type-numeric">数値型</a>において小さい型から大きい型への変換が行われる場合に適用される変換の規則のことです。
      </p>
      
      <h3 id="language-type-convertion-boxing">ボクシング変換</h3>
      <p>
        ボクシング変換とは、数値型の値を、数値オブジェクト型に変換する操作のことをいいます。
      </p>
      
      <h3 id="language-type-convertion-unboxing">アンボクシング変換</h3>
      <p>
        アンボクシング変換とは、数値オブジェクト型の値を、対応する数値型の値に変換する操作のことをいいます。
      </p>
      
      <h3 id="language-type-convertion-bool">ブール型変換</h3>
      <p>
        ブール型変換とは、if文の条件部などで適用される、真偽値判定のために、適用される変換のことです。
      </p>
      <p>
        <b>ブール型変換が行われる場所</b>
      </p>
      <p>
        <b>if文のかっこの中</b>
      </p>
<pre>
if (条件部) {

}
</pre>
      <p>
        <b>unless文のかっこの中</b>
      </p>
<pre>
unless (条件部) {

}
</pre>
      <p>
        <b>forのかっこの中の二つ目</b>
      </p>
<pre>
for (初期化;条件部;次の値;) {

}
</pre>
      <p>
        <b>whileのかっこの中</b>
      </p>
<pre>
while (条件部) {

}
</pre>
      <p>
        <b>論理AND演算子の左右</b>
      </p>
<pre>
条件部 && 条件部
</pre>
      <p>
        <b>論理OR演算子の左右</b>
      </p>
<pre>
条件部 || 条件部
</pre>
      <p>
        <b>論理否定演算子の右側</b>
      </p>
<pre>
!条件部
</pre>
      <p>
        ブール型変換で指定される式は、<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-object">オブジェクト型</a>あるいは<a href="#language-type-undef">未定義型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
      </p>
      <p>
        ブール型変換の戻り値は、int型の式です。
      </p>
      <p>
        式が<a href="#language-undef">未定義値</a>である場合は、0が返されます。
      </p>
      <p>
        式が、<a href="#language-type-numeric">数値型</a>の場合は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
      </p>
      <p>
        式がint型の場合は、その値が返されます。
      </p>
      <p>
        式がlong型、float型、double型、オブジェクト型である場合は、C99における以下の演算と完全に一致する演算を行い、結果が返されます。
      </p>
<pre>
!!x
</pre>
      <p>
        式がオブジェクト型の場合は、未定義値の場合は0、そうでない場合は1が返されます。
      </p>
      
      <h2 id="language-auto-loaded-module">自動的に読み込まれるモジュール</h2>
      <p>
        自動的に読み込まれるモジュールです。<a href="#language-module-use">モジュールの読み込み</a>を行わないで利用することができます。
      </p>
      <ul class="list">
        <li>SPVM::Byte</li>
        <li>SPVM::Short</li>
        <li>SPVM::Int</li>
        <li>SPVM::Long</li>
        <li>SPVM::Float</li>
        <li>SPVM::Double</li>
        <li>SPVM::Complex_2f</li>
        <li>SPVM::Complex_2d</li>
      </ul>
      
      <h2 id="language-other">参考情報</h2>
      <p>
        SPVMの公式ドキュメントについては、「<a href="/">SPVMドキュメント</a>」を見てください。
      </p>
      <p>
        PerlからSPVM言語の利用については「<a href="/exchange-api">SPVMエクスチェンジAPI仕様</a>」を見てください。
      </p>
      <p>
        SPVMからC/C++などのネイティブコードの利用については、「SPVMネイティブAPI」を見てください。
      </p>
      <p>
        SPVMの標準関数については、「SPVM標準関数」を見てください。
      </p>
      <p>
        SPVMの標準モジュールについては、「SPVM標準モジュール」を見てください。
      </p>
      
      <h2 id="language-limitation">制限</h2>
      <p>
        SPVMにおける制限です。
      </p>

      <h3 id="language-limitation-package-vars-count">パッケージ変数の個数の制限</h3>
      <p>
        ひとつのパッケージに定義できるパッケージ変数の個数の最大値は、65535個です。最大値を超えた場合は、コンパイル時エラーが発生します。
      </p>

      <h3 id="language-limitation-fields-count">フィールドの個数の制限</h3>
      <p>
        ひとつのパッケージに定義できるフィールドの個数の最大値は、65535個です。最大値を超えた場合は、コンパイル時エラーが発生します。
      </p>

      <h3 id="language-limitation-subs-count">サブルーチンの個数の制限</h3>
      <p>
        ひとつのパッケージに定義できるサブルーチンの個数の最大値は、65535個です。最大値を超えた場合は、コンパイル時エラーが発生します。
      </p>

      <h3 id="language-limitation-switches-count">switch文の個数の制限</h3>
      <p>
        ひとつのパッケージに定義できるswitch文の個数の最大値は、65535個です。最大値を超えた場合は、コンパイル時エラーが発生します。
      </p>

      <h3 id="language-limitation-lines-count">サブルーチンの行数の制限</h3>
      <p>
        ひとつのサブルーチンで定義できる行数の最大値は、65535個です。最大値を超えた場合は、コンパイル時エラーが発生します。
      </p>

      <h3 id="language-limitation-opcodes-count">オペレーションコードの個数の制限</h3>
      <p>
        SPVMのサブルーチンは、内部でオペレーションコードにコンパイルされます。オペレーションコードの個数の最大値は、65535個です。最大値を超えた場合は、コンパイル時エラーが発生します。
      </p>
      
      <h3 id="language-limitation-sub-arguments-count">サブルーチンの引数の個数の制限</h3>
      <p>
        SPVMのサブルーチンの引数の個数の最大は255個です。
      </p>
      <p>
        複数数値型の引数を渡すときは、フィールドの個数が、引数の個数としてカウントされます。たとえばSPVM::Complex_2d型が引数で指定された場合は、2個と数えます。
      </p>
      <p>
        複数数値のリファレンス型の引数を渡すときは、複数数値型のフィールドの個数が、引数の個数としてカウントされます。たとえばSPVM::Complex_2d&型が引数で指定された場合は、2個と数えます。
      </p>
      <p>
        もし、最大値を超えた場合は、コンパイル時エラーが発生します。
      </p>

      <h3 id="language-limitation-value-type-fileds-count">複数数値型のフィールドの個数の制限</h3>
      <p>
        複数数値型のフィールドの個数の最大値は、16個で、少なくともひとつのフィールドが必要です。そうでない場合は、コンパイル時エラーが発生します。
      </p>
    </div>

