<h2>SPVM 1.0 Language Specification</h3>

<b>SPVM 1.0 Language Specification</b> is described in this document.

SPVM is in beta testing for the 1.0 release. Language Specification will be changed without warning.

Last modified 2020-04-02

<ul>
  <li><a href="#language-c99">C99 compliant</a></li>
  <li><a href="#language-lex">Lexical Analysis</a></li>
  <li><a href="#language-parsing">Syntax Parsing</a></li>
  <li><a href="#language-comment">Comment</a></li>
  <li><a href="#language-pod">POD</a></li>
  <li><a href="#language-package">Package</a></li>
  <li><a href="#language-module">Module</a></li>
  <li><a href="#language-package-var">Package Variable</a></li>
  <li><a href="#language-field">Field</a></li>
  <li><a href="#language-sub">Subroutine</a></li>
  <li><a href="#language-enum">Enumeration</a></li>
  <li><a href="#language-begin-block">BEGIN Block</a></li>
  <li><a href="#language-lex-var">Lexical Variable</a></li>
  <li><a href="#language-scope">Scope</a></li>
  <li><a href="#language-literal">Literal</a></li>
  <li><a href="#language-string">String</a></li>
  <li><a href="#language-undef">Undefined Value</a></li>
  <li><a href="#language-array">Array</a></li>
  <li><a href="#language-mulnum">Multi Numeric Value</a></li>
  <li><a href="#language-mulnum-array">Multi Numeric Array</a></li>
  <li><a href="#language-ref">Reference</a></li>
  <li><a href="#language-expression">Expression</a></li>
  <li><a href="#language-operator">Operator</a></li>
  <li><a href="#language-expression-operator-precedence">Operator Precidence</a></li>
  <li><a href="#language-Statement">Statement</a></li>
  <li><a href="#language-type">Type</a></li>
  <li><a href="#language-type-inference">Type Inference</a></li>
  <li><a href="#language-type-compatible">Type Compatibility</a></li>
  <li><a href="#language-type-convertion">Type Convertion</a></li>
  <li><a href="#language-exception">Exception</a></li>
  <li><a href="#language-garbage-collection">Garbage Collection</a></li>
  <li><a href="#language-callback">Callback</a></li>
  <li><a href="#language-weak-ref">Weaken Reference</a></li>
</ul>

<h3 id="language-c99">C99 compliant</h3><!-- 2019/2/27 almost ok -->
<ul class="list">
  <li><a href="#language-c99-spec">C99 compliant compiler and runtime</a>
  <li><a href="#language-c99-type">Type correspondence with C99</a>
</ul>

<h4 id="language-c99-spec">C99 compliant compiler and runtime</h4><!-- 2019/2/27 almost ok -->

The source code of the SPVM compiler and SPVM runtime is written in C and conforms to C99.

Note that this does not mean that users cannot call the functions of C versions other than C99 (C11, GNU extensions, etc.) or call the functions of C++ from SPVM.

This means that the SPVM compiler and runtime must be C99 compliant.

<h4 id="language-c99-type">Type correspondence with C99</h4><!-- 2019/2/27 almost ok -->

SPVM types are exactly the same as the following C99 types:

<table>
  <tr>
    <th>
      <b> SPVM type </ b>
    </ th>
    <th>
      <b> C99 type </ b>
    </ th>
    <th>
      <b> Description </ b>
    </ th>
  </ tr>
  <tr>
    <td>
      <b> byte </ b>
    </ td>
    <td>
      int8_t
    </ td>
    <td>
      SPVM <a href="#language-type-byte"> byte type</a> matches C99 int8_t type.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> short </ b>
    </ td>
    <td>
      int16_t
    </ td>
    <td>
      SPVM <a href="#language-type-short"> short type</a> matches the C99 int16_t type.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> int </ b>
    </ td>
    <td>
      int32_t
    </ td>
    <td>
      SPVM <a href="#language-type-int">int Type</a> matches the C99 int32_t type.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> long </ b>
    </ td>
    <td>
      int64_t
    </ td>
    <td>
      SPVM <a href="#language-type-long"> long type</a> matches C99 int64_t type.
    </ td>
  </ tr>

<tr>
    <td>
      <b> float </ b>
    </ td>
    <td>
      float
    </ td>
    <td>
      SPVM <a href="#language-type-float"> float type</a> matches the C99 float type.
    </ td>
  <tr>
    <td>
      <b> double </ b>
    </ td>
    <td>
      double
    </ td>
    <td>
      SPVM <a href="#language-type-double"> double type</a> matches C99 double.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> Object type </ b>
    </ td>
    <td>
      void*
    </ td>
    <td>
      SPVM <a href="#language-type-object"> Object Type</a> matches the C99 void* type.
    </ td>
  </ tr>        
  <tr>
    <td>
      <b> Multiple Numeric Type </ b>
    </ td>
    <td>
      Numeric Array Type that matches the type and length in SPVM multiple Numeric Type fields
    </ td>
    <td>
      <p>
        For example, if SPVM <a href="#language-type-multi-numeric">multiple Numeric Type</a>
      </ p>
      <p>
        <b>package Point_2i: mulnum_t {has x: int; has y: int;}</b>
      </ p>
      <p>
        matches the type declared in C99
      </ p>
      <p>
        <b>int32_t var[2];</b>
      </p>
    </ td>
  </ tr>
</table>

<h3 id="language-lex">Lexical Analysis</h3>

This topic specifies the Lexical Analysis of the SPVM language.

<ul class="list">
  <li><a href="#language-lex-lalr">LALR(1)</a>
  <li><a href="#language-lex-charset">Character Set</a>
  <li><a href="#language-lex-component">Component</a>
  <li><a href="#language-lex-line-terminator">Line Terminater</a>
  <li><a href="#language-lex-space-character">Space Character</a>
  <li><a href="#language-lex-identifier">Identifiers</a>
  <li><a href="#language-lex-separator">Separator</a></li>
  <li><a href="#language-lex-separator-fat-comma">Fat Comma</a></li>
  <li><a href="#language-lex-operator">Operator</a>
  <li><a href="#language-lex-syntax-definition">Syntax Definition</a></li>
</ul>

<h4 id="language-lex-lalr">LALR(1)</h4><!-- 2019/2/27 almost ok -->

SPVM language can be analyzed by the LALR(1). It can be parsed by the parser generator generated by yacc/bison.

<h4 id="language-lex-lalr">Character Set</h4>

SPVM programs are written in UTF-8.

<h4 id="language-lex-component">Component</h4><!-- 2019/2/27 almost ok -->

Component in SPVM is <a href="#language-lex-space-character">Space Character</a>,<a href="#language-comment">Comment</a>, <a href="#language-pod">POD</a>, <a href="#language-literal">Literal</a>, <a href="#language-lex-identifier">Identifier</a>, <a href="#language-lex-keyword">Keyword</a>, <a href="#language-lex-separator">Separator</a>, or <a href="#language-lex-operator">Operator</a>.

<h4 id="language-lex-line-terminator">Line Terminator</h4><!-- 2019/7/1 check -->

Line Terminator in SPVM are ASCII Code "LF", "CR", "CRLF".

When a line terminator appears, the line number is incremented.Line Terminator in a program is converted to ASCII Code "LF".

<h4 id="language-lex-space-character">Space Character</h4><!-- 2019/2/27 almost ok -->

Space Character in SPVM is ASCII Code "SP", "HT", "FF" or <a href="#language-lex-line-terminator">Line Terminator</a>.

Space Character has no meaning in the program execution.

<h4 id="language-lex-identifier">Identifiers</h4><!-- 2019/2/27 maybe ok -->

Identifiers in SPVM are <a href="#language-lex-identifier-package-name">Package Name</a>, <a href="#language-lex-identifier-sub-name">Subroutine Name</a>, <a href="#language-lex-identifier-field-name">Field Name</a>, <a href="#language-lex-identifier-package-var-name">Package Variable Name</a>, and <a href="#language-lex-identifier-lex-var-name">Lexical Variable Name</a>.

<h4 id="language-lex-identifier-package-name">Package Name</h4><!-- 2019/2/27 almost ok -->

Package Name is one or more alphabet(a-zA-Z), number(0-9), underscore(_) or "::" of ASCII Code.

It is not necessary to include "::" in the Package Name.

Package Name must start a uppercase letter in ASCII Code

"::" cannot be continued twice. Last characters cannot end with "::".

Underscore cannot be continued twice.

<pre>
# Valid Package Name
Foo
Foo::Bar
Foo::Bar::Baz3
Foo::bar
Foo_Bar::Baz_Baz

# Invalid Package Name
foo
_Foo
Foo::Bar::
Foo__Bar
</pre>

If Package Name is invalid, a compile-time error occurs.

<h4 id="language-lex-identifier-sub-name">Subroutine Name</h4><!-- 2019/2/27 almost ok -->

Subroutine Name is one or more alphabet(a-zA-Z), number(0-9), or underscore(_) of ASCII Code.

First character must not number character.

Underscore cannot be continued twice.

<pre>
# Valid Subroutine Name
FOO
FOO_BAR3
foo
foo_bar
_foo
_foo_bar_

# Invalid Subroutine Name
foo__bar
</pre>

<h4 id="language-lex-identifier-field-name">Field Name</h4><!-- 2019/2/27 almost ok -->

Field Name is one or more alphabet(a-zA-Z), number(0-9), or underscore(_) of ASCII Code.

First character must not number character.
  
Underscore cannot be continued twice.

<pre>
# Valid Field Name
FOO
FOO_BAR3
foo
foo_bar
_foo
_foo_bar_

# Invalid Field Name
3foo
foo__bar
</pre>

<h4 id="language-lex-identifier-package-var-name">Package Variable Name</h4><!-- 2019/2/27 maybe ok -->

Package Variable Name starts with "$", followed more alphabet(a-zA-Z), number(0-9), underscore(_) or "::" of ASCII Code.

Followed character must not start with number.

"::" cannot be continued twice. Last characters cannot end with "::".

Underscore cannot be continued twice.

<pre>
# Valid Package Variable Name
$FOO::BAR
$Foo::Bar3
$FOO
$FOO_BAR
$foo

# Invalid Package Variable Name
$FOO__BAR
$3FOO
</pre>

<h4 id="language-lex-identifier-lex-var-name">Lexical Variable Name</h4><!-- 2019/2/27 maybe ok -->

Lexical Variable Name starts with "$", followed more alphabet characters of ASCII Code.

Followed character must not start with number.

Underscore cannot be continued twice.

<pre>
# Valid Lexical Variable Name
$foo
$foo_bar3
$_foo
$FOO

# Invalid Lexical Variable Name
$foo__bar
$3foo
</pre>

<h4 id="language-lex-keyword">Keywords</h4><!-- 2019/2/27 maybe ok -->

Keywords in SPVM are the followings.

<pre>
allow byte BEGIN case die warn print default double elsif else enum eq
eval for float gt ge has if callback_t isa int last break length
lt le long my native ne next new our object package private
public precompile pointer_t return require rw ro self switch
sub string short scalar undef unless use void mulnum_t while
weaken wo __END__ __PACKAGE__ __FILE__ __LINE__
</pre>

<h4 id="language-lex-separator">Separators</h4><!-- 2019/2/27 almost ok -->

Separators in SPVM are the followings.

<pre>
( ) { } [ ] ; , -> =>
</pre>

<h4 id="language-lex-separator-fat-comma">Fat Comma</h4>

Fat Comma is a <a href="#language-lex-separator">Separator</a> represented by "<b>=></b>".

<pre>
=>
</pre>

Fat Comma is an alias for Comma "<b>,</b>". Wherever you can use "<b>,</b>" you can use Fat Comma instead.

<pre>
# Comma
["a", "b", "c", "d"]

# Use Fat Comma instead of Comma
["a" => "b", "c" => "d"]
</pre>


Identifiers other than <a href="#language-lex-identifier-package-var-name">Package Variable Name</a> and <a href="#language-lex-identifier-lex-var-name">Lexical Variable Name</a> placed on the left of Fat Comma are treated as <a href="#language-literal-string">String Literal</a>.

<pre>
# Identifiers placed on the left of Fat Comma are treated as String Literal
# a is "a", c is "c"
[a => "b", c => "d"]
</pre>

<h4 id="language-lex-operator">Operators</h4><!-- 2019/2/27 almost ok -->

Operators in SPVM are the followings.

<pre>
=   >   <   !   ~
==  <=  >=  !=  &&  ||  ++  --
+   -   *   /   &   |   ^   %   <<   >>   >>>
+=  -=  *=  /=  &=  |=  ^=  %=  <<=  >>=  >>>=
\   $   @   .   .=
</pre>

<h3 id="language-parsing">Syntax Parsing</h3>

<h4 id="language-parsing-syntax-definition">Syntax Parsing Definition</h4><!-- 2019/2/27 not ok -->

The following is Syntax Parsing Definition in SPVM, using the syntax in yacc/bison. 

<pre>
%token <opval> PACKAGE HAS SUB OUR ENUM MY SELF USE REQUIRE ALLOW
%token <opval> DESCRIPTOR
%token <opval> IF UNLESS ELSIF ELSE FOR WHILE LAST NEXT SWITCH CASE DEFAULT BREAK EVAL
%token <opval> NAME VAR_NAME CONSTANT EXCEPTION_VAR
%token <opval> UNDEF VOID BYTE SHORT INT LONG FLOAT DOUBLE STRING OBJECT
%token <opval> DOT3 FATCAMMA RW RO WO BEGIN NEW
%token <opval> RETURN WEAKEN DIE WARN CURRENT_PACKAGE UNWEAKEN '[' '{' '('

%type <opval> grammar
%type <opval> opt_packages packages package package_block refcnt
%type <opval> opt_declarations declarations declaration
%type <opval> enumeration enumeration_block opt_enumeration_values enumeration_values enumeration_value
%type <opval> sub cb_obj opt_args args arg invocant has use require our string_length
%type <opval> opt_descriptors descriptors sub_names opt_sub_names
%type <opval> opt_Statements Statements Statement if_Statement else_Statement 
%type <opval> for_Statement while_Statement switch_Statement case_Statement default_Statement
%type <opval> block eval_block begin_block switch_block if_require_Statement
%type <opval> unary_op binary_op num_comparison_op str_comparison_op isa logical_op
%type <opval> call_sub opt_vaarg
%type <opval> array_access field_access weaken_field unweaken_field isweak_field convert array_length
%type <opval> deref ref assign inc dec allow
%type <opval> new array_init
%type <opval> my_var var
%type <opval> expression opt_expressions expressions opt_expression case_Statements
%type <opval> field_name sub_name
%type <opval> type basic_type array_type array_type_with_length ref_type  type_or_void

%right <opval> ASSIGN SPECIAL_ASSIGN
%left <opval> LOGICAL_OR
%left <opval> LOGICAL_AND
%left <opval> BIT_OR BIT_XOR
%left <opval> '&'
%nonassoc <opval> NUMEQ NUMNE STREQ STRNE
%nonassoc <opval> NUMGT NUMGE NUMLT NUMLE STRGT STRGE STRLT STRLE ISA
%left <opval> SHIFT
%left <opval> '+' '-' '.'
%left <opval> MULTIPLY DIVIDE REMAINDER
%right <opval> LOGICAL_NOT BIT_NOT '@' REF DEREF PLUS MINUS CONVERT SCALAR LENGTH ISWEAK REFCNT
%nonassoc <opval> INC DEC
%left <opval> ARROW

%%

grammar
: opt_packages

opt_packages
:	/* Empty */
|	packages

packages
: packages package
| package

package
: PACKAGE basic_type package_block
| PACKAGE basic_type ':' opt_descriptors package_block
| PACKAGE basic_type ';'
| PACKAGE basic_type ':' opt_descriptors ';'

package_block
: '{' opt_declarations '}'

opt_declarations
:	/* Empty */
|	declarations

declarations
: declarations declaration
| declaration

declaration
: has
| sub
| enumeration
| our ';'
| use
| allow
| begin_block

begin_block
: BEGIN block

use
: USE basic_type ';'
| USE basic_type '(' opt_sub_names ')' ';'

require
: REQUIRE basic_type

allow
: ALLOW basic_type ';'

enumeration
: opt_descriptors ENUM enumeration_block

enumeration_block 
: '{' opt_enumeration_values '}'

opt_enumeration_values
:	/* Empty */
|	enumeration_values

enumeration_values
: enumeration_values ',' enumeration_value 
| enumeration_values ','
| enumeration_value

enumeration_value
: sub_name
| sub_name ASSIGN CONSTANT

our
: OUR PACKAGE_VAR_NAME ':' opt_descriptors type

has
: HAS field_name ':' opt_descriptors type ';'

sub
: opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' block
| opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' ';'

cb_obj
: opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block
| '[' args ']' opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block

opt_args
:	/* Empty */
|	args
| invocant
| invocant ',' args

args
: args ',' arg
| args ','
| arg

arg
: var ':' type

opt_vaarg
: /* Empty */
| DOT3

invocant
: var ':' SELF

opt_descriptors
:	/* Empty */
|	descriptors

descriptors
: descriptors DESCRIPTOR
| DESCRIPTOR

opt_Statements
:	/* Empty */
|	Statements

Statements
: Statements Statement 
| Statement

Statement
: if_Statement
| for_Statement
| while_Statement
| block
| switch_Statement
| case_Statement
| default_Statement
| eval_block
| if_require_Statement
| expression ';'
| LAST ';'
| NEXT ';'
| RETURN ';'
| RETURN expression ';'
| DIE ';'
| DIE expression ';'
| WARN ';'
| WARN expression ';'
| PRINT expression ';'
| weaken_field ';'
| unweaken_field ';'
| ';'

for_Statement
: FOR '(' opt_expression ';' expression ';' opt_expression ')' block

while_Statement
: WHILE '(' expression ')' block

switch_Statement
: SWITCH '(' expression ')' switch_block

switch_block
: '{' case_Statements '}'
| '{' case_Statements default_Statement '}'

case_Statements
: case_Statements case_Statement
| case_Statement

case_Statement
: CASE expression ':' block
| CASE expression ':'

default_Statement
: DEFAULT ':' block
| DEFAULT ':'

if_require_Statement
: IF '(' require ')' block
| IF '(' require ')' block ELSE block

if_Statement
: IF '(' expression ')' block else_Statement
| UNLESS '(' expression ')' block else_Statement

else_Statement
: /* NULL */
| ELSE block
| ELSIF '(' expression ')' block else_Statement

block 
: '{' opt_Statements '}'

eval_block
: EVAL block ';'

opt_expressions
:	/* Empty */
|	expressions

opt_expression
: /* Empty */
| expression

expression
: var
| EXCEPTION_VAR
| package_var_access
| CONSTANT
| UNDEF
| call_sub
| field_access
| array_access
| convert
| new
| array_init
| array_length
| string_length
| refcnt
| my_var
| binary_op
| unary_op
| ref
| deref
| assign
| inc
| dec
| '(' expressions ')'
| CURRENT_PACKAGE
| isweak_field
| num_comparison_op
| str_comparison_op
| isa
| logical_op

refcnt
: REFCNT var
expressions
: expressions ',' expression
| expressions ','
| expression

unary_op
: '+' expression %prec PLUS
| '-' expression %prec MINUS
| BIT_NOT expression

inc
: INC expression
| expression INC

dec
: DEC expression
| expression DEC

binary_op
: expression '+' expression
| expression '-' expression
| expression MULTIPLY expression
| expression DIVIDE expression
| expression REMAINDER expression
| expression BIT_XOR expression
| expression '&' expression
| expression BIT_OR expression
| expression SHIFT expression
| expression '.' expression

num_comparison_op
: expression NUMEQ expression
| expression NUMNE expression
| expression NUMGT expression
| expression NUMGE expression
| expression NUMLT expression
| expression NUMLE expression

str_comparison_op
: expression STREQ expression
| expression STRNE expression
| expression STRGT expression
| expression STRGE expression
| expression STRLT expression
| expression STRLE expression

isa
: expression ISA type

logical_op
: expression LOGICAL_OR expression
| expression LOGICAL_AND expression
| LOGICAL_NOT expression

assign
: expression ASSIGN expression
| expression SPECIAL_ASSIGN expression

new
: NEW basic_type
| NEW array_type_with_length
| cb_obj

array_init
: '[' opt_expressions ']'

convert
: '(' type ')' expression %prec CONVERT

array_access
: expression ARROW '[' expression ']'
| array_access '[' expression ']'
| field_access '[' expression ']'

call_sub
: NAME '(' opt_expressions  ')'
| basic_type ARROW sub_name '(' opt_expressions  ')'
| basic_type ARROW sub_name
| expression ARROW sub_name '(' opt_expressions ')'
| expression ARROW sub_name
| expression ARROW '(' opt_expressions ')'

field_access
: expression ARROW '{' field_name '}'
| field_access '{' field_name '}'
| array_access '{' field_name '}'

weaken_field
: WEAKEN var ARROW '{' field_name '}'

unweaken_field
: UNWEAKEN var ARROW '{' field_name '}'

isweak_field
: ISWEAK var ARROW '{' field_name '}'

array_length
: '@' expression
| '@' '{' expression '}'
| SCALAR '@' expression
| SCALAR '@' '{' expression '}'

string_length
: LENGTH expression

deref
: DEREF var

ref
: REF var

my_var
: MY var ':' type
| MY var

var
: VAR_NAME

package_var_access
: PACKAGE_VAR_NAME

type
: basic_type
| array_type
| ref_type

basic_type
: NAME
| BYTE
| SHORT
| INT
| LONG
| FLOAT
| DOUBLE
| OBJECT
| STRING

ref_type
: basic_type '&'
array_type
: basic_type '[' ']'
| array_type '[' ']'

array_type_with_length
: basic_type '[' expression ']'
| array_type '[' expression ']'

type_or_void
: type
| VOID

field_name
: NAME

sub_name
: NAME

opt_sub_names
:	/* Empty */
|	sub_names

sub_names
: sub_names ',' sub_name
| sub_names ','
| sub_name
%%
</pre>

The following is a correspondence table between tokens in yacc/bison and keywords and operators in SPVM.

<table>
  <tr>
    <th>Tokens in yacc/bison</th><th>Keywords and Operators in SPVM</th>
  </tr>
  <tr>
    <td>PACKAGE</td><td>package</td>
  </tr>
  <tr>
    <td>SUB</td><td>sub</td>
  </tr>
  <tr>
    <td>OUR</td><td>our</td>
  </tr>
  <tr>
    <td>ENUM</td><td>enum</td>
  </tr>
  <tr>
    <td>MY</td><td>my</td>
  </tr>
  <tr>
    <td>SELF</td><td>self</td>
  </tr>
  <tr>
    <td>USE</td><td>use</td>
  </tr>
  <tr>
    <td>REQUIRE</td><td>require</td>
  </tr>
  <tr>
    <td>ALLOW</td><td>allow</td>
  </tr>
  <tr>
    <td>DESCRIPTOR</td><td>descriptor</td>
  </tr>
  <tr>
    <td>IF</td><td>if</td>
  </tr>
  <tr>
    <td>UNLESS</td><td>unless</td>
  </tr>
  <tr>
    <td>ELSIF</td><td>elsif</td>
  </tr>
  <tr>
    <td>ELSE</td><td>else</td>
  </tr>
  <tr>
    <td>FOR</td><td>for</td>
  </tr>
  <tr>
    <td>WHILE</td><td>while</td>
  </tr>
  <tr>
    <td>LAST</td><td>last</td>
  </tr>
  <tr>
    <td>BREAK</td><td>break</td>
  </tr>
  <tr>
    <td>NEXT</td><td>next</td>
  </tr>
  <tr>
    <td>SWITCH</td><td>switch</td>
  </tr>
  <tr>
    <td>CASE</td><td>case</td>
  </tr>
  <tr>
    <td>DEFAULT</td><td>default</td>
  </tr>
  <tr>
    <td>EVAL</td><td>eval</td>
  </tr>
  <tr>
    <td>NAME</td><td>name</td>
  </tr>
  <tr>
    <td>VAR</td><td>var</td>
  </tr>
  <tr>
    <td>CONSTANT</td><td>Literal</td>
  </tr>
  <tr>
    <td>PACKAGE_VAR_NAME</td><td>Package Variable Name</td>
  </tr>
  <tr>
    <td>EXCEPTION_VAR</td><td>$@</td>
  </tr>
  <tr>
    <td>UNDEF</td><td>undef</td>
  </tr>
  <tr>
    <td>VOID</td><td>void</td>
  </tr>
  <tr>
    <td>BYTE</td><td>byte</td>
  </tr>
  <tr>
    <td>SHORT</td><td>short</td>
  </tr>
  <tr>
    <td>INT</td><td>int</td>
  </tr>
  <tr>
    <td>LONG</td><td>long</td>
  </tr>
  <tr>
    <td>FLOAT</td><td>float</td>
  </tr>
  <tr>
    <td>DOUBLE</td><td>double</td>
  </tr>
  <tr>
    <td>STRING</td><td>string</td>
  </tr>
  <tr>
    <td>OBJECT</td><td>object</td>
  </tr>
  <tr>
    <td>DOT3</td><td>...</td>
  </tr>
  <tr>
    <td>FATCAMMA</td><td>=></td>
  </tr>
  <tr>
    <td>RW</td><td>rw</td>
  </tr>
  <tr>
    <td>RO</td><td>ro</td>
  </tr>
  <tr>
    <td>WO</td><td>wo</td>
  </tr>
  <tr>
    <td>BEGIN</td><td>BEGIN</td>
  </tr>
  <tr>
    <td>NEW</td><td>new</td>
  </tr>
  <tr>
    <td>RETURN</td><td>return</td>
  </tr>
  <tr>
    <td>WEAKEN</td><td>weaken</td>
  </tr>
  <tr>
    <td>DIE</td><td>die</td>
  </tr>
  <tr>
    <td>WARN</td><td>warn</td>
  </tr>
  <tr>
    <td>PRINT</td><td>print</td>
  </tr>
  <tr>
    <td>CURRENT_PACKAGE</td><td>__PACKAGE__</td>
  </tr>
  <tr>
    <td>UNWEAKEN</td><td>unweaken</td>
  </tr>
  <tr>
    <td>ASSIGN</td><td>=</td>
  </tr>
  <tr>
    <td>SPECIAL_ASSIGN</td><td>+=  -=  *=  /=  &=  |=  ^=  %=  &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;= .=</td>
  </tr>
  <tr>
    <td>LOGICAL_OR</td><td>||</td>
  </tr>
  <tr>
    <td>LOGICAL_AND</td><td>&&</td>
  </tr>
  <tr>
    <td>BIT_OR</td><td>|</td>
  </tr>
  <tr>
    <td>BIT_XOR</td><td>&</td>
  </tr>
  <tr>
    <td>NUMEQ</td><td>==</td>
  </tr>
  <tr>
    <td>NUMNE</td><td>!=</td>
  </tr>
  <tr>
    <td>STREQ</td><td>eq</td>
  </tr>
  <tr>
    <td>STRNE</td><td>ne</td>
  </tr>
  <tr>
    <td>NUMGT</td><td>&gt;</td>
  </tr>
  <tr>
    <td>NUMGE</td><td>&gt;=</td>
  </tr>
  <tr>
    <td>NUMLT</td><td>&lt;</td>
  </tr>
  <tr>
    <td>NUMLE</td><td>&lt;=</td>
  </tr>
  <tr>
    <td>STRGT</td><td>gt</td>
  </tr>
  <tr>
    <td>STRGE</td><td>ge</td>
  </tr>
  <tr>
    <td>STRLT</td><td>lt</td>
  </tr>
  <tr>
    <td>STRLE</td><td>le</td>
  </tr>
  <tr>
    <td>ISA</td><td>isa</td>
  </tr>
  <tr>
    <td>SHIFT</td><td>&lt;&lt;  &gt;&gt;  &gt;&gt;&gt;</td>
  </tr>
  <tr>
    <td>MULTIPLY</td><td>*</td>
  </tr>
  <tr>
    <td>DIVIDE</td><td>/</td>
  </tr>
  <tr>
    <td>REMAINDER</td><td>%</td>
  </tr>
  <tr>
    <td>LOGICAL_NOT</td><td>!</td>
  </tr>
  <tr>
    <td>BIT_NOT</td><td>~</td>
  </tr>
  <tr>
    <td>REF</td><td>\</td>
  </tr>
  <tr>
    <td>DEREF</td><td>$</td>
  </tr>
  <tr>
    <td>PLUS</td><td>+</td>
  </tr>
  <tr>
    <td>MINUS</td><td>-</td>
  </tr>
  <tr>
    <td>CONVERT</td><td>(TypeName)</td>
  </tr>
  <tr>
    <td>SCALAR</td><td>scalar</td>
  </tr>
  <tr>
    <td>LENGTH</td><td>length</td>
  </tr>
  <tr>
    <td>ISWEAK</td><td>isweak</td>
  </tr>
  <tr>
    <td>REFCNT</td><td>refcnt</td>
  </tr>
  <tr>
    <td>INC</td><td>++</td>
  </tr>
  <tr>
    <td>DEC</td><td>--</td>
  </tr>
  <tr>
    <td>ARROW</td><td>-></td>
  </tr>
</table>

<h3 id="language-comment">Comment</h3>

Comment begins with "#" and ends with <a href="#language-lex-line-terminator">Line Terminator</a>.

<pre>
# Comment
</pre>

Comment has no meaning in the program execution.

<h3 id="language-pod">POD</h3>

POD(Plain Old Document) is a syntax to write documents easily.

You can use POD as Multi-Line comments.

POD starts from the line beginning with "=", followed by any character string of one or more characters, and ending with <a href="#language-lex-line-terminator">Line Terminator</a>.

POD ends from the line beginning with "=cut", and ending with <a href="#language-lex-line-terminator">Line Terminator</a>.

<b>POD Example:</b>

<pre>
=pod

Multi-Line
Comment

=cut
</pre>

<pre>
=head1

Multi-Line
Comment

=cut
</pre>

POD has no meaning in the program execution.

<h3 id="language-package">Package</h3>
<ul class="list">
  <li><a href="#language-package-definition">Package Definition</a></li>
  <li><a href="#language-package-descriptor">Package Descriptor</a></li>
  <li><a href="#language-package-destructor">Destructor</a></li>
  <li><a href="#language-package-allow-package-access">Allow Package Access</a></li>
</ul>

<h4 id="language-package-definition"><a href="#language-package-definition">Package Definition</a></h4>

<b>Package Definition</b> is the following syntax.

<pre>
package PACAKGE_NAME {

}
</pre>

PACAKGE_NAME must follow the rule for <a href="#language-lex-identifier-package-name">Package Name</a>.

<a href="#language-package-descriptor">Package Descriptor</a> can be specified by the following syntax.

<pre>
package PACAKGE_NAME : PACAKGE_DESCRIPTOR {

}

package PACAKGE_NAME : PACAKGE_DESCRIPTOR1 PACAKGE_DESCRIPTOR2 PACAKGE_DESCRIPTORN {

}
</pre>

<b>Package Definition Example:</b>

<pre>
# Package Name
package Point {

}
</pre>

<pre>
# Package Name and Package Descriptor
package Point : public {

}
</pre>

In direct children of the package block, <a href="#language-module-use">use</a>, <a href="#language-package-var-definition">our</a>, <a href="#language-field-definition">has</a>, <a href="#language-enum-definition">enum</a>, <a href="#language-sub-definition">sub</a> can be defined.

<pre>
package Foo {
  # use
  use Point;

  # Package Variable Definition
  our $VAR int;

  # Field Defintion
  has var : int;

  # Enumeration Definition
  enum {
    CONST_VAL1,
    CONST_VAL2,
  }

  # Subroutine Definition
  sub foo : int ($num : int) {

  }
}
</pre>

If more than one package with the same name is defined, a compile-time error occurs.

<h4 id="language-package-descriptor">Package Descriptor</h4>

The descriptions of Package Descriptors.

<table>
  <tr>
    <th>
      Descriptor
    </th>
    <th>
      Meaning
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      This package is public. Other packages can <a href="#language-expression-new">new</a> this package.
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      This package is private. Other packages can't <a href="#language-expression-new">new</a> this package. This is default setting.
    </td>
  </tr>
  <tr>
    <td>
      <b>callback_t</b>
    </td>
    <td>
      This package is <a href="#language-type-callback">Callback Type</a>.
    </td>
  </tr>
  <tr>
    <td>
      <b>mulnum_t</b>
    </td>
    <td>
      This package is <a href="#language-type-multi-numeric">Multi Numeric Type</a>.
    </td>
  </tr>
  <tr>
    <td>
      <b>pointer_t</b>
    </td>
    <td>
      This package is <a href="#language-type-pointer">Pointer Type</a>.
    </td>
  </tr>
</table>

If both "public" and "private" are specifed, a compile-time error occurs.

If more than one of "callback_t", "mulnum_t", "pointer_t" are specified, a compile-time error occurs.

<h4 id="language-package-destructor">Destructor</h4>

If the package is <a href="#language-type-class">Class Type</a>, the package defined a destructor.

Destructor is a special <a href="#language-sub">Subroutine</a> called when the object of this class is freed.

Destructor name must be "DESTROY".

Destructor Retrun Value must be <a href="#language-type-void">void Type</a>, otherwise a compile-time error occurs.

Destructor arguments must be one and the type must be <a href="#language-type-self">self Type</a>, otherwise a compile-time error occurs.

<pre>
sub DESTROY : void ($self : self) {

}
</pre>

If a <a href="#language-exception-occur">Exception</a> occurs in Destructor, the program don't exit, print the message of the exception to STDERR.

<b>Destructor Example:</b>

<pre>
package Foo {
  sub new : Foo {
    return new Foo;
  }

  sub DESTROY : void ($self : self) {
    print "DESTROY";
  }
}
</pre>

<h4 id="language-package-allow-package-access">Allow Package Access</h4>

By default, private Subroutines, Fields, and Package Variables cannot be accessed from outside the Package.

Also, Private Package cannot <a href="#language-expression-new">Create Object</a> from outside of Package.

If the package allow other package, the other package can access private Subroutines, Fields, and Package Variables, and can <a href="#language-expression-new">Create Object</a> of the package.

<pre>
allow PACKAGE_NAME;
</pre>

allow must be defined directory under <a href="#language-package-definition">Package Definition</a>.

<pre>
package Foo {
  allow Bar;
}
</pre>

In this example, Bar can access the private Subroutine, Field, and Package Variable of Foo can be accessed and can Create Object of Foo.

Specifying the module of <b>allow</b> also loads the module by <a href="#language-module-use">use</a> at the same time.


<h3 id="language-module">Module</h3>
<ul class="list">
  <li><a href="#language-module-summary">Module Summary</a></li>
  <li><a href="#language-module-file-name">Module File Name</a></li>
  <li><a href="#language-module-use">Load Module</a></li>
  <li><a href="#language-module-auto-loaded-module">Automatically Loaded Module</a></li>
  <li><a href="#language-module-if-require">Selective Load Module</a></li>
</ul>

<h4 id="language-module-summary">Module Summary</h4>

Module is a single file that can be read as SPVM source code.

<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}
</pre>


Module can contain multiple Packages.

<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}

package Foo::Bar::Baz {

}
</pre>

<h4 id="language-module-file-name">Module File Name</h4>

Modules must be placed in the module loading path with the following File Name.

Change "::" to "/". Add ".spvm" at the end.

<pre>
Foo.spvm
Foo/Bar.spvm
Foo/Bar/Baz.spvm
</pre>

<h4 id="language-module-use">Load Module</h4>

Use <b>use</b> keyword to load a Module.

<pre>
use Foo;
use Foo::Bar;
</pre>


Modules are loaded at compile-time.


If the Module does not exist, a compile-time error will occur.


use Keyword must be defined directly under <a href="#language-package-definition">Package Definition</a>.

<pre>
package Foo {
  use Foo;
}
</pre>

<h4 id="language-module-auto-loaded-module">Automatically Loaded Module</h4>

The followings are Automatically Loaded Modules. They can be used without <a href="#language-module-use">use</a>.

<ul class="list">
  <li>SPVM::Byte</li>
  <li>SPVM::Short</li>
  <li>SPVM::Int</li>
  <li>SPVM::Long</li>
  <li>SPVM::Float</li>
  <li>SPVM::Double</li>
</ul>

<h4 id="language-module-if-require">Load Module Selective</h4>

In SPVM, there is an if require Statement that loads a Module only if it exists in the module path, and if it does not exist, the block does not exist.

It was designed to implement a part of features of "#ifdef" in C language.

<pre>
if (require Foo) {

}
</pre>

if require Statement can be followed by else Statement. 

<pre>
if (require Foo) {

}
else {

}
</pre>

Note that elsif Statement cannot be followed.


Let's look at an example. if Foo does not exist, no compile-time error occurs and it is assumed that there is no if block

Therefore, "$foo = new Foo;" does not result in a compile-time error because it is assumed that there is no if block.

In the other hand, the else block exists, so a warning is issued.

<pre>
my $foo : object;
if (require Foo) {
  $foo = new Foo;
}
else {
  warn "Warning: Can't load Foo";
}
</pre>

<h3 id="language-package-var">Package Variable</h3>
<ul class="list">
  <li><a href="#language-package-var-definition">Package Variable Definition</a></li>
  <li><a href="#language-package-var-descriptor">Package Variable Descriptor</a></li>
  <li><a href="#language-package-var-initial-value">Package Variable Initial Value</a></li>
  <li><a href="#language-package-var-access">Package Variable Access</a></li>
</ul>

<h4 id="language-package-var-definition">Package Variable Definition</h4>

<b>Package Variable</b> is a global variable that belongs to <a href="#language-package">Package</a> and exists from the start to the end of the program execution.

"our" Keyword defines a Package Variable.

<pre>
our PACKAGE_VARIABLE_NAME : TYPE;
</pre>

Package Variable must be defined directly under <a href="#language-package-definition">Package Definition</a>.

Package Variable Definition must specify <a href="#language-type">Type</a>. The Type must be <a href="#language-type-numeric">Numeric Type</a> or <a href="#language-type-object">Object Type</a>.

Package Variable Name must follows the rule specified in <a href="#language-lex-identifier-package-var-name">Package Variable Name</a>, and must not contain "::". Otherwise a compile-time error occurs.

If more than one Package Variable with the same name is defined, a compile-time error occurs.

Package Variable Descriptor can be specified together in Package Variable definition.

<pre>
our PACKAGE_VARIABLE_NAME : DESCRIPTOR TYPE;
our PACKAGE_VARIABLE_NAME : DESCRIPTOR1 DESCRIPTOR2 DESCRIPTORN TYPE;
</pre>

<h4 id="language-package-var-descriptor">Package Variable Descriptor</h4>

List of Package Variable Descriptors.

<table>
  <tr>
    <th>
      Descriptor
    </th>
    <th>
      Description
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      This Package Variable is public. This Package Variable can be accessed from other package.
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      This Package Variable is private. This Package Variable can't be accessed from other package. This is default setting of Package Variable.
    </td>
  </tr>
  <tr>
    <td>
      <b>ro</b>
    </td>
    <td>
      This Package Variable has Read Accessor. Read Accessor name is the same as Package Variable Name except removing "$". For example, If the Package Variable Name is "$FOO", Read Accessor name is "FOO".
    </td>
  </tr>
  <tr>
    <td>
      <b>wo</b>
    </td>
    <td>
      This Package Variable has Write Accessor. Write Accessor name is the same as Package Variable Name except removing "$" and adding "SET_" to top. For example, If the Package Variable Name is "$FOO", Read Accessor name is "SET_FOO".
    </td>
  </tr>
  <tr>
    <td>
      <b>rw</b>
    </td>
    <td>
      This Package Variable has Read accessor and Write Accessor.
    </td>
  </tr>
</table>

If both "public" and "private" Descriptors are specified, a compile-time error occurs.

If more than one of "ro", "wo", and "rw" are specified at the same time, a compile-time error occurs

Read Accessor of Package Variable has no arguments and the return type is same as the type of Package Variable.

Write Acessor of Package Variable has one argument and the type is same as the type of Package Variable. The type of return value is <a href="#language-type-void">void Type</a>.

Inline Expansion optimization is performed to Read Accessor and Write Accessor. You don't have to worry about the performance penalty of using Package Variable Accessors.

<b>Package Variable Definition Example:</b>

<pre>
package Foo {
  our $NUM1 : byte;
  our $NUM2 : short;
  our $NUM3 : int;
  our $NUM4 : long;
  our $NUM5 : float;
  our $NUM6 : double;

  our $NUM_PUBLIC : public int;
  our $NUM_RO : ro int;
  our $NUM_WO : wo int;
  our $NUM_RW : rw int;
}
</pre>

<h4 id="language-package-var-initial-value">Package Variable Initial Value</h4>

Package Variable is initialized with <a href="#language-type-initial-value">Type Initial Value</a> after compilation and before execution.

This initial value can be changed by using <a href="#language-begin-block">BEGIN Block</a>.

<pre>
package Foo {
  our $VAR : int;

  BEGIN {
    $VAR = 3;
  }
}
</pre>

<h4 id="language-package-var-access">Package Variable Access</h4>

Package Variable Access is an operation to access Package Variable to get or set a value.

See <a href="#language-expression-get-package-var">Get Package Variable Value</a> for how to get the value of Package Variable.

See <a href="#language-expression-set-package-var">Set Package Variable Value</a> for the setting of the value of Package Variable.

<h3 id="language-field">Field</h3>
<ul class="list">
  <li><a href="#language-field-definition">Field Definition</a></li>
  <li><a href="#language-field-descriptor">Field Descriptor</a></li>
  <li><a href="#language-field-access">Field Access</a></li>
</ul>
<h4 id="language-field-definition">Field Definition</h4>

Field is a data area in a <a href="#language-expression-new">object created using new keyword</a>

"has" Keyword defines a Field.

<pre>
has FIELD_NAME : TYPE;
</pre>

Field must be defined directly under <a href="#language-package-definition">Package Definition</a>.

Field Definition must be specify <a href="#language-type">Type</a>. The Type must be <a href="#language-type-numeric">Numeric Type</a> or <a href="#language-type-object">Object Type</a>.

Field Name must follows the rule specified in <a href="#language-lex-identifier-field-name">Field Name</a>.

Field Name is allowed as same as <a href="#language-lex-keyword">Keyword</a>.

Field Type must be <a href="#language-type-numeric">Numeric Type</a> or <a href="#language-type-object">Object Type</a>, otherwise a compile-time error occurs.

If more than one Field Name Variable with the same name is defined, a compile-time error occurs.

Field Descriptor can be specified together in Field Definition.

<pre>
has FIELD_NAME : DESCRIPTOR TYPE_NAME;
has FIELD_NAME : DESCRIPTOR1 DESCRIPTOR2 DESCRIPTORN TYPE_NAME;
</pre>

<h4 id="language-field-descriptor">Field Descriptor</h4>

List of Field Descriptors.

<table>
  <tr>
    <th>
      Descriptor
    </th>
    <th>
      Description
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      This field is public. This field can be accessed from other package.
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      This field is private. This field can't be accessed from other package. This is default setting.
    </td>
  </tr>
  <tr>
    <td>
      <b>ro</b>
    </td>
    <td>
      This Field has Read Accessor. Read Accessor name is the same as Field Name. For example, If the Field Name is "foo", Read Accessor name is "foo".
    </td>
  </tr>
  <tr>
    <td>
      <b>wo</b>
    </td>
    <td>
      This Field has Write Accessor. Write Accessor name is the same as Field Name adding "set_" to top. For example, If the Field Name is "foo", Read Accessor name is "set_foo".
    </td>
  </tr>
  <tr>
    <td>
      <b>rw</b>
    </td>
    <td>
      This Field has Read Accessor and Write Accessor.
    </td>
  </tr>
</table>

If both "public" and "private" Descriptors are specified, a compile-time error occurs.

If more than one of "ro", "wo", and "rw" are specified at the same time, a compile-time error occurs

Read Accessor of Field has one argument that is <a href="#language-type-self">self Type</a> and the Return Type is same as the type of Field.

Write Acessor of Package Variable has two arguments. First argument is <a href="#language-type-self">self Type</a> and second argument is same as the type of Field. The type of return value is <a href="#language-type-void">void Type</a>.

Inline Expansion optimization is performed to Read Accessor and Write Accessor. You don't have to worry about the performance penalty of using Field Accessors.

<b>Field Definition Example:</b>

<pre>
package Foo {
  has num1 : byte;
  has num2 : short;
  has num3 : int;
  has num4 : long;
  has num5 : float;
  has num6 : double;

  has num_public : public int;
  has num_ro : ro int;
  has num_wo : wo int;
  has num_rw : rw int;
}
</pre>

<h4 id="language-field-access">Field Access</h4>

Field Access is an operation to access Field to get or set a value.

<pre>
EXPRESSION->{FIELD_NAME}
</pre>

Field Access has three different meanings.

<b>1. Class Based Object Field Access</b>

Class Based Object Field Access is Field Access from object which is create by <a href="#language-expression-new">new</a> keyword.

<pre>
my $point = new Point;
$point->{x} = 1;
</pre>

See <a href="#language-expression-get-field-class-based-object">Get Class Based Object Field Value</a> to get field of Class Based Object.

See <a href="#language-expression-set-field-class-based-object">Set Class Based Object Field Value</a> to set field of Class Based Object.

<b>2. Multi Numeric Field Access</b>

Multi Numeric Field Access is Field Access from the value of <a href="#language-type-multi-numeric">Multi Numeric Type</a>. The value of <a href="#language-type-multi-numeric">Multi Numeric Type</a> is allocated Callstack of Subroutine.

<pre>
my $z : SPVM::Complex_2d;
$z->{x} = 1;
$z->{y} = 3;
</pre>

See <a href="#language-expression-get-field-multi-numeric">Get Multi Numeric Type Field Value</a> to get field of the value of <a href="#language-type-multi-numeric">Multi Numeric Type</a>.

See <a href="#language-expression-set-field-multi-numeric">Set Multi Numeric Type Field Value</a> to set field of the value of <a href="#language-type-multi-numeric">Multi Numeric Type</a>.

<b>3. Dereference Multi Numeric Field</b>

Dereference Multi Numeric Field is Field access from Reference of the value of <a href="#language-type-multi-numeric">Multi Numeric Type</a>.

<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{x} = 1;
$z_ref->{y} = 3;
</pre>

See <a href="#language-expression-get-field-multi-numeric-deref">Get Multi Numeric Type Field Value via Dereference</a> to get Multi Numeric Field via Dereference.

See <a href="#language-expression-set-field-multi-numeric-deref">Set Multi Numeric Type Field Value via Dereference</a> to set Multi Numeric Field via Dereference.

<h3 id="language-sub">Subroutine</h3>
<ul class="list">
  <li><a href="#language-sub-definition">Subroutine Definition</a></li>
  <li><a href="#language-sub-descriptor">Subroutine Descriptor</a></li>
  <li><a href="#language-sub-native">Native Subroutine</a></li>
  <li><a href="#language-sub-precompiled">Precompiled Subroutine</a></li>
  <li><a href="#language-sub-constant">Constant Subroutine</a></li>
  <li><a href="#language-sub-method">Method</a></li>
  <li><a href="#language-sub-signature">Signature</a></li>
  <li><a href="#language-sub-stack">Subroutine Callstack</a></li>
</ul>

<h4 id="language-sub-definition">Subroutine Definition</h4>

"sub" Keyword defines Subroutine.

<pre>
sub SUBROUTINE_NAME : RETURN_VALUE_TYPE_NAME () {

}
sub SUBROUTINE_NAME : RETURN_VALUE_TYPE_NAME (ARGUMENT_NAME1 : ARGUMENT_TYPE_NAME1, ARGUMENT_NAME2 : ARGUMENT_TYPE_NAME2, ARGUMENT_NAMEN : ARGUMENT_TYPE_NAMEN) {

}
</pre>

Subroutine must be defined directly under <a href="#language-package-definition">Package Definition</a>.

Subroutine name must be follow the rule of <a href="#language-lex-identifier-sub-name">Subroutine Name</a>.

Subroutine Name is allowed as same as <a href="#language-lex-keyword">Keyword</a>. 

Type of Return Value must be <a href="#language-type-void">void Type</a>, <a href="#language-type-numeric">Numeric Type</a>, or <a href="#language-type-object">Object Type</a>, otherwise a compile-time error occurs.

Argument name must be follow the rule of <a href="#language-lex-identifier-lex-var-name">Lexical Variable Name</a>.

Minimal Argument Count is 0. Max Argument Count is 255.

Type of Argument must be <a href="#language-type-numeric">Numeric Type</a>, <a href="#language-type-object">Object Type</a>, or <a href="#language-type-reference">Reference Type</a>, otherwise a compile-time error occurs.

The defined Subroutine can be called. See <a href="#language-expression-callsub">Subroutine Call</a> about calling Subroutine, .

<a href="#language-scope-block-Statement-sub">Subroutine Block</a> can have zero or more Statements.

Subroutine Definition can have <a href="#language-sub-descriptor">Subroutine Descriptor</a>.

<pre>
DESCRIPTOR1 DESCRIPTOR2 DESCRIPTORN sub SUBROUTINE_NAME : RETURN_VALUE_TYPE_NAME () {

}
DESCRIPTOR1 DESCRIPTOR2 DESCRIPTORN sub SUBROUTINE_NAME : RETURN_VALUE_TYPE_NAME (ARGUMENT_NAME1 : ARGUMENT_TYPE_NAME1, ARGUMENT_NAME2 : ARGUMENT_TYPE_NAME2, ARGUMENT_NAMEN : ARGUMENT_TYPE_NAMEN) {

}
</pre>


If "..." follows Type of Argument, the Argument becomes Variable Length Argument. Only the last Argument can be Variable Length Argument.

The Type must be <a href="#language-type-array">Array Type</a>.

<pre>
sub SUBROUTINE_NAME : RETURN_VALUE_TYPE_NAME (ARGUMENT_NAME1 : ARGUMENT_TYPE_NAME1, ARGUMENT_NAME2 : ARGUMENT_TYPE_NAME2...) {

}
</pre>

Variable Length Argument can recieve multi values.

<pre>
# Variable Length Argument Definition
sub sprintf : string ($format : string, $values : object[]...) {

}

# Call Variable Length Argument Subroutine with multi values.
sprintf("Value %d %f", 1, 2.0);
</pre>

Variable Length Argument can recieve Array.

<pre>
# Call Variable Length Argument Subroutine with Array.
sprintf("Value  %d %f", [(object)1, 2.0]);
</pre>

If you want to treat the value of Array as an individual element of the variable length argument, cast it to Type other than Array Type.

<pre>
sprintf("aaa %p", (object)[(object)1, 2.0]);
</pre>

<h4 id="language-sub-descriptor">Subroutine Descriptor</h4>

List of Subroutine Descriptor.

<table>
  <tr>
    <th>
      Descriptor
    </th>
    <th>
      Description
    </th>
  </tr>
  <tr>
    <td>
      <b>native</b>
    </td>
    <td>
      This Subroutine is <a href="#language-sub-native">Native Subroutine</a>. 
    </td>
  </tr>
  <tr>
    <td>
      <b>precompile</b>
    </td>
    <td>
      This Subroutine is <a href="#language-sub-precompiled">Precompiled Subroutine</a>. 
    </td>
  </tr>
</table>

If both "native" and "precompile" Descriptors are specified, a compile-time error occurs

<h4 id="language-sub-native">Native Subroutine</h4>

Native Subroutine is Subroutine that call function written in Native Language(C, C++, etc).

See <a href="/native-api.html">SPVM Native API</a> Native Subroutine.

<h4 id="language-sub-precompiled">Precompiled Subroutine</h4>

Precompiled Subroutine is a subroutine translated into C language and converted into machine code.

Precompiled Subroutine needs Build Directory described in <a href="/native-api.html">SPVM Native API</a>

<h4 id="language-sub-constant">Constant Subroutine</h4>

Constant Subroutine is a Subroutine that Return Type is <a href="#language-type-numeric">Numeric Type</a> and returns Constant Value.

<pre>
sub foo : int () { return 5; }
sub foo : long () { return 5L; }
sub foo : float () { return 5.0f; }
sub foo : double () { return 5.0; }
</pre>

Inline Expansion optimization is performed to Constant Subroutine.

Note that SPVM does not perform constant convolution optimization, so if a constant is calculated, it will not performe Inline Expansion.

<pre>
# This is not Constant Subroutine.  Inline Expansion is not performed
sub foo : int () { return 5 + 3; }
</pre>

<h4 id="language-sub-method">Method</h4>

Method is Subroutine that has <a href="#language-type-self">self Type</a> as its first argument.

<pre>
sub SUB_NAME : TYPE  ($self : self, ARGUMENT2 : TYPE2, ARGUMENT3 : TYPE3, ARGUMENTN : TYPEN) {

}
</pre>

<a href="#language-type-self">self Type</a> must be first argument.

Method can be called from the object created by <a href="#language-expression-new">new</a>. See <a href="#language-expression-callsub">Subroutine Call</a> for Method Call.

$self is called Invocant.

<h4 id="language-sub-signature">Signature</h4>

Signature is a string that follow the following rule sequence of Subroutine Retrun Value and arguments arranged according to the following rules. Arguments do not need to exist. There cannot be spaces between them.

1. RETURN_VALUE_TYPE

2. (

3. ARGUMENT_TYPE1,ARGUMENT_TYPE2,ARGUMENT_TYPE3

4. )

<b>Signature Example:</b>

<pre>
# Subroutine Definition
sub foo : int ($num1 : double, $num2 : long[])

# Signature
int(double,long[])

# Subroutine Definition
sub foo : void ()

# Signature
void()
</pre>

Signature is not used in SPVM programs. Signature is used when calling the SPVM Subroutine from <a href="/native-api.html">SPVM Native API</a>.

<h4 id="language-sub-stack">Subroutine Callstack</h4>

Subroutine Callstack is memory area allocated in each subroutine call.


<p>
  Subroutine Callstackには,the following 情報が保存されます。
</p>
<p>
  1. <a href="#language-lex-var">Lexical Variable</a>のためのメモリ領域
</p>
<p>
  2. Motal Lexical Variableの場所
</p>

<h3 id="language-enum">Enumeration</h3>

<ul class="list">
  <li>
    <a href="#language-enum-definition">Enumeration Definition</a>
  </li>
  <li>
    <a href="#language-enum-descriptor">Enumeration Descriptor</a>
  </li>
  <li>
    <a href="#language-enum-call">Enumeration Call</a>
  </li>
</ul>

<h4 id="language-enum-definition">Enumeration Definition</h4>

Enumeration Definition is a syntax to define multiple <a href="#language-sub-constant">Constant Subroutines</a> easily.

<pre>
# Enumeration Definition
enum {
  FLAG1,
  FLAG2,
  FLAG3
}
</pre>

Enumeration must be defined directly under <a href="#language-package-definition">Package Definition</a>.

<pre>
package Foo {
  enum {
    FLAG1,
    FLAG2,
    FLAG3
  }
}
</pre>

The first value starts with "0". The value is incremented by "1". In this example, "FLAG1" is "0", "FALG2" is "1", and "FLAG3" is "2".

"," can be added after the last element of Enumeration.

<pre>
enum {
  FLAG1,
  FLAG2,
  FLAG3,
}
</pre>

Enumeration is an alias for <a href="#language-sub-constant">Constant Subroutine</a> that Return Type is <a href="#language-type-int">int Type</a>. It is equivalent to the following Subroutine Definition:

<pre>
sub FLAG1 : int () { return 0; }
sub FLAG2 : int () { return 1; }
sub FLAG3 : int () { return 2; }
</pre>

The value of <a href="#language-type-int">int Type</a> can be set in the enum element.

<pre>
enum {
  FLAG1,
  FLAG2 = 4,
  FLAG3,
}
</pre>


In the above case, "FLAG1" is "0", "FALG2" is "4", and "FLAG3" is "5".

If Enum Definition is invalid, a compile-time error occurs.

<h4 id="language-enum-descriptor">Enumeration Descriptor</h4>

Descriptor can be specified for Enumeration.

<pre>
private enum {
  FLAG1,
  FLAG2 = 4,
  FLAG3,
}
</pre>

List of Enumeration Descriptor

<table>
  <tr>
    <th>
      Descriptor
    </th>
    <th>
      Description
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      This Enumeration is public. This Enumeration can be accessed from other Package. This is default setting.
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      This Enumeration is private. This Enumeration can not be accessed from other Package.
    </td>
  </tr>
</table>

If both "public" and "private" Descriptors are specified, a compile-time error occurs.

<h4 id="language-enum-call">Enumeration Call</h4>

Enumeration is an alias for <a href="#language-sub-constant">Constant Subroutine</a>, so it can be called in exactly the same way as Subroutine call.

<pre>
my $flag1 = Foo->FLAG1;
my $flag2 = Foo->FLAG2;
my $flag3 = Foo->FLAG3;
</pre>

<p>
  In special case, Enumeration Call can be used in <a href="#language-Statement-case">case Statement</a> of <a href="#language-Statement-switch">switch Statement</a>.
</p>

<pre>
switch ($num) {
  case Foo->FLAG1: {

    break;
  }
  case Foo->FLAG2: {

    break:
  }
  case Foo->FLAG3: {

    break:
  }
  default: {

  }
}
</pre>

<h3 id="language-begin-block"><a href="#language-begin-block">BEGIN Block</a></h3>

<b>BEGIN Block</b> is a block that is executed immediately after the compilation of program.

BEGIN Keyword defines BEGIN Block.

<pre>
BEGIN {

}
</pre>

BEGIN Block must be defined directly under <a href="#language-package-definition">Package Definition</a>.

<pre>
package Foo {
  BEGIN {

  }
}
</pre>

Zero or more <a href="#language-Statement">Statements</a> can be written in BEGIN Block.

<pre>
BEGIN {
  my $foo = 1 + 1;
  my $bar;
}
</pre>

<a href="#language-Statement-return">return Statement</a> cannot be written in BEGIN Block.

Internally, BEGIN Block is a <a href="#language-sub">Subroutine</a> that Return Type is <a href="#language-type-void">void Type</a> and has no arguments.

You can define multiple BEGIN Blocks.

The execution order of BEGIN Block is not guaranteed. If ohter BEGIN Block is defined in ohter Package, do not assume that BEGIN Block of the current package will be executed first.

A common use of BEGIN Block is to initialize <a href="#language-package-var">Package Variable</a>.

<pre>
package Foo {
  use Point;
  
  our $NUM : int;
  our $POINT : Point;
  BEGIN {
    $NUM = 3;
    $POINT = Point->new;
  }
}
</pre>

<h3 id="language-lex-var">Lexical Variable</h3>

<ul class="list">
  <li><a href="#language-lex-var-declaration">Lexical Variable Declaration</a></li>
  <li><a href="#language-lex-var-initial-value">Lexical Variable Initial Value</a></li>
  <li><a href="#language-lex-var-access">Lexical Variable Access</a></li>
</ul>

<h4 id="language-lex-var-declaration">Lexical Variable Declaration</h4>

<b>Lexical Variable</b> is a variable that is declared in <a href="#language-scope-scope-block">Scope Block</a>.  Lexical Variable has <a href="#language-scope">Scope</a>. This is same as Local Variable in C Language.

Lexical Variable is declared using <b>my</b> <a href="#language-lex-keyword">Keyword</a>.

<pre>
my LEXICAL_VARIABLE_NAME : TYPE;
</pre>

Lexical variable name must be follow the rule of <a href="#language-lex-identifier-lex-var-name">Lexical Variable Name</a>.

<a href="#language-type">Type</a> must be specified. Type must be <a href="#language-type-numeric">Numeric Type</a>, <a href="#language-type-object">Object Type</a>, <a href="#language-type-multi-numeric">Multi Numeric Type</a>, or <a href="#language-type-ref">Reference Type</a>.

<pre>
# Lexical Variable Declaration Examples
my $var : int;
my $var : Point;
my $var : SPVM::Complex_2d;
my $var : int&;
</pre>

Lexical Variable is initialized by <a href="#language-lex-var-initial-value">Lexical Variable Initial Value</a>.

<pre>
# Initialized by 0
my $num : int;

# Initialized by 0
my $num : double;

# Initialized by undef
my $point : Point;

# x is initialized by 0. y is initialized by 0.
my $z : SPVM::Complex_2d;
</pre>


Initialization can be done at the same time as Lexical Variable Declaration.

<pre>
# Initialized by 1
my $num : int = 1;

# Initialized by 2.5
my $num : double = 2.5;

# Initialized by Point object
my $point : Point = new Point;
</pre>

Using <a href="#language-type-inference">Type Inference</a>, you omit <a href="#language-type">Type</a> in Lexical Variable Declaration.

<pre>
# int
my $num = 1;

# double
my $num = 1.0;
</pre>

Lexical Variable Declaration returns the value of Lexical Variable. This is a <a href="#language-expression">Expression</a>.

<pre>
my $ppp = my $bar = 4;

if (my $bar = 1) {

}

while (my $bar = 1) {

}
</pre>

See <a href="#language-scope">Scope</a> about Lexical Variable Scope.

<h4 id="language-lex-var-initial-value">Lexical Variable Initial Value</h4>

Lexical Variable is initialized by <a href="#language-type-initial-value">Type Initial Value</a>.

<h4 id="language-lex-var-access">Lexical Variable Access</h4>

Lexical Variable Access is an operation to access Lexical Variable to get or set the value.

See <a href="#language-expression-get-lex-var">Get Lexical Variable Value</a> to get Lexical Variable value.

<a href="#language-expression-set-lex-var">Set Lexical Variable Value</a> to get Lexical Variable value.

If <a href="#language-package-var">Package Variable</a> with the same name as the Lexical Variable exists, Program uses the variable as Lexical Variable, not <a href="#language-package-var">Package Variable</a>.

<h3 id="language-scope">Scope</h3>
<ul class="list">
  <li><a href="#language-scope-summary">Scope Summary</a>
  <li><a href="#language-scope-block">Block</a></li>
  <li><a href="#language-scope-scope-block">Scope Block</a>
</ul>

<h4 id="language-scope-summary">Scope Summary</h4>

<b>Scope</b> is a range surrounded by <a href="#language-scope-scope-block">Scope Block</a>.

<pre>
# Scope Block 
{
  # Start of Scope
  
  # ...
  
  # End of Scope
}
</pre>

Lexical Variable Declaration registers the Lexical Variable that is <a href="#language-type-object">Object Type</a> with Motal Variable in run-time. 

If the object is not <a href="#language-undef">undef</a>, The Reference Count is added by 1.

<pre>
{
  # $num become Motal Variable in run-time
  my $num = new Foo;
}
</pre>

At the end of Scope, the object that is registered as Motal Variable, Reference Count is reduced by 1 except the object is not <a href="#language-undef">undef</a>.

If the Reference Count become 0, the object released.

<h4 id="language-scope-block">Block</h4>

The part enclosed by "{" and "}" is called <b>Block</b>.

<pre>
# Block 
{

}
</pre>

There are <a href="#language-scope-scope-block">Scope Block</a> that creates a scope and Non Scope Block that does not create a scope.

<h4 id="language-scope-scope-block">Scope Block </h4>

<b>Scope Block</b> is a block that creates a Scope. Zero or more <a href="#language-Statement">Statement</a> can be written in Scope Block.

<b>List of Scope Blocks</b>

<ul class="list">
  <li><a href="#language-scope-block-Statement-simple">Simple Block</a></li>
  <li><a href="#language-scope-block-Statement-sub">Subroutine Block</a></li>
  <li><a href="#language-scope-block-Statement-eval">eval Block</a></li>
  <li><a href="#language-scope-block-Statement-if">if Block</a></li>
  <li><a href="#language-scope-block-Statement-elsif">elsif Block</a></li>
  <li><a href="#language-scope-block-Statement-else">else Block</a></li>
  <li><a href="#language-scope-block-Statement-for">for Block</a></li>
  <li><a href="#language-scope-block-Statement-while">while Block</a></li>
  <li><a href="#language-scope-block-Statement-switch">switch Block</a></li>
</ul>

<h4 id="language-scope-block-Statement-simple">Simple Block</h4>

Simple Block is a scope block.

<pre>
# Simple Block
{

}
</pre>

<h4 id="language-scope-block-Statement-sub">Subroutine Block</h4>

Subroutine Block is a scope block.

<pre>
# Subroutine Block
sub foo : int () {

}
</pre>

<h4 id="language-scope-block-Statement-eval">eval Block</h4>

eval Block is a scope block.

<pre>
# eval Block
eval {

}
</pre>

<h4 id="language-scope-block-Statement-if">if Block</h4>

if Block is a scope block.

<pre>
# if Block
if (Expression) {

}
</pre>

<h4 id="language-scope-block-Statement-elsif">elsif Block</h4>

elsif Block is a scope block.

<pre>
#elsif Block
elsif (Expression) {

}
</pre>

<h4 id="language-scope-block-Statement-else">else Block</h4>

else Block is a scope block.

<pre>
# else Block
else {

}
</pre>

<h4 id="language-scope-block-Statement-for">for Block</h4>

for Block is a scope block.

<pre>
# for Block 
for (my $i = 0; $i < 3; $i++) {

}
</pre>

<h4 id="language-scope-block-Statement-while">while Block</h4>

while Block is a scope block.

<pre>
# while Block
while (Expression) {

}
</pre>

<h4 id="language-scope-block-Statement-switch">switch Block</h4>

switch Block is a scope block.

<pre>
switch (Expression) {

}
</pre>

<h3 id="language-literal">Literal</h3>

<ul class="list">
  <li><a href="#language-literal-summary">Literal Summary</a></li>
  <li><a href="#language-literal-integer">Integer Literal</a></li>
  <li><a href="#language-literal-floating-point">Floating Point Literal</a></li>
  <li><a href="#language-literal-character">Charater Literal</a></li>
  <li><a href="#language-literal-string">String Literal</a></li>
  <li><a href="#language-literal-string-variable-expansion">Variable Expansion</a></li>
</ul>

<h4 id="language-literal-summary">Literal Summary</h4>

<b>Literal</b> is a <a href="#language-expression">Expression</a> that represents Constant Value.

<h4 id="language-literal-integer">Integer Literal</h4>

<h5>Decimal Representation of Integer Literal</h5>

Decimal Representation of Integer Literal is represented by one or more consecutive characters from "0" to "9".

Can be prefixed with "+" or "-".

<a href="#language-type">Type</a> of Integer Literal is <a href="#language-type-int">int Type</a> by default.

If Integer Literal exceeds the range of numbers that can be represented by <a href="#language-type-int">int Type</a>, a compile-time error occurs.

By suffixing "L" or "l" at the end, that represents <a href="#language-type-long">long Type</a> Integer Literal.

If <a href="#language-type-long">long Type</a> Integer Literal  exceeds the range of numbers that can be represented by <a href="#language-type-long">long Type</a>,  If it exceeds the range, a compile-time error occurs.

"_" can be used as a Separator. Separator has no meaning.

If Integer Literal is assigned to a <a href="#language-type-byte">byte Type</a> variable or passed to <a href="#language-type-byte">byte Type</a> Subroutine Argument, and does not exceed the range of numbers that can be represented by <a href="#language-type-byte">byte Type</a>, <a href = "#language-type-convertion-numeric-narrowing">Numeric Narrowing Type Convertion</a> is applied and the value converted to <a href="#language-type-byte">byte Type</a> value. If it exceeds the range, a compile-time error will occur.

If Integer Literal is assigned to a <a href="#language-type-short">short Type</a> variable or passed to <a href="#language-type-short">short Type</a> Subroutine Argument, and does not exceed the range of numbers that can be represented by <a href="#language-type-short">short Type</a>, <a href = "#language-type-convertion-numeric-narrowing">Numeric Narrowing Type Convertion</a> is applied and the value converted to <a href="#language-type-short">short Type</a> value. If it exceeds the range, a compile-time error will occur.

<b>Integer Literal Example:</b>

<pre>
123
+123
-123
123L
123l
123_456_789
-123_456_789L
</pre>

<h5>Hexadecimal Representation of Integer Literal</h5>

Hexadecimal Representation of Integer Literal is represented by the following rule.

Hexadecimal Representation of Integer Literal starts with "0x" or "0X".

It is followed by one or more consecutive characters "0" to "9", "a" to "f", or "A" to "F"..

Other rules are same as Decimal Representation of Integer Literal

<b>Hexadecimal Representation of Integer Literal Example:</b>

<pre>
0x3b4f
-0x3F1A
0xDeL
0xFFFFFFFF_FFFFFFFF
</pre>

<h5>Octal Representation of Integer Literal</h5>

Octal Representation of Integer Literal is represented by the following rule.

Octal Representation of Integer Literal starts with "0".

It is followed by one or more consecutive characters "0" to "7".

Other rules are same as Decimal Representation of Integer Literal

<b>Octal Representation of Integer Literal Example:</b>

<pre>
0755
-0644
0666L
0655_755
</pre>

<h5>Binary Representation of Integer Literal</h5>

Binary Representation of Integer Literal is represented by the following rule.

Binary Representation of Integer Literal starts with "0b" or "0B".

It is followed by one or more consecutive characters "0" or "1".

<b>Binary Representation of Integer Literal Example:</b>

<pre>
0b0101
-0b1010
0b110000L
0b10101010_10101010
</pre>

<h4 id="language-literal-floating-point">Floating Point Literal</h4>

Floating Point Literal consists of <b>Sign Part</b>, <b>Numeric Part</b>, <b>Exponent Part</b> and <b>Suffix</b>.

<pre>
# Floating Point Literal
[Sign Part][Numeric Part][Exponent Part][Suffix Part]
</pre>

Floating Point Literal is <b>Decimal Floating Point Literal</b> or <b>Hexadecimal Floating Point Literal</b>.

<b>Sign Part</b> is represented by "+" or "-". Sign Part is optional.

Numeric Part of Decimal Floating Point Literal starts one or more "0" to "9".

Numeric Part of Hexadecimal Floating Point Literal starts "0x" or "0X", and is followed by "0" to "9", "a" to "f", or "A" to "F".

For that the Literal is Floating Point Literal, Numeric Part contains "." or, The Literal have Exponent Part, or have Suffix Part.


Numeric part can contain "_". This is just a Numeric Separator and is ignored.

Hexadecimal Floating Point Literal needs Exponent Part.

<b>Exponent Part</b> is consist of <b>Exponential Notation</b> and <b>Signed Decimal Integer</b>.

<pre>
# Exponent Part
[Exponential Notation][Signed Decimal Integer]
</pre>

Exponential Notation is "e" or "E" for Decimal Floating Point Literal, and "p" or "P" for Hexadecimal Floating Point Literal.

The meaning of Exponent Part is decimal shift for Decimal Floating Point Literal, or binary shift for Hexadecimal Floating Point Literal.

If Suffix Part is "f" or "F", the <a href="#language-type">Type</a> of Floating Point Literal is <a href="#language-type-float">float Type</a>.

If Suffix Part is "d" or "D", the <a href="#language-type">Type</a> of Floating Point Literal is <a href="#language-type-double">double Type</a>.

If Suffix Part is omitted, the <a href="#language-type">Type</a> of Floating Point Literal is <a href="#language-type-double">double Type</a>.

If Floating Point Literal is <a href="#language-type-float">float Type</a>, the Floating Point Literal is converted to float value using C standard "strtof" function. If the conversion fails, a compile-time error occurs.

If Floating Point Literal is <a href="#language-type-double">double Type</a>, the Floating Point Literal is converted to double value using C standard "strtod" function. If the conversion fails, a compile-time error occurs.

<b>Floating Point Literal Example:</b>

<pre>
1.32
-1.32
1.32f
1.32F
1.32e3
1.32e-3
1.32E+3
1.32E-3
0x3d3d.edp0
0x3d3d.edp3
0x3d3d.edP3
0x3d3d.edP-3f
</pre>

<h4 id="language-literal-character">Charater Literal</h4>

<b>Charater Literal</b> represents one character of ASCII code.

Character Literal is enclosed in single quotes "'".

Content of Character Literal is one printable ASCII character or one Escape Character of Character Literal.

Charater Literal のTypeは"<a href="#language-type-byte">byte Type</a>"になります。

<a href="#language-type">Type</a> of Charater Literal is <a href="#language-type-byte">byte Type</a>.

<table class="toc">
  <tr>
    <th>
      Escape Characters of Character Literal
    </th>
    <th>
      Description
    </th>
  </tr>
  <tr>
    <td>
      <b>\0</b>
    </td>
    <td>
      ASCII Code 0 NUL
    </td>
  </tr>
  <tr>
    <td>
      <b>\a</b>
    </td>
    <td>
      ASCII Code 7 BEL
    </td>
  </tr>
  <tr>
    <td>
      <b>\b</b>
    </td>
    <td>
      ASCII Code 8 BS
    </td>
  </tr>
  <tr>
    <td>
      <b>\t</b>
    </td>
    <td>
      ASCII Code 9 HT
    </td>
  </tr>
  <tr>
    <td>
      <b>\n</b>
    </td>
    <td>
      ASCII Code 10 LF
    </td>
  </tr>
  <tr>
    <td>
      <b>\f</b>
    </td>
    <td>
      ASCII Codeの12"FF"
    </td>
  </tr>
  <tr>
    <td>
      <b>\r</b>
    </td>
    <td>
      ASCII Code 13 CR
    </td>
  </tr>
  <tr>
    <td>
      <b>\"</b>
    </td>
    <td>
      ASCII Code 34 "
    </td>
  </tr>
  <tr>
    <td>
      <b>\'</b>
    </td>
    <td>
      ASCII Code 39 '
    </td>
  </tr>
  <tr>
    <td>
      <b>\\</b>
    </td>
    <td>
      ASCII Code 92 \
    </td>
  </tr>
  <tr>
    <td>
      <b>\x + tow hexadecimal numbers</b>
    </td>
    <td>
      Specify ASCII code by hexadecimal. Hexadecimal numbers are "0" to "9", "a" to "z", "A" to "Z".
    </td>
  </tr>
</table>

<b>Charater Literal Example:</b>

<b>Charater Literal</b> represents one character of ASCII code.

<pre>
# Charater Literal 
'a'
'x'

# Charater Literal using Escape Character
'\a'
'\b'
'\t'
'\n'
'\f'
'\r'
'\"'
'\''
'\\'
'\x0D'
'\x0A'
</pre>

<h4 id="language-literal-string">String Literal</h4>

<b>String Literal</b> represents String.

String Literal is enclosed in double quotes '"'.

The content of String Literal is zero or more ASCII printable Characters or Escape Characters of String Literal".

<table class="toc">
  <tr>
    <th>
      Escape Character of String Literal
    </th>
    <th>
      Description
    </th>
  </tr>
  <tr>
    <td>
      <b>\0</b>
    </td>
    <td>
      ASCII Code 0 NUL
    </td>
  </tr>
  <tr>
    <td>
      <b>\a</b>
    </td>
    <td>
      ASCII Code 7 BEL
    </td>
  </tr>
  <tr>
    <td>
      <b>\b</b>
    </td>
    <td>
      ASCII Code 8 BS
    </td>
  </tr>
  <tr>
    <td>
      <b>\t</b>
    </td>
    <td>
      ASCII Code 9 HT
    </td>
  </tr>
  <tr>
    <td>
      <b>\n</b>
    </td>
    <td>
      ASCII Code 10 LF
    </td>
  </tr>
  <tr>
    <td>
      <b>\f</b>
    </td>
    <td>
      ASCII Code 12 FF
    </td>
  </tr>
  <tr>
    <td>
      <b>\r</b>
    </td>
    <td>
      ASCII Code 13 CR
    </td>
  </tr>
  <tr>
    <td>
      <b>\"</b>
    </td>
    <td>
      ASCII Code 34 "
    </td>
  </tr>
  <tr>
    <td>
      <b>\'</b>
    </td>
    <td>
      ASCII Code 39 '
    </td>
  </tr>
  <tr>
    <td>
      <b>\\</b>
    </td>
    <td>
      ASCII Code 92 \
    </td>
  </tr>
  <tr>
    <td>
      <b>\x + two hexadecimal numbers</b>
    </td>
    <td>
      Specify ASCII code by hexadecimal. Hexadecimal numbers are "0" to "9", "a" to "z", "A" to "Z". <br>For example, \x0D.
    </td>
  </tr>
  <tr>
    <td>
      <b>\N{U+} + hexadecimal numbers after U+</b>
    </td>
    <td>
      Specify the Unicode code point in hexadecimal. Hexadecimal numbers are expressed as "0" to "9", "a" to "f", "A" to "F".<br>For example, \N{U+3046}.<br>The code point is converted to UTF-8. 
    </td>
  </tr>
  <tr>
    <td>
      <b>\s</b>
    </td>
    <td>
      ASCII Code 92,115 \s
    </td>
  </tr>
  <tr>
    <td>
      <b>\S</b>
    </td>
    <td>
      ASCII Code 92,83 \S
    </td>
  </tr>
  <tr>
    <td>
      <b>\d</b>
    </td>
    <td>
      ASCII Code 92,100 \d
    </td>
  </tr>
  <tr>
    <td>
      <b>\D</b>
    </td>
    <td>
      ASCII Code 92,68 \D
    </td>
  </tr>
  <tr>
    <td>
      <b>\w</b>
    </td>
    <td>
      ASCII Code 92,119 \w
    </td>
  </tr>
  <tr>
    <td>
      <b>\W</b>
    </td>
    <td>
      ASCII Code 92,87 \W
    </td>
  </tr>
  <tr>
    <td>
      <b>\ + ASCII Code Punctuation Character(33 to 47, 58 to 64, 91 to 96, 123 to 125)</b>
    </td>
    <td>
      ASCII Code 92, Number of ASCII Code Punctuation Character. For eample, \- represents \-. \+ represents \+.
    </td>
  </tr>
</table>

<b>String Literal Example:</b>

<pre>
# String Literal 
"abc"
"あいう"

# Escape Character of String Literal 
"abc\tdef\n"
"\x0D\x0A"
"\N{U+3042}\N{U+3044}\N{U+3046}"
</pre>

<h4 id="language-literal-string-variable-expansion">Variable Expansion</h4>

<b>Variable Expansion</b> applys <a href="#language-lex-var">Lexical Variable</a>, <a href="#language-package-var">Package Variable</a>, <a href="#language-ref-deref">Dereference</a>, <a href="#language-field-access">Field Access</a>, <a href="#language-array-access">Array Access</a>, <a href="#language-exception-var">Exception Variable</a> in String Literal.

<pre>
"AAA $foo BBB"
"AAA $FOO BBB"
"AAA $$foo BBB"
"AAA $foo->{x} BBB"
"AAA $foo->[3] BBB"
"AAA $foo->{x}[3] BBB"
"AAA $@ BBB"
</pre>

The above is expanded as the following.

<pre>
"AAA" . $foo . "BBB"
"AAA" . $FOO . "BBB"
"AAA" . $$foo . "BBB"
"AAA" . $foo->{x} . "BBB"
"AAA" . $foo->[3] . "BBB"
"AAA" . $foo->{x}[3] . "BBB"
"AAA" . $@ . "BBB"
</pre>

The variable name can besurround with "{" and "}" to indicate the end of the variable name.

<pre>
"AAA ${foo}_ccc BBB"
</pre>
<p>

The above is expanded as the following.

</p>
<pre>
"AAA " . ${foo} . "_ccc BBB"
</pre>

If there is no enclosing "{" and "}", up to the valid part as a variable name is interpreted as a Variable. Dereference interpreting is same as this.

If "->" follows the variable name, it is interpreted as <a href="#language-field-access">Field Access</a> or <a href="#language-array-access">Array Access</a>.

[1] If the following Characters are "a-z" "A-Z" "0-9" "_" "{" "[", proceed with the interpretation.

[2] If the Character following [1] is "}", or "]", then if the next Character is "->", "{", or "[", proceed with the interpretation and return back to [1]. Otherwise stop interpreting.

The trailing $ is not treated as the start of Variable Expansion. It is treated as "$".

<pre>
"AAA$"
</pre>

<h3 id="language-string">String</h3>

SPVM String is <a href="#language-type-array-byte">byte[] Type</a>. 

<pre>
# String is Array of byte Type
my $string = new byte[3];
$string->[0] = 'a';
$string->[1] = 'b';
$string->[2] = 'c';
</pre>

<a href="#language-type-array-byte">byte[] Type</a> can be assigned to <a href="#language-type-string">string Type</a>. The address of String is copied to the distination Variable.

<pre>
my $string_const : string = $string;
</pre>

<a href="#language-type-string">string Type</a> is same as <a href="#language-type-array-byte">byte[] Type</a>, but can't set the element value.

<pre>
# Compile Time Error
$string_const->[0] = 'd';
</pre>

String can be created by assigning <a href="#language-literal-string">String Literal</a>. a new String that is return  a new String based on String Literal.

A new String is created that copies the value of the String Literal. The Type of the returned string is <a href="#language-type-string">string Type</a>.

<pre>
my $string_const = "abc";
</pre>

<a href="#language-type-array-byte">byte [] Type</a> is designed to represent "<b>char *</b>" type in C language.

<a href="#language-type-string">string Type</a> is designed to represent "<b>const char *</b>" type in C language.

<h3 id="language-undef">Undefined Value</h3>

Undefined Value is "undef"

<pre>
undef
</pre>

Undefined Value can be assigned to all <a href="#language-type-object">Object Type</a> variable.

Undefined Value can be compared with the value of Object Type using "==" Operator or "!=" Operator. Undefined Value is guaranteed not to be equal to the created object.

If Undefined Value is used in the Condition Part, it will be false.

<h3 id="language-array">Array</h3>

<ul class="list">
  <li><a href="#language-array-summary">Array Summary</a></li>
  <li><a href="#language-array-new">Create Array</a></li>
  <li><a href="#language-array-access">Array Access</a></li>
</ul>
<h4 id="language-array-summary">Array Summary</h4>

Array is a data structure for continuous multiple values.

There are the following types of Array.

<ul class="list">
  <li>
    Numeric Type Array
  </li>
  <li>
    Object Type Array
  </li>
  <li>
    Multi Numeric Type Array
  </li>
</ul>

Numeric Type Array is Array that element type is <a href="#language-type-numeric">Numeric Type</a>.

Numeric Type Array is Array that element type is <a href="#language-type-object">Object Type</a>.

Numeric Type Array is Array that element type is <a href="#language-type-multi-numeric">Multi Numeric Type</a>.

<h4 id="language-array-summary">Create Array</h4>

See <a href="#language-expression-new-array">Create Array</a> to create Array.

<h4 id="language-array-access">Array Access</h4>

Array Access is an operation to access the element of Array to get or set the value.

<pre>
ARRAY->[INDEX]
</pre>

See <a href="#language-expression-get-array-element">Get Array Element Value</a> to get the element value of Array.

See <a href="#language-expression-set-array-element">Set Array Element Value</a> to set the element value of Array.

<h3 id="language-mulnum">Multi Numeric Value</h3>

<ul class="list">
  <li><a href="#language-mulnum-definition">Multi Numeric Type Definition</a></li>
  <li><a href="#language-mulnum-definition">Multi Numeric Type Suffix</a></li>
  <li><a href="#language-mulnum-usage">Multi Numeric Type Usage</a></li>
  <li><a href="#language-mulnum-access">Multi Numeric Type Field Access</a></li>
</ul>

<h4 id="language-mulnum-definition">Multi Numeric Type Definition</h4>

Multi Numeric type represents continuous numeric values. For example, there are three consecutive 32-bit signed integers, two consecutive double-precision floating point numbers. It isplaned to use 3D points, complex numbers, quaternions, etc.

Multi Numeric Type is defined by specifying mulnum_t <a href="#language-package-descriptor">Package Descriptor</a> in <a href="#language-package-definition">Package Definition</a>.

<pre>
# Three consecutive 32bit signed integers
package Point_3i : mulnum_t {
  has x : int;
  has y : int;
  has z : int;
}

# Tow consecutive 64bit floating point numbers
package Complex_2d : mulnum_t {
  x : double;
  y : double;
}
</pre>

Multi Numeric Type must end with "_", Number of Fields, <a href="#language-mulnum-definition"> Multi Numeric Type Suffix</a>.

The suffix must correspond to <a href="#language-type-numeric">Numeric Type</a>.

All Fields must be the same <a href="#language-type-numeric">Numeric Type</a>.

The maximum number of Fields is 255.

Multi Numeric Type can be used as <a href="#language-type">Type</a> of <a href="#language-lex-var-declaration">Lexical Variable Declaration</a>.

Multi Numeric Type can be used as an argument <a href="#language-type">Type</a> in <a href="#language-sub-definition">Subroutine Definition</a> .

Multi Numeric Type can be used as <a href="#language-type">Type</a> of Return Value in <a href="#language-sub-definition">Subroutine Definition</a>.

Multi Numeric Type can be used as <a href="#language-type-basic">Basic Type</a> of <a href="#language-type-array">Array Type</a> .

<pre>
my $points = new Point_3i[5];
</pre>

Reference can be created for Multi Numeric Type value.

<pre>
my $point : Point_3i;
my $point_ref = \$point;
</pre>

<a href="#language-undef">Undefined Value</a> cannot be assigned to Multi Numeric Type value.

See <a href="#language-mulnum-access">Multi Numeric Type Field Access</a> to get and set the value of field of Multi Numeric Type Value.

<h4>Multi Numeric Type Suffix</h4>

List of Multi Numeric Type Suffix.

<table>
  <tr>
    <th>
      <b>Numeric Type</b>
    </th>
    <th>
      Multi Numeric Type Suffix
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      b
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      s
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      i
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      l
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      f
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      d
    </td>
  </tr>
</table>

<h4 id="language-mulnum-usage">Multi Numeric Type Usage</h4>

To use Multi Numeric Type, load a Module using <a href="#language-module-use">use Statement</a>.

<pre>
use Point_3i;
use Complex_2d;
</pre>


Next is <a href="#language-lex-var-declaration">Lexical Variable Declaration</a>. Lexical Variable Declaration create continuous area for fields of Multi Numeric Type Value on <a href="#language-sub-stack">Subroutine Callstack</a>. All fields of of Multi Numeric Type Value are initialized by <a href="#language-type-initial-value">Type Initial Value</a>.

<pre>
my $point : Point_3i;
my $z : Complex_2d;
</pre>

Note that Multi Numeric Type value are not object, so cannot create a Object by <a href="#language-expression-new">new</a> syntax.

<h4 id="language-mulnum-access">Multi Numeric Type Field Access</h3>

<b>Multi Numeric Type Field Access</b> is an operation to access Multi Numeric Type Field to get or set a value.

<pre>
MULTI_NUMERIC_TYPE_VALUE->{FIELD_NAME}
</pre>

See <a href="#language-expression-get-field-multi-numeric">Get Multi Numeric Type Field Value</a> to get Multi Numeric Type Field Value.

See <a href="#language-expression-set-field-multi-numeric">Set Multi Numeric Type Field Value</a> to set Multi Numeric Type Field Value.

<h3 id="language-mulnum-array">Multi Numeric Array</h3>
<ul class="list">
  <li><a href="#language-mulnum-array-summary">Multi Numeric Array Summary</a></li>
  <li><a href="#language-mulnum-array-access">Multi Numeric Array Access</a></li>
</ul>

<h4 id="language-mulnum-array-summary">Multi Numeric Array Summary</h4>

<a href="#language-mulnum">Multi Numeric Value</a> can be an element of <a href="#language-array">Array</a>.

<pre>
my $points = new Point_3i[5];

my $zs = new Complex_2d[5];
</pre>

Multi Numeric Array has continuous Multi Numeric Values.

The Element Type is <a href="#language-type-multi-numeric">Multi Numeric Type</a>, not <a href="#language-type-object">Object Type</a>.

For example, Point_3i[5] is continuous 15 (= 3 * 5) count <a href="#language-type-int">int Type</a> Value.

<a href="#language-type">Type</a> of Multi Numeric Array is <a href="#language-type-array">Array Type</a>.

<h4 id="language-mulnum-array-access">Multi Numeric Array Access</h4>

Multi Numeric Array Access is an operation to access Multi Numeric Array to get and set the element value.

<pre>
Array->[INDEX]
</pre>

See <a href="#language-expression-get-array-element">Get Array Element Value</a> to get Array Element Value.

See <a href="#language-expression-set-array-element">Set Array Element Value</a> to get Array Element Value.

<h3 id="language-ref">Reference</h3>
<ul>
  <li><a href="#language-ref-summary">Reference Summary</a></li>
  <li><a href="#language-ref-deref">Dereference</a></li>
</ul>

<h4 id="language-ref">Reference Summary</h4>

Reference is data that indicates the location of <a href="#language-lex-var">Lexical Variable</a> in the memory. Reference is a feature corresponding to Pointer in C language.

You can get Reference of Lexical Variable using <a href="#language-expression-operator-ref">Reference Operator</a>.

<a href="#language-type-ref">Reference Type</a> is represented by <a href="#language-type-numeric">Numeric Type</a> "&" or <a href="# language-type-multi-numeric ">Multi Numeric Type</a> followed by "&".
Reference types are represented by appending an & after <a href="#language-type-numeric">Numeric Type</a> or <a href="# language-type-multi-numeric ">Multi Numeric Type</a>.

<pre>
# Numeric Type Reference
my $num : int;
my $num_ref : int& = \$num;

# Multi Numeric Type Reference
my $point : Point_3d;
my $point_ref : Point_3d& = \$point;
</pre>

Target of Reference Operator is Variable of <a href="#language-type-numeric">Numeric Type</a> or <a href="#language-type-multi-numeric">Multi Numeric Type</a>. <a href="#language-type-object">Object Type</a> Variable or <a href="#language-literal">Literal</a> can't be target of Reference Operator.

<a href="#language-type-ref">Reference Type</a> can be used in Subroutine Argument.

<pre>
# Subroutine Definition
sub sum : void ($out_ref : int&, $in1 : int, $in2 : int) {
  $$out_ref = $in1 + $in2;
}

# Subroutine Call
my $num1 = 1;
my $num2 = 2;
my $out : int;
my $out_ref = \$out;
sum($out_ref, $num1, $num2);
</pre>

<h4 id="language-ref-deref">Dereference</h4>

Dereference is an operation to get and set the value pointed by Reference.

<pre>
# Dereference Numeric Type Reference to get the pointed value
my $num2 = $$num_ref;

# Dereference Numeric Type Reference to set the pointed value
$$num_ref = 3;

# Dereference Mutil Numeric Type Reference to get the pointed value
my $point2 = $$point_ref;

# Dereference Mutil Numeric Type Reference to set the pointed value
$$point_ref = $point2;
</pre>

If the target of Reference Type is <a href="#language-type-multi-numeric">Multi Numeric Type</a>, the setting and getting of Multi Numeric Type Field Value can be done by Arrow Operator.

<pre>
# If the target of Reference Type is Multi Numeric Type, get Multi Numeric Type Field Value
my $x = $point_ref->{x};

# If the Target of Reference Type is Multi Numeric Type, set Multi Numeric Type Field Value
$point_ref->{x} = 1;
</pre>

<h3 id="language-expression"><a href="#language-expression">Expression</a></h3>

Expression is a syntax component that can be evaluated as a value.

<ul class="list">
  <li><a href="#language-expression-operator">Operator</a></li>
  <li><a href="#language-expression-get-lex-var">Get Lexical Variable Value</a></li>
  <li><a href="#language-expression-set-lex-var">Set Lexical Variable Value</a></li>
  <li><a href="#language-expression-set-package-var">Get Package Variable Value</a></li>
  <li><a href="#language-expression-get-package-var">Set Package Variable Value</a></li>
  <li><a href="#language-expression-get-exception-var">Get Exception Variable Value</a></li>
  <li><a href="#language-expression-set-exception-var">Set Exception Variable Value</a></li>
  <li><a href="#language-literal">Literal</a></li>
  <li><a href="#language-undef">Undefined Value</a></li>
  <li><a href="#language-expression-callsub">Subroutine Call</a></li>
  <li><a href="#language-expression-get-field-class-based-object">Get Class Based Object Field Value</a></li>
  <li><a href="#language-expression-set-field-class-based-object">Set Class Based Object Field Value</a></li>
  <li><a href="#language-expression-get-field-multi-numeric">Get Multi Numeric Type Field Value</a></li>
  <li><a href="#language-expression-set-field-multi-numeric">Set Multi Numeric Type Field Value</a></li>
  <li><a href="#language-expression-get-field-multi-numeric-deref">Get Multi Numeric Type Field Value via Dereference</a></li>
  <li><a href="#language-expression-set-field-multi-numeric-deref">Set Multi Numeric Type Field Value via Dereference</a></li>
  <li><a href="#language-expression-get-array-element">Get Array Element Value</a></li>
  <li><a href="#language-expression-set-array-element">Set Array Element Value</a></li>
  <li><a href="#language-expression-typecast">Type Cast</a></li>
  <li><a href="#language-expression-new">Create Object</a></li>
  <li><a href="#language-expression-new-array">Create Array</a></li>
  <li><a href="#language-expression-array-init">Array Initialization</a></li>
  <li><a href="#language-expression-current-package">Get Current Package Name</a></li>
  <li><a href="#language-expression-current-file">Get Current File Name</a></li>
  <li><a href="#language-expression-current-line">Get Current Line Number</a></li>
  <li>(Expression)</li>
</ul>

<h4 id="language-expression-operator">Operator</h4>

<a href="#language-operator">Operator</a> is a Expression.

<h4 id="language-expression-get-lex-var">Get Lexical Variable Value</h4>
<p>
  Get Lexical Variable Valueをするには,Lexical Variable 自体を記述します。
</p>
<pre>
$var
</pre>
<p>
  Get Lexical Variable Valueは,<a href="#language-expression">Expression</a>です。
</p>

<h4 id="language-expression-set-lex-var">Set Lexical Variable Value</h4>
<p>
  Set Lexical Variable Valueを行うには,<a href="#language-expression-operator-assign">Assignment Operator</a>を使用します。
</p>
<pre>
$var = Right Expression
</pre>
<p>
  代入が<a href="#language-type-compatible">Type Compatibility</a>を満たさない場合は,a compile-time error occurs
</p>
<p>
  Set Lexical Variable Valueは,設定後の値を返します。
</p>
<p>
  Set Lexical Variable Valueは,<a href="#language-expression">Expression</a>です。
</p>
<p>
  Right Expressionが,Object Type であった場合は,オブジェクトのReference Countが1増やされます。
</p>
<p>
  代入前に,すでに$varにオブジェクトが代入されていた場合は,そのオブジェクトのReference Countが1減らされます。
</p>

<h4 id="language-expression-get-package-var">Get Package Variable Value</h4>

Use the following syntax to get the value of Package Variable.

<p>
  Package Variable の値を取得するにはthe following syntax を使用します。
</p>

<pre>
$PACKAGE_NAME::PACKAGE_VARIABLE_NAME
</pre>
<p>
  自分自身のPackage に属するPackage Variable の場合は"PACKAGE_NAME::"を省略できます。
</p>
<pre>
$PACKAGE_VARIABLE_NAME
</pre>

<p>
 Get Package Variable Valueは,<a href="#language-expression">Expression</a>を返します。
</p>

<p>
  DefinitionされていないPackage Variable の値を取得しようとした場合は,a compile-time error occurs
</p>

<p>
  Package 外側からプライベートなPackage Variable にアクセスしようとした場合は,a compile-time error occurs
</p>

<p>
  <b>Get Package Variable Value Example:</b>
</p>
<pre>
package Foo {
  our $VAR : int;

  sub bar : int () {
    my $var1 = $Foo::VAR;
    my $var2 = $VAR;
  }
}
</pre>

<h4 id="language-expression-set-package-var">Set Package Variable Value</h4>
<p>
  Package Variable の値を設定するにはthe following syntax を使用します。
</p>
<pre>
$Class名::Package Variable Name = Right Expression
</pre>
  自分自身のPackage に属するPackage Variable の場合は"Class名::"を省略できます。
</p>
<pre>
$Package Variable Name = Right Expression
</pre>
<p>
  Package Variable 設定は,<a href="#language-expression">Expression</a>を返します。返される結果は,代入後のPackage Variable の値です。
</p>
<p>
  DefinitionされていないPackage Variable の値を設定しようとした場合は,コンパイル時エラーが設定します。
</p>
<p>
  Package 外側からプライベートなPackage Variable にアクセスしようとした場合は,a compile-time error occurs
</p>
<p>
  <b>Set Package Variable Value Example:</b>
</p>
<pre>
package Foo {
  our $VAR : int;

  sub bar : int () {
    $Foo::VAR = 1;
    $VAR = 3;
  }
}
</pre>

<h4 id="language-expression-get-exception-var">Get Exception Variable Value</h4>
<p>
  Exception Variableの値を取得するにはthe following syntax を使用します。
</p>
<pre>
$@
</pre>
<p>
 Get Exception Variable Valueは,<a href="#language-expression">Expression</a>を返します。
</p>
<p>
 Get Exception Variable Valueは,<a href="#language-type-string">string Type</a>の値を返します。
</p>
<p>
  <b>Get Exception Variable ValueのExample</b>
</p>
<p>
  Get Exception Variable ValueのExampleです。
</p>
<pre>
eval {
  foo();
};

if (my $message = $@) {

}
</pre>

<h4 id="language-expression-set-exception-var">Set Exception Variable Value</h4>
<p>
  Exception Variableの値を設定するにはthe following syntax を使用します。
</p>
<pre>
$@ = Right Expression
</pre>
<p>
  Right Expressionは<a href="#language-type-string-compatible">String Compatible Type</a>でなければなりません。
</p>
<p>
 Set Exception Variable Valueは,<a href="#language-expression">Expression</a>を返します。
</p>
<p>
 Set Exception Variable Valueは,設定後のException Variableの値を返します。これは,<a href="#language-type-string">string Type</a>です。
</p>
<p>
  <b>Set Exception Variable ValueのExample</b>
</p>
<p>
  Set Exception Variable ValueのExampleです。
</p>
<pre>
$@ = "Error";
</pre>

<h4 id="language-expression-get-field-class-based-object">Get Class Based Object Field Value</h4>
<p>
  Get Class Based Object Field Valueは,次のように記述します。
</p>
<pre>
Invocant Expression->{Field Name}
</pre>
<p>
  Invocant Expressionは,<a href="#language-type-class">Class Type</a>の値でなければなりません。Invocant Expressionが,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric">Get Multi Numeric Type Field Value</a>になり,<a href="#language-type-ref-multi-numeric">Multi Numeric Reference Type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric-deref">Get Multi Numeric Type Field Value via Dereference</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Get Class Based Object Field Valueは,オブジェクトに保存されているFieldの値を返します。これは<a href="#language-expression">Expression</a>です。
</p>
<p>
  返される値のTypeは,FieldのTypeです。
</p>
<p>
  <b>Get Class Based Object Field ValueのExample</b>
</p>
<p>
  Get Class Based Object Field ValueのExampleです。
</p>
<pre>
my $point = Point->new;
my $x = $point->{x};
</pre>

<h4 id="language-expression-set-field-class-based-object">Set Class Based Object Field Value</h4>
<p>
  Set Class Based Object Field Valueは,次のように記述します。
</p>
<pre>
Invocant Expression->{Field Name} = Right Expression
</pre>
<p>
  Invocant Expressionは,<a href="#language-type-class">Class Type</a>の値でなければなりません。Invocant Expressionが,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric">Set Multi Numeric Type Field Value</a>になり,<a href="#language-type-ref-multi-numeric">Multi Numeric Reference Type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric-deref">Set Multi Numeric Type Field Value via Dereference</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Right ExpressionのTypeは,FieldのTypeと同じでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Set Class Based Object Field Valueは,設定後のオブジェクトに保存されているFieldの値を返します。これは<a href="#language-expression">Expression</a>です。
</p>
<p>
  返される値のTypeは,FieldのTypeです。
</p>
<p>
  Right Expressionが,Object Type であった場合は,オブジェクトのReference Countが1増やされます。
</p>
<p>
  代入前に,すでにFieldにオブジェクトが代入されていた場合は,そのオブジェクトのReference Countが1減らされます。
</p>
<p>
  <b>Set Class Based Object Field ValueのExample</b>
</p>
<p>
  Set Class Based Object Field ValueのExampleです。
</p>
<pre>
my $point = Point->new;
$point->{x} = 1;
</pre>

<h4 id="language-expression-get-field-multi-numeric">Get Multi Numeric Type Field Value</h4>
<p>
  Get Multi Numeric Type Field Valueは,次のように記述します。
</p>
<pre>
Invocant Expression->{Field Name}
</pre>
<p>
  Invocant Expressionは,<a href="#language-type-class">Multi Numeric Type</a>の値でなければなりません。Invocant Expressionが,<a href="#language-type-class">Class Type</a>の値であった場合は,<a href="#language-expression-get-field-class-based-object">Get Class Based Object Field Value</a>になり,<a href="#language-type-ref-multi-numeric">Multi Numeric Reference Type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric-deref">Get Multi Numeric Type Field Value via Dereference</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Get Multi Numeric Type Field Valueは,<a href="#language-sub-stack">Subroutine Callstack</a>に保存されている該当するFieldの値を返します。これは<a href="#language-expression">Expression</a>です。
</p>
<p>
  返される値のTypeは,FieldのTypeです。
</p>
<p>
  <b>Get Multi Numeric Type Field ValueのExample</b>
</p>
<p>
  Get Multi Numeric Type Field ValueのExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $re = $z->{x};
</pre>

<h4 id="language-expression-set-field-multi-numeric">Set Multi Numeric Type Field Value</h4>
<p>
  Set Multi Numeric Type Field Valueは,次のように記述します。
</p>
<pre>
Invocant Expression->{Field Name} = Right Expression
</pre>
<p>
  Invocant Expressionは,<a href="#language-type-class">Multi Numeric Type</a>の値でなければなりません。Invocant Expressionが,<a href="#language-type-class">Class Type</a>の値であった場合は,<a href="#language-expression-set-field-class-based-object">Set Class Based Object Field Value</a>になり,<a href="#language-type-ref-multi-numeric">Multi Numeric Reference Type</a>の値であった場合は,<a href="#language-expression-set-field-multi-numeric-deref">Set Multi Numeric Type Field Value via Dereference</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Right ExpressionのTypeは,FieldのTypeと同じでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Set Multi Numeric Type Field Valueは,設定後の<a href="#language-sub-stack">Subroutine Callstack</a>に保存されている該当するFieldの値を返します。これは<a href="#language-expression">Expression</a>です。
</p>
<p>
  返される値のTypeは,FieldのTypeです。
</p>
<p>
  <b>Set Multi Numeric Type Field ValueのExample</b>
</p>
<p>
  Set Multi Numeric Type Field ValueのExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
$z->{x} = 2.5;
</pre>

<h4 id="language-expression-get-field-multi-numeric-deref">Dereference によるGet Multi Numeric Type Field Value</h4>
<p>
  Dereference によるGet Multi Numeric Type Field Valueは,次のように記述します。
</p>
<pre>
Invocant Expression->{Field Name}
</pre>
<p>
  Invocant Expressionは,<a href="#language-type-ref-multi-numeric">Multi Numeric Reference Type</a>の値でなければなりません。Invocant Expressionが,<a href="#language-type-class">Class Type</a>の値であった場合は,<a href="#language-expression-get-field-class-based-object">Get Class Based Object Field Value</a>になり,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric">Get Multi Numeric Type Field Value</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Dereference によるGet Multi Numeric Type Field Valueは,<a href="#language-sub-stack">Subroutine Callstack</a>に保存されている該当するFieldの値を返します。これは<a href="#language-expression">Expression</a>です。
</p>
<p>
  返される値のTypeは,FieldのTypeです。
</p>
<p>
  <b>Dereference によるGet Multi Numeric Type Field ValueのExample</b>
</p>
<p>
  Dereference によるGet Multi Numeric Type Field ValueのExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
my $re = $z_ref->{x};
</pre>

<h4 id="language-expression-set-field-multi-numeric-deref">Dereference によるSet Multi Numeric Type Field Value</h4>
<p>
  Dereference によるSet Multi Numeric Type Field Valueは,次のように記述します。
</p>
<pre>
Invocant Expression->{Field Name} = Right Expression
</pre>
<p>
  Invocant Expressionは,<a href="#language-type-ref-multi-numeric">Multi Numeric Reference Type</a>の値でなければなりません。Invocant Expressionが,<a href="#language-type-class">Class Type</a>の値であった場合は,<a href="#language-expression-set-field-class-based-object">Set Class Based Object Field Value</a>になり,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値であった場合は,<a href="#language-expression-set-field-multi-numeric">Set Multi Numeric Type Field Value</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Right ExpressionのTypeは,FieldのTypeと同じでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Dereference によるSet Multi Numeric Type Field Valueは,設定後の<a href="#language-sub-stack">Subroutine Callstack</a>に保存されている該当するFieldの値を返します。これは<a href="#language-expression">Expression</a>です。
</p>
<p>
  返される値のTypeは,FieldのTypeです。
</p>
<p>
  <b>Dereference によるSet Multi Numeric Type Field ValueのExample</b>
</p>
<p>
  Dereference によるSet Multi Numeric Type Field ValueのExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{x} = 2.5;
</pre>

<h4 id="language-expression-get-array-element">Get Array Element Value</h4>
<p>
  Arrayの要素の値を取得するには,次のように記述します。
</p>
<p>
ArrayExpression->[インデックスExpression]
</p>
<p>
  ArrayExpressionは,<a href="#language-type-array">Array Type</a>の値でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  インデックスExpressionは,<a href="#language-type-int">int Type</a> の値でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Arrayの要素の値を取得は,指定したインデックスの要素の値を返します。これは,Expressionです。
</p>
<p>
  実行時に,ArrayExpressionの値が,Undefined Valueである場合は,実行時例外が発生します。
</p>
<p>
  実行時に,インデックスの値が,0より小さい場合,あるいは,Arrayの最大のインデックスを超えている場合は,実行時例外が発生します。
</p>
<p>
  <b>Get Array Element ValueのExample</b>
</p>
<p>
  Get Array Element ValueのExampleです。
</p>
<pre>
my $nums = new int[3];
my $num = $nums->[1];

my $points = new Point[3];
my $point = $points->[1];

my $objects : oarray = $points;
my $object = (Point)$objects->[1];
</pre>

<h4 id="language-expression-set-array-element">Set Array Element Value</h4>
<p>
  Arrayの要素の値を設定するには,次のように記述します。
</p>
<p>
ArrayExpression->[インデックスExpression] = Right Expression
</p>
<p>
  ArrayExpressionは,<a href="#language-type-array">Array Type</a>の値でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  インデックスExpressionは,<a href="#language-type-int">int Type</a> の値でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Right ExpressionのTypeは,Arrayの要素のTypeと<a href="#language-type-compatible">Type Compatibility</a>がなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Arrayの要素の値を設定は,設定後の値を返します。これは,Expressionです。
</p>
<p>
  実行時に,ArrayExpressionの値が,Undefined Valueである場合は,実行時例外が発生します。
</p>
<p>
  実行時に,インデックスの値が,0より小さい場合,あるいは,Arrayの最大のインデックスを超えている場合は,実行時例外が発生します。
</p>
<p>
  Right Expressionが,Object Type であった場合は,オブジェクトのReference Countが1増やされます。
</p>
<p>
  代入前に,すでにArrayの要素にオブジェクトが代入されていた場合は,そのオブジェクトのReference Countが1減らされます。
</p>
<p>
  <b>Set Array Element ValueのExample</b>
</p>
<p>
  Set Array Element ValueのExampleです。
</p>
<pre>
my $nums = new int[3];
$nums->[1] = 3;

my $points = new Point[3];
$points->[1] = Point->new(1, 2);

my $objects : oarray = $points;
$objects->[2] = Point->new(3, 5);;
</pre>

<h4 id="language-expression-new">Create Object</h4>
<p>
  オブジェクトを生成するには,new  Keyword とthe following syntax をを使用します。
</p>
<pre>
my $object = new PACKAGE_NAME;
</pre>
<p>
  指定されたPackage は,<a href="#language-type-class">Class Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Fieldは,すべて<a href="#language-type-initial-value">Type Initial Value</a>で初期化されます。
</p>
<p>
  Create Objectは,<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  生成直後のオブジェクトのReference Countは,0です。代入が実行されるタイミングで,Reference Countが1増やされます。明示的な代入が行われない場合でも,一時変数が作成され,そこに代入されます。
</p>
<p>
  <b>Create ObjectのExample</b>
</p>
<pre>
my $object = new Foo;
</pre>
<p>
  生成されたオブジェクトは内部的に次の情報を持っています。
</p>
<ul class="list">
  <li>Reference Count</li>
  <li>Back references of Weaken Reference</li>
  <li>Basic Type ID</li>
  <li>Type Dimension(Always 0)</li>
</ul>

<h4 id="language-expression-new-array">Create Array</h4>
<p>
  Arrayを作成するには,new  Keyword とthe following syntax をを使用します。
</p>
<pre>
my $object = new Type[要素数Expression];
</pre>
<p>
  Typeには,<a href="#language-type-numeric">Numeric Type</a>,<a href="#language-type-object">Object Type</a>,<a href="#language-type-multi-numeric">Multi Numeric Type</a>が指定できます。それ以外のTypeを指定した場合は,a compile-time error occurs
</p>
<p>
  要素数Expressionは,<a href="#language-type-int">int Type</a> the following <a href="#language-type-numeric">Numeric Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  要素数Expressionに対して,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  要素数Expressionで指定された長さのArrayが生成されます。
</p>
<p>
  Arrayの要素は,すべて<a href="#language-type-initial-value">Type Initial Value</a>で初期化されます。
</p>
<p>
  Arrayにおいて,要素は,メモリ上に連続していることが保証されます。
</p>
<p>
  Create Arrayは,<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Arrayは,<a href="#language-type-object">Object Type</a>です。
</p>
<p>
  <b>Create ArrayのExample</b>
</p>
<pre>
my $nums = new int[3];
my $objects = new Foo[3];
my $objects = new object[3];
my $values = new Complex_2d[3]
</pre>
<p>
  生成されたArrayは,内部的に次の情報を持っています。
</p>
<ul class="list">
  <li>Reference Count</li>
  <li>Basic Type ID</li>
  <li>Type Dimension(1以上の値)</li>
  <li>Array Length</li>
</ul>
<p>
  多次元Arrayは,上記のsyntax を使用して,作成できます。要素は,<a href="#language-type-initial-value">Type Initial Value</a>によって初期化されます。
</p>
<pre>
my $nums = new int[][3];
my $nums = new int[][][3];
</pre>
<p>
  多次元Arrayの次元数の最大は,255です。
</p>

<h4 id="language-expression-array-init">Array Initialization</h4>
<p>
  SPVMには,Create Arrayを簡単にするためのArray Initializationのsyntax があります。Expressionはなくてもかまいません。
</p>
<pre>
[]
[Expression1, Expression2, Expression3]
</pre>
<p>
  Array Initializationは,Expressionの要素数の長さを持ったArrayを返します。
</p>
<p>
  ArrayのTypeは,Expression1のTypeをArray Typeにしたものです。要素が指定されない場合は,<a href="#language-type-any-object">Any Object Type</a>をArray Typeにしたものになります。
</p>
<p>
  Expression2以降が,<a href="#language-type-compatible">Type Compatibility</a>を満たさない場合は,コンパイルエラーになります。
</p>

<h4 id="language-expression-callsub">Subroutine Call</h4>
<p>
  <a href="#language-sub-definition">Subroutine Definition</a>によってDefinitionされたSubroutine は呼び出すことができます。呼び出しには,2種類あって,<b>関数の呼び出し</b>と<b>Method Call </b>があります。
</p>

<h4 id="language-expression-callsub-func">関数の呼び出し</h4>
<p>
  関数の呼び出しとは,<a href="#language-sub-method">Method</a>ではないSubroutine を呼び出す方法のことをいいます。Methodかどうかの判断は,<a href="#language-sub-definition">Subroutine Definition</a>において,第一引数に<a href="#language-type-self">self Type</a>の引数が指定されていた場合が,Methodになります。
</p>
<p>
  関数の呼び出しはthe following 方法で行うことができます。引数は,なくても構いません。最大で255個の引数を指定できます。
</p>
<pre>
Package Name->Subroutine Name(引数1, 引数2, 引数3, ..., 引数n);
</pre>
<p>
  PerlにおいてClassMethod Call と呼ばれているものが,SPVMでは,関数の呼び出しと呼ばれていることに注意してください。
</p>
<p>
  関数の呼び出しでは,Package Nameを省略することもできます。
</p>
<pre>
Subroutine Name(引数1, 引数2, 引数3, ..., 引数n);
</pre>
<p>
  どのPackage Subroutine が呼び出されるかは,the following 順番によって決まります。
</p>
<p>
  Current Package でDefinitionされているSubroutine ,またはCurrent Package にインポートされたSubroutine 
</p>

<p>
  関数の呼び出しは,引数を受け取ります。引数の個数が,Subroutine DefinitionでDefinitionされている引数の個数と一致しない場合は,a compile-time error occursそれぞれの引数のTypeが,Subroutine DefinitionでDefinitionされている引数のTypeと<a href="#language-type-compatible">Type Compatibility</a>がない場合は,a compile-time error occurs
</p>
<p>
  関数の呼び出しは,Return Valueが<a href="#language-type-void">void Type</a>以外の場合は,Return Valueを返します。
</p>
<p>
  関数の呼び出しは,<a href="#language-expression">Expression</a>です。
<p>
<p>
  <b>Subroutine 呼び出しのExample</b>
</p>
<p>
  Subroutine 呼び出しのExampleです。
</p>
<pre>
my $ret = Foo->bar(1, 2, 3);
my $ret = bar(1, 2, 3);
</pre>

<h4 id="language-expression-callsub-method">Method Call </h4>
<p>
  Method Call とは,<a href="#language-sub-method">Method</a>であるSubroutine を呼び出す方法のことをいいます。Methodかどうかの判断は,<a href="#language-sub-definition">Subroutine Definition</a>において,第一引数に<a href="#language-type-self">self Type</a>の引数が指定されていた場合が,Methodになります。
</p>
<p>
  Method Call は,<a href="#language-expression-new">Create Object</a>によって生成されたオブジェクトを使ってthe following syntax で行うことができます。
</p>
<pre>
オブジェクト->Subroutine Name(引数1, 引数2, 引数3, ..., 引数n);
</pre>
<p>
  Method Call は,引数を受け取ります。引数の個数が,Subroutine DefinitionでDefinitionされている引数の個数と一致しない場合は,a compile-time error occursそれぞれの引数のTypeが,Subroutine DefinitionでDefinitionされている引数のTypeと<a href="#language-type-compatible">Type Compatibility</a>がない場合は,a compile-time error occurs
</p>
<p>
  Method Call は,Return Valueが<a href="#language-type-void">void Type</a>以外の場合は,Return Valueを返します。
</p>
<p>
  Method Call は,<a href="#language-expression">Expression</a>です。
<p>
<p>
  <b>Method Call のExample</b>
</p>
<p>
  Method Call のExampleです。
</p>
<pre>
my $point = new Point;
$point->set_x(3);
</pre>
<p>
  <a href="#language-sub-new-callback-object">Create Callback Object</a>で作成されたオブジェクトは,通常のオブジェクトなのでMethodを呼び出すことができます。
</p>
<pre>
オブジェクト->(引数1, 引数2, 引数3, ..., 引数n);
</pre>

<p>
  <b>Create Callback Objectで生成されたオブジェクトからMethodを呼び出すExample</b>
</p>
<p>
  Create Callback Objectで生成されたオブジェクトからMethodを呼び出すExampleです。
</p>
<pre>
my $cb_obj = sub : int ($self: self, $num1 : int, $num2 : int) {
  return $num1 + $num2;
};

my $ret = $cb_obj->(1, 2);
</pre>

<h4 id="language-expression-operator-deref-get">Dereference による値の取得</h4>
<p>
  Dereference による値の取得とは,Referenceから実際の値を取得するための操作のことです。C言語の関節Operator "*"を実現するために設計されました。
</p>
<pre>
$変数
</pre>
<p>
  変数のTypeは,Reference Type でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Dereference による値の取得は,<a href="#language-expression">Expression</a>を返します。
</p>
<pre>
  <b>Dereference による値の取得のExample</b>
</pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
my $num_deref : int = $$num_ref;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
my $z_deref : SPVM::Complex_2d = $$z_ref;
</pre>

<h4 id="language-expression-operator-deref-set">Dereference による値の設定</h4>
<p>
  Dereference による値の設定とは,Referenceから実際の値を設定するための操作のことです。C言語の関節Operator "*"を実現するために設計されました。
</p>
<pre>
$変数 = Expression
</pre>
<p>
  変数のTypeは,Reference Type でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  ExpressionのTypeは,Dereference された場合の変数のTypeに一致していなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Dereference による値の設定は,設定された値を返します。これは<a href="#language-expression">Expression</a>です。
</p>
<pre>
  <b>Dereference による値の設定のExample</b>
</pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
$$num_ref = 1;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;

my $z2 : SPVM::Complex_2d;

$$z_ref = $z2;
</pre>

<h4 id="language-expression-current-package">Get Current Package Name</h4>

<b>Get Current Package Name</b> is a Expression to get the current package name by __PACKAGE__ <a href="#language-lex-keyword">Keyword</a>.

<pre>
__PACKAGE__
</pre>

<p>
  <b>Get Current Package Name Example:</b>
</p>
<pre>
package Foo::Bar {
  sub baz : void () {
    # Foo::Bar
    my $package_name == __PACKAGE__;
  }
}
</pre>

<h4 id="language-expression-current-package">Get Current File Name</h4>

<b>Get Current File Name</b> is a Expression to get the current file name by __LINE__ <a href="#language-lex-keyword">Keyword</a>.

<pre>
__FILE__
</pre>

Current File Name means the relative path from the base path of the module file. For example, if the Module Loaded Path is "/mypath" and the Module name is "Foo::Bar", the absolute path is "/mypath/Foo/Bar.spvm" and the relative path is "Foo/Bar.spvm". "Foo/Bar.spvm" is Current File Name.

<b>Get Current File Name Example:</b>

<pre>
# Foo/Bar.spvm
package Foo::Bar {
  sub baz : void () {
    # Foo/Bar.spvm
    my $file_name == __FILE__;
  }
}
package Foo::Bar2 {
  sub baz : void () {
    # Foo/Bar.spvm
    my $file_name == __FILE__;
  }
}
</pre>

<h4 id="language-expression-current-package">Get Current Line Number</h4>

<b>Get Current Line Number</b> is a Expression to get the current line number of the current file by __LINE__ <a href="#language-lex-keyword">Keyword</a>.

<pre>
__LINE__
</pre>

<p>
  <b>Get Current Line Number Example:</b>
</p>
<pre>
package Foo::Bar {
  sub baz : void () {
    # 4
    my $line = __LINE__;
  }
}
</pre>

<h3 id="language-operator">Operator</h3>
<ul class="list">
  <li><a href="#language-expression-operator-summary">Operator Summary</a></li>
  <li><a href="#language-expression-operator-unary">Unary Operator</a></li>
  <li><a href="#language-expression-operator-binary">Binary Operator</a></li>
  <li><a href="#language-expression-operator-sequential">Sequential Operator</a></li>
  <li><a href="#language-expression-operator-arithmetic">Arithmetic Operator</a></li>
  <li><a href="#language-expression-operator-unary-plus">Unary Plus Operator</a></li>
  <li><a href="#language-expression-operator-unary-minus">Unary Minus Operator</a></li>
  <li><a href="#language-expression-operator-add">Addition Operator</a></li>
  <li><a href="#language-expression-operator-subtract">Subtraction Operator</a></li>
  <li><a href="#language-expression-operator-multiply">Multiplication Operator</a></li>
  <li><a href="#language-expression-operator-divide">Division Operator</a></li>
  <li><a href="#language-expression-operator-remainder">Remainder Operator</a></li>
  <li><a href="#language-expression-operator-inc">Increment Operator</a></li>
  <li><a href="#language-expression-operator-dec">Decrement Operator</a></li>
  <li><a href="#language-expression-operator-bit">Bit Operator</a></li>
  <li><a href="#language-expression-operator-bit-and">Bit AND Operator</a></li>
  <li><a href="#language-expression-operator-bit-or">Bit OR Operator</a></li>
  <li><a href="#language-expression-operator-bit-not">Bit NOT Operator</a></li>
  <li><a href="#language-expression-operator-shift">Shift Operator</a></li>
  <li><a href="#language-expression-operator-left-shift">Left Shift Operator</a></li>
  <li><a href="#language-expression-operator-arithmetic-right-shift">Arithmetic Right Shift Operator</a></li>
  <li><a href="#language-expression-operator-logical-right-shift">Logical Right Shift Operator</a></li>
  <li><a href="#language-expression-operator-comparison">Comparison Operator</a></li>
  <li><a href="#language-expression-operator-comparison-numeric">Numeric Comparison Operator</a></li>
  <li><a href="#language-expression-operator-comparison-string">String Comparison Operator</a></li>
  <li><a href="#language-expression-operator-isa">isa Operator</a></li>
  <li><a href="#language-expression-operator-logical">Logical Operator</a></li>
  <li><a href="#language-expression-operator-logical-and">Logical AND Operator</a></li>
  <li><a href="#language-expression-operator-logical-or">Logical OR Operator</a></li>
  <li><a href="#language-expression-operator-logical-not">Logical NOT Operator</a></li>
  <li><a href="#language-expression-operator-concat">String Concatenation Operator</a></li>
  <li><a href="#language-expression-operator-assign">Assignment Operator</a></li>
  <li><a href="#language-expression-operator-assign-special">Special Assignment Operator</a></li>
  <li><a href="#language-expression-operator-ref">Reference Operator</a></li>
  <li><a href="#language-expression-operator-array-length">Array Length Operator</a></li>
  <li><a href="#language-expression-operator-string-length">String Length Operator</a></li>
  <li><a href="#language-expression-operator-scalar">Scalar Operator</a></li>
  <li><a href="#language-expression-operator-isweak">isweak Operator</a></li>
</ul>

<h4 id="language-expression-operator-summary">Operator Summary </h4>
<p>
  Operator は,<a href="#language-expression-operator-unary">Unary Operator</a>,<a href="#language-expression-operator-binary">Binary Operator</a>,<a href="#language-expression-operator-inc">Increment Operator</a>,<a href="#language-expression-operator-dec">Decrement Operator</a>,<a href="#language-expression-operator-comparison">Comparison Operator</a>,<a href="#language-expression-operator-logical">Logical Operator</a>,<a href="#language-expression-operator-assign">Assignment Operator</a>からなります。
</p>

<h4 id="language-expression-operator-unary">Unary Operator  </h4>
<p>
  Unary Operator  とは,<a href="#language-expresssion">Expression</a>の前に置かれるOperator のことをいいます。
</p>
<pre>
UNARY_OPERATOR Expression
</pre>
<p>
  Unary Operator  には,<a href="#language-expression-operator-unary-plus">Unary Plus Operator</a>,<a href="#language-expression-operator-unary-minus">Unary Minus Operator</a>,<a href="#language-expression-operator-bit-not">Bit NOT Operator</a>,<a href="#language-expression-operator-logical-not">Logical NOT Operator</a>,<a href="#language-expression-operator-array-legnth">Array Length Operator</a>,<a href="#language-expression-operator-string-legnth">String Length Operator</a>があります。
</p>
<p>
  Increment Operator とDecrement Operator は,Unary Operator  には含まれません。
</p>

<h4 id="language-expression-operator-binary">Binary Operator  </h4>
<p>
  Binary Operator  とは,Left ExpressionとRight Expressionの間に置かれるOperator のことをいいます。項については,<a href="#language-expresssion">Expression</a>を参考にしてください。
</p>
<pre>
Left Expression Binary Operator   Right Expression
</pre>

<p>
  Binary Operator  には,<a href="#language-expression-operator-add">Addition Operator</a>,<a href="#language-expression-operator-subtract">Subtraction Operator</a>,<a href="#language-expression-operator-multiply">Multiplication Operator</a>,<a href="#language-expression-operator-divide">Division Operator</a>,<a href="#language-expression-operator-remainder">Remainder Operator</a>,<a href="#language-expression-operator-bit-and">Bit AND Operator</a>,<a href="#language-expression-operator-bit-or">Bit OR Operator</a>,<a href="#language-expression-operator-logical-and">Logical AND Operator</a>,<a href="#language-expression-operator-logical-or">Logical OR Operator</a>,<a href="#language-expression-operator-shift">Shift Operator</a>,<a href="#language-expression-operator-concat">String Concatenation Operator</a>があります。
</p>

<h4 id="language-expression-operator-sequential">Sequential Operator </h4>
<p>
  Sequential Operator とは,複数の<a href="#language-expression">Expression</a>を並べて記述でき,最後の値を返すOperator のことです。
</p>
<pre>
(Expression1, Expression2, Expression3)
</pre>
<p>
  Expressionは左から実行されます。最後の値が返されます。
<p>
<p>
  Sequential Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  <b>Sequential Operator のExample</b>
</p>
<p>
  Sequential Operator のExampleです。
</p>
<pre>
# $fooには3が代入される。
my $foo = (1, 2, 3);

# $xは3,$retは5になる
my $x = 1;
my $y = 2;
my $ret = ($x += 2, $x + $y);
</pre>

<li><a href="#language-expression-operator-sequential">Sequential Operator</a></li>

<h4 id="language-expression-operator-arithmetic">Arithmetic Operator </h4>
<p>
  Arithmetic Operator は,算術を行うOperator のことで,<a href="#language-expression-operator-add">Addition Operator</a>,<a href="#language-expression-operator-subtract">Subtraction Operator</a>,<a href="#language-expression-operator-multiply">Multiplication Operator</a>,<a href="#language-expression-operator-divide">Division Operator</a>,<a href="#language-expression-operator-remainder">Remainder Operator</a>,<a href="#language-expression-operator-unary-plus">Unary Plus Operator</a>,<a href="#language-expression-operator-unary-minus">Unary Minus Operator</a>,<a href="#language-expression-operator-inc">Increment Operator</a>,<a href="#language-expression-operator-dec">Decrement Operator</a>からなります。
</p>

<h4 id="language-expression-operator-unary-plus">Unary Plus Operator </h4>
<p>
  Unary Plus Operator は"+"で表現される<a href="#language-expression-operator-unary">Unary Operator</a>です。
</p>
<pre>
+Expression
</pre>
<p>
  Expressionは<a href="#language-type-numeric">Numeric Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  <a href="#language-expression">Expression</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Unary Plus Operator は,与えられた値をコピーして返します。
</p>
<p>
  Unary Plus Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Unary Plus Operator のReturn ValueのTypeは,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Unary Plus Operator は例外を発生させません。
</p>
<p>
  <b>Unary Plus Operator のExample</b>
</p>
<pre>
my $num = +10;
</pre>
<h4 id="language-expression-operator-unary-minus">Unary Minus Operator </h4>
<p>
  Unary Minus Operator は"-"で表現される<a href="#language-expression-operator-unary">Unary Operator</a>です。
</p>
<pre>
-Expression
</pre>
<p>
  Expressionは<a href="#language-type-numeric">Numeric Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  <a href="#language-expression">Expression</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Unary Minus Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>,<a href="#language-type-float">float Type</a>,<a href="#language-type-double">double Type</a>における演算がDefinitionされます。
</p>
<pre>
-x
</pre>
<p>
  Unary Minus Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Unary Minus Operator のReturn ValueのTypeは,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Unary Minus Operator は例外を発生させません。
</p>
<p>
  <b>Unary Minus Operator のExample</b>
</p>
<pre>
my $num = -10;
</pre>
<h4 id="language-expression-operator-add">Addition Operator </h4>
<p>
  Addition Operator は"+"で表現される,加算を行うための<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression + Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-numeric">Numeric Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Addition Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>,<a href="#language-type-float">float Type</a>,<a href="#language-type-double">double Type</a>における演算がDefinitionされます。
</p>
<pre>
x + y;
</pre>
<p>
  Addition Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Addition Operator のReturn ValueのTypeは,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Addition Operator は,例外を発生させません。
</p>
<h4 id="language-expression-operator-subtract">Subtraction Operator </h4>
<p>
  Subtraction Operator は"-"で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression - Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-numeric">Numeric Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Subtraction Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>,<a href="#language-type-float">float Type</a>,<a href="#language-type-double">double Type</a>における演算がDefinitionされます。
</p>
<pre>
x - y;
</pre>
<p>
  Subtraction Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Subtraction Operator のReturn ValueのTypeは,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Subtraction Operator は,例外を発生させません。
</p>
<h4 id="language-expression-operator-multiply">Multiplication Operator </h4>
<p>
  Multiplication Operator は"*"で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression * Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-numeric">Numeric Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Multiplication Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>,<a href="#language-type-float">float Type</a>,<a href="#language-type-double">double Type</a>における演算がDefinitionされます。
</p>
<pre>
x * y;
</pre>
<p>
  Multiplication Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Multiplication Operator のReturn ValueのTypeは,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Multiplication Operator は,例外を発生させません。
</p>
<h4 id="language-expression-operator-divide">Division Operator </h4>
<p>
  Division Operator は"/"で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression / Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-numeric">Numeric Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Division Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>,<a href="#language-type-float">float Type</a>,<a href="#language-type-double">double Type</a>における演算がDefinitionされます。
</p>
<pre>
x / y;
</pre>
<p>
  Division Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Division Operator のReturn ValueのTypeは,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Integral Typeに対する演算の場合には,Division Operator は,右辺が0であった場合に,例外が発生します。
</p>
<p>
  Floating Point Typeに対する演算の場合には,Division Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-remainder">Remainder Operator </h4>
<p>
  Remainder Operator は"%"で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression % Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-integral">Integral Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Remainder Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>における演算がDefinitionされます。
</p>
<pre>
x % y;
</pre>
<p>
  Remainder Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Remainder Operator のReturn ValueのTypeは,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Remainder Operator は,右辺が0であった場合に,例外が発生します。
</p>

<h4 id="language-expression-operator-inc">Increment Operator </h4>
<p>
  Increment Operator は,値を1加算するOperator です。Increment Operator が前置されるか,後置されるかで,意味が変わります。
</p>
<pre>
# 前置のインクリメント
++Lexical Variable 
++Package Variable 
++Field Access
++Array Access
++Dereference 

# 後置のインクリメント
Lexical Variable ++
Package Variable ++
Field Access++
Array Access++
Dereference ++
</pre>
<p>
  Increment Operator の対象は,<a href="#language-lex-var">Lexical Variable</a>,<a href="#language-package-var">Package Variable</a>,<a href="#language-field-access">Field Access</a>,<a href="#language-array-access">Array Access</a>,<a href="#language-deref">Dereference</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Increment Operator の対象のTypeは,<a href="#language-type-numeric">Numeric Type</a>でなければなりません。otherwise コンパイルエラーが発生します。
</p>
<p>
  <b>前置のIncrement Operator </b>
</p>
<p>
  前置のIncrement Operator は,インクリメントを行った後に,インクリメントされた値を返します。
</p>
<p>
  前置のIncrement Operator は,次のExpressionと等価です。対象に1が加算された後に,元のTypeでType Castが行われ,対象に代入されます。
</p>
<pre>
(対象 = (Type Cast)(対象 + 1))
</pre>
<p>
  たとえば,<a href="#language-type-byte">byte Type</a>の値の前置のインクリメントは,次のExpressionと等価です。
</p>

<pre>
($num = (byte)($num + 1))
</pre>
<p>
  <b>後置のIncrement Operator </b>
</p>
<p>
  後置のIncrement Operator は,インクリメントを行った後に,インクリメントする前の値を返します。
</p>
<p>
  後置のIncrement Operator は,Sequential Operator を使った,次のExpressionと等価です。対象が一時変数に保存され,対象に1が足された後に,元のTypeでType Castが行われ,対象に代入されます。その後,一時変数が返されます。
</p>
<pre>
(my 一時変数 = 対象, 対象 = (Type Cast)(対象 + 1), 一時変数)
</pre>
<p>
  たとえば,<a href="#language-type-byte">byte Type</a>の値の後置のインクリメントは,次のExpressionと等価です。
</p>

<pre>
(my $tmp = $num, $num = (byte)($num + 1), $tmp)
</pre>

<h4 id="language-expression-operator-dec">Decrement Operator </h4>
<p>
  Decrement Operator は,値を1減算するOperator です。Decrement Operator が前置されるか,後置されるかで,意味が変わります。
</p>
<pre>
# 前置のデクリメント
--Lexical Variable 
--Package Variable 
--Field Access
--Array Access
--Dereference 

# 後置のデクリメント
Lexical Variable --
Package Variable --
Field Access--
Array Access--
Dereference --
</pre>
<p>
  Decrement Operator の対象は,<a href="#language-lex-var">Lexical Variable</a>,<a href="#language-package-var">Package Variable</a>,<a href="#language-field-access">Field Access</a>,<a href="#language-array-access">Array Access</a>,<a href="#language-deref">Dereference</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Decrement Operator の対象のTypeは,<a href="#language-type-numeric">Numeric Type</a>でなければなりません。otherwise コンパイルエラーが発生します。
</p>
<p>
  <b>Pre Decrement Operator </b>
</p>
<p>
  Pre Decrement Operator は,デクリメントを行った後に,デクリメントされた値を返します。
</p>
<p>
  Pre Decrement Operator は,次のExpressionと等価です。対象に1が減算された後に,元のTypeでType Castが行われ,対象に代入されます。
</p>
<pre>
(対象 = (Type Cast)(対象 - 1))
</pre>
<p>
  たとえば,<a href="#language-type-byte">byte Type</a>の値の前置のデクリメントは,次のExpressionと等価です。
</p>

<pre>
($num = (byte)($num - 1))
</pre>
<p>
  <b>Post Decrement Operator </b>
</p>
<p>
  Post Decrement Operator は,デクリメントを行った後に,デクリメントする前の値を返します。
</p>
<p>
  Post Decrement Operator は,Sequential Operator を使った,次のExpressionと等価です。対象が一時変数に保存され,対象に1が足された後に,元のTypeでType Castが行われ,対象に代入されます。その後,一時変数が返されます。
</p>
<pre>
(my 一時変数 = 対象, 対象 = (Type Cast)(対象 - 1), 一時変数)
</pre>
<p>
  たとえば,<a href="#language-type-byte">byte Type</a>の値の後置のデクリメントは,次のExpressionと等価です。
</p>

<pre>
(my $tmp = $num, $num = (byte)($num - 1), $tmp)
</pre>

<h4 id="language-expression-operator-bit">Bit Operator </h4>
<p>
  Bit Operator は,Bit 演算を行うOperator のことで,><a href="#language-expression-operator-bit-and">Bit AND Operator</a>,<a href="#language-expression-operator-bit-or">Bit OR Operator</a>,<a href="#language-expression-operator-bit-not">Bit NOT Operator</a>からなります。
</p>

<h4 id="language-expression-operator-bit-and">Bit AND Operator </h4>
<p>
  Bit ANDは"&"で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression & Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-integral">Integral Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Bit AND Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>における演算がDefinitionされます。
</p>
<pre>
x & y;
</pre>
<p>
  Bit AND Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Bit AND Operator のReturn ValueのTypeは,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Bit AND Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-bit-or">Bit OR Operator </h4>
<p>
  Bit ORは"|"で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression | Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-integral">Integral Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Bit OR Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>における演算がDefinitionされます。
</p>
<pre>
x | y;
</pre>
<p>
  Bit OR Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Bit OR Operator のReturn ValueのTypeは,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Bit OR Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-bit-not">Bit NOT Operator </h4>
<p>
  Bit NOT Operator は"~"で表現される<a href="#language-expression-operator-unary">Unary Operator</a>です。
</p>
<pre>
~Expression
</pre>
<p>
  Expressionは<a href="#language-type-integral">Integral Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  <a href="#language-expression">Expression</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Bit NOT Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>における演算がDefinitionされます。
</p>
<pre>
~x
</pre>
<p>
  Bit NOT Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Bit NOT Operator のReturn ValueのTypeは,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>されたTypeです。
</p>
<p>
  Bit NOT Operator は例外を発生させません。
</p>
<p>
  <b>Bit NOT Operator のExample</b>
</p>
<pre>
my $num = ~0xFF0A;
</pre>

<h4 id="language-expression-operator-shift">Shift Operator </h4>
<p>
  Shift Operator は,Bit シフトを行うOperator で,<a href="#language-expression-operator-left-shift">Left Shift Operator</a>,<a href="#language-expression-operator-arithmetic-right-shift">Arithmetic Right Shift Operator</a>,<a href="#language-expression-operator-logical-right-shift">Logical Right Shift Operator</a>からなります。
</p>
<h4 id="language-expression-operator-left-shift">Left Shift Operator </h4>
<p>
  左シフトは"<<"で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression << Right Expression
</pre>
<p>
  Left Expressionは,<a href="#language-type-integral">Integral Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  最初に<a href="#language-expression">Left Expression</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  Right Expressionは,<a href="#language-type-int">int Type</a> でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left Shift Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>における演算がDefinitionされます。
</p>
<pre>
x << y;
</pre>
<p>
  Left Shift Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Left Shift Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-arithmetic-right-shift">Arithmetic Right Shift Operator </h4>
<p>
  算術右シフトは">>"で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression >> Right Expression
</pre>
<p>
  Left Expressionは,<a href="#language-type-integral">Integral Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  最初に<a href="#language-expression">Left Expression</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  Right Expressionは,<a href="#language-type-int">int Type</a> でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Arithmetic Right Shift Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。xに対して,<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>における演算がDefinitionされます。
</p>
<pre>
x >> y;
</pre>
<p>
  Arithmetic Right Shift Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Arithmetic Right Shift Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-logical-right-shift">Logical Right Shift Operator </h4>
<p>
  論理右シフトは">>>"で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression >>> Right Expression
</pre>
<p>
  Left Expressionは,<a href="#language-type-integral">Integral Type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  最初に<a href="#language-expression">Left Expression</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  Right Expressionは,<a href="#language-type-int">int Type</a> でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Logical Right Shift Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。xに対して,<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>における演算がDefinitionされます。
</p>
<pre>
(符号付Integral Type Cast)((符号なしIntegral Type Cast)x >> y);
</pre>
<p>
  Logical Right Shift Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Logical Right Shift Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-comparison">Comparison Operator </h4>
<p>
  Comparison Operator とは,Left ExpressionとRight Expressionの間に置かれるOperator で,<a href="#language-expression">Expression</a>を返すOperator のことをいいます。
</p>
<pre>
Left Expression Comparison Operator  Right Expression
</pre>
<p>
  Comparison Operator には,<a href="#language-expression-operator-comparison-numeric">Numeric Comparison Operator</a>,<a href="#language-expression-operator-comparison-string">String Comparison Operator</a>,isa Operator があります。
</p>

<h4 id="language-expression-operator-comparison-numeric">Numeric Comparison Operator </h4>
<p>
  Numeric Comparison Operator とは,数値あるいはオブジェクトのアドレスを比較するために,Left ExpressionとRight Expressionの間に置かれるOperator で,<a href="#language-expression">Expression</a>を返すOperator のことをいいます。
</p>
<pre>
Left Expression Numeric Comparison Operator  Right Expression
</pre>
<p>
  Numeric Comparison Operator の一覧です。
</p>
<table>
  <tr>
    <th>Operator </th>
    <th>比較可能なType</th>
    <th>解説</th>
  </tr>
  <tr>
    <td>
      Left Expression == Right Expression
    </td>
    <td>
      Left ExpressionとRight ExpressionがNumeric Type,Left ExpressionとRight ExpressionがObject Type (Undefined Valueを含む)
    </td>
    <td>
      Left ExpressionとRight Expressionが等しい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression != Right Expression
    </td>
    <td>
      Left ExpressionとRight ExpressionがNumeric Type,Left ExpressionとRight ExpressionがObject Type (Undefined Valueを含む)
    </td>
    <td>
      Left ExpressionとRight Expressionが等しくない
    </td>
  </tr>
  <tr>
    <td>
      Left Expression > Right Expression
    </td>
    <td>
      Left ExpressionとRight ExpressionがNumeric Type
    </td>
    <td>
      Left ExpressionはRight Expressionより大きい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression >= Right Expression
    </td>
    <td>
      Left ExpressionとRight ExpressionがNumeric Type
    </td>
    <td>
      Left ExpressionはRight Expressionより大きいまたは等しい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression < Right Expression
    </td>
    <td>
      Left ExpressionとRight ExpressionがNumeric Type
    </td>
    <td>
      Left ExpressionはRight Expressionより小さい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression <= Right Expression
    </td>
    <td>
      Left ExpressionとRight ExpressionがNumeric Type
    </td>
    <td>
      Left ExpressionはRight Expressionより小さいまたは等しい
    </td>
  </tr>
</table>
<p>
  左辺と右辺のTypeは,比較可能なTypeでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Numeric Typeの比較の場合は,Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  その後,Numeric Comparison Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99とのTypeの対応</a>に応じた,<a href="#language-type-int">int Type</a> ,<a href="#language-type-long">long Type</a>,<a href="#language-type-float">float Type</a>,<a href="#language-type-double">double Type</a>,Object Type における演算がDefinitionされます。
</p>
<pre>
# Numeric Typeの比較,Object Type の比較
(int32_t)(x == y);
(int32_t)(x != y);

# Numeric Typeの比較
(int32_t)(x > y);
(int32_t)(x >= y);
(int32_t)(x < y);
(int32_t)(x <= y);
</pre>
<p>
  Numeric Comparison Operator のReturn ValueのTypeは,<a href="#language-type-int">int Type</a> です。
</p>
<p>
  Numeric Comparison Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-comparison-string">String Comparison Operator </h4>
<p>
  String Comparison Operator とは,Stringを比較するために,Left ExpressionとRight Expressionの間に置かれるOperator で,<a href="#language-expression">Expression</a>を返すOperator のことをいいます。
</p>
<pre>
Left Expression String Comparison Operator  Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-string-compatible">String Compatible Type</a>でなければなりません。
</p>
<p>
  String Comparison Operator の一覧です。
</p>
<table>
  <tr>
    <th>Operator </th>
    <th>解説</th>
  </tr>
  <tr>
    <td>
      Left Expression eq Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionが等しい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression ne Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionが等しくない
    </td>
  </tr>
  <tr>
    <td>
      Left Expression gt Right Expression
    </td>
    <td>
      Left ExpressionはRight Expressionより辞書Expression順序で比較して大きい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression ge Right Expression
    </td>
    <td>
      Left ExpressionはRight Expressionより辞書Expression順序で比較して大きいまたは等しい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression lt Right Expression
    </td>
    <td>
      Left ExpressionはRight Expressionより辞書Expression順序で比較して小さい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression le Right Expression
    </td>
    <td>
      Left ExpressionはRight Expressionより辞書Expression順序で比較して小さいまたは等しい
    </td>
  </tr>
</table>
<p>
  String Comparison Operator のReturn ValueのTypeは,<a href="#language-type-int">int Type</a> です。条件が満たされた場合は1を,そうでない場合は0を返します。
</p>
<h4 id="language-expression-operator-isa">isa Operator </h4>
<p>
  Numeric Comparison Operator とは,数値あるいはオブジェクトのアドレスを比較するために,Left ExpressionとRight Expressionの間に置かれるOperator で,<a href="#language-expression">Expression</a>を返すOperator のことをいいます。
</p>
<p>
  isa Operator とはは,Typeの適合性をチェックするためのOperator で,<a href="#language-expression">Expression</a>を返します。
</p>
<pre>
Left Expression isa 右Type
</pre>
<p>
  isa Operator は,右Typeに応じて,3種類の動作をします。
</p>
<p>
  1. 右Typeが,<a href="#language-type-numeric">Numeric Type</a>,<a href="#language-type-multi-numeric">Multi Numeric Type</a>,<a href="#language-type-any-object">Any Object Type</a>,<a href="#language-type-ref">Reference Type</a>の場合は,コンパイル時にLeft ExpressionのTypeが右Typeと同一のものであるかをチェックします。同一であった場合は<a href="#language-type-int">int Type</a> で1を,そうでない場合は0を返します。
</p>
<p>
  2. 右Typeが,<a href="#language-type-class">Class Type</a>であった場合は,実行時にLeft ExpressionのTypeが,Class Typeと一致するかをチェックします。一致した場合は<a href="#language-type-int">int Type</a> で1を,そうでない場合は0を返します。Left ExpressionのTypeは,Object Type でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  3. 右Typeが,<a href="#language-type-callback">Callback Type</a>であった場合は,実行時にLeft ExpressionのTypeがClass Typeであり,そのClassがCallback Typeを満たすかどうかをチェックします。満たした場合は<a href="#language-type-int">int Type</a> の1を,そうでない場合は0を返します。Left ExpressionのTypeは,Object Type でなければなりません。otherwise a compile-time error occurs.
</p>

<h4 id="language-expression-operator-logical">Logical Operator </h4>
<p>
  Logical Operator は,論理演算を行うOperator のことで,><a href="#language-expression-operator-logical-and">Logical AND Operator</a>,<a href="#language-expression-operator-logical-or">Logical OR Operator</a>,<a href="#language-expression-operator-logical-not">Logical NOT Operator</a>からなります。
</p>
<p>
  Logical Operator は,<a href="#language-expression">Expression</a>を返します。
</p>

<h4 id="language-expression-operator-logical-and">Logical AND Operator </h4>
<p>
  Logical AND Operator とは,Logical AND演算を行うために,"&&"で表現される,<a href="#language-expresssion">Expression</a>をオペランドとする<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression && Right Expression
</pre>
<p>
  Logical AND Operator のReturn ValueのTypeは,<a href="#language-type-int">int Type</a> です。
</p>
<p>
  Logical AND Operator は次のように動作します。
</p>
<p>
  1. Left Expressionに<a href="#language-type-convertion-bool">Bool Type Convertion</a>を実行します。
</p>
<p>
  2. Left Expressionの値が0以外であれば,Right Expressionに対して,<a href="#language-type-convertion-bool">Bool Type Convertion</a>を実行し,その値を返します。
</p>
<p>
  3. Left Expressionの値が0であれば,その値を返します。
</p>
<p>
  Logical AND Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Logical AND Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-logical-and">Logical OR Operator </h4>
<p>
  Logical OR Operator とは,Logical OR演算を行うために,"||"で表現される,<a href="#language-expresssion">Expression</a>をオペランドとする<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression || Right Expression
</pre>
<p>
  Logical OR Operator は次のように動作します。
</p>
<p>
  Logical OR Operator のReturn ValueのTypeは,<a href="#language-type-int">int Type</a> です。
</p>
<p>
  1. Left Expressionに<a href="#language-type-convertion-bool">Bool Type Convertion</a>を実行します。
</p>
<p>
  2. Left Expressionの値が0あれば,Right Expressionに対して,<a href="#language-type-convertion-bool">Bool Type Convertion</a>を実行し,その値を返します。
</p>
<p>
  3. Left Expressionの値が0以外であれば,その値を返します。
</p>
<p>
  Logical OR Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Logical OR Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-logical-and">Logical NOT Operator </h4>
<p>
  Logical NOT Operator とは,論理NOT演算を行うために,Expressionの左に置かれるOperator で,"!"で表現される<a href="#language-expression">Expression</a>を返す<a href="#language-expression-operator-binary">Unary Operator</a>です。Expressionについては,<a href="#language-expresssion">Expression</a>を参考にしてください。
</p>
<pre>
!Expression
</pre>
<p>
  Logical NOT Operator のReturn ValueのTypeは,<a href="#language-type-int">int Type</a> です。
</p>
<p>
  Logical NOT Operator は,Expressionに<a href="#language-type-convertion-bool">Bool Type Convertion</a>を実行し,その値が0の場合は1を,0以外の値の場合は,0を返します。
</p>
<p>
  Logical NOT Operator は<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  Logical NOT Operator は,例外を発生させません。
</p>

<h4 id="language-expression-operator-concat">String Concatenation Operator </h4>
<p>
  String Concatenation Operator は"."で表現される<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression . Right Expression
</pre>
<p>
  Left ExpressionあるいはRight Expressionが,<a href="#language-type-numeric">Numeric Type</a>であった場合は,<a href="#language-type-convertion-numeric-to-string">Numeric-to-<a href="#language-type-string">string Type</a> Convertion</a>によってStringに変換されます。
</p>
<p>
  Left ExpressionとRight Expressionはどちらも<a href="#language-type-string-compatible">String Compatible Type</a>でなければなりません。otherwise コンパイルエラーになります。
</p>
<p>
  String Concatenation Operator は,Left ExpressionとRight Expressionで表現される<a href="#language-string">String</a>を連結し,新しいStringを返します。
</p>
<p>
  String Concatenation Operator は<a href="#language-expression">Expression</a>を返し,Typeは<a href="#language-type-string">string Type</a>です。
</p>
<p>
  Left ExpressionとRight Expressionの両方が,<a href="#language-literal-string">String Literal</a>であった場合は,コンパイル時に連結されたString Literal が生成されます。パフォーマンスのコストを意識せずに,String Concatenation Operator で,String Literal を連結できます。
</p>
<p>
  実行時に,Left ExpressionあるいはRight Expressionが<a href="#language-undef">Undefined Value</a>だった場合は,例外が発生します。
</p>
<p>
  <b>String Concatenation Operator のExample</b>
</p>
<pre>
my $str = "abc" . "def";
my $str = "def" . 34;
my $str = 123 . 456;
</pre>
<h4 id="language-expression-operator-assign">Assignment Operator </h4>
<p>
  Assignment Operator は"="で表現される,代入を行うための<a href="#language-expression-operator-binary">Binary Operator</a>です。
</p>
<pre>
LEFT_EXPRESSION = RIGHTH_EXPRESSION
</pre>
<p>
  Assignment Operator は,右辺と左辺によって,複数の意味を持ちます。各項目を参考にしてください。
</p>
<p>
  Assignment Operator においては,Right Expressionが評価された後に,Left Expressionが評価されます。これは,原則として,Expressionは左から右へ実行されるということの例外です。
</p>

<ul>
  <li><a href="#language-expression-set-lex-var">Set Lexical Variable Value</a></li>
</ul>

<h4 id="language-expression-operator-assign-special">Special Assignment Operator </h4>
<p>
  Special Assignment Operator とは,<a href="#language-expression-operator-binary">Binary Operator</a>と<a href="#language-expression-operator-assign">Assignment Operator</a>の組み合わせで表現される特殊な代入を行う<a href="#language-expression-operator-binary">Binary Operator</a>のことです。
</p>
<pre>
Left Expression Special Assignment Operator  Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionが<a href="#language-type-compatible">Type Compatibility</a>を満たさない場合は,a compile-time error occurs
</p>
<p>
  <b>Special Assignment Operator の一覧</b>
</p>
<p>
  Special Assignment Operator の一覧です。
</p>
<table>
  <tr>
    <td>加算Assignment Operator </td>
    <td>+=</td>
  </tr>
  <tr>
    <td>減算Assignment Operator </td>
    <td>-=</td>
  </tr>
  <tr>
    <td>乗算Assignment Operator </td>
    <td>*=</td>
  </tr>
  <tr>
    <td>除算Assignment Operator </td>
    <td>/=</td>
  </tr>
  <tr>
    <td>剰余Assignment Operator </td>
    <td>%=</td>
  </tr>
  <tr>
    <td>Bit ANDAssignment Operator </td>
    <td>&=</td>
  </tr>
  <tr>
    <td>Bit ORAssignment Operator </td>
    <td>|=</td>
  </tr>
  <tr>
    <td>左シフトAssignment Operator </td>
    <td><<=</td>
  </tr>
  <tr>
    <td>算術右シフトAssignment Operator </td>
    <td>>>=</td>
  </tr>
  <tr>
    <td>論理右シフトAssignment Operator </td>
    <td>>>>=</td>
  </tr>
</table>
<p>
  Special Assignment Operator は,次のように展開されます。
</p>
<pre>
# 展開前
Left Expression Special Assignment Operator  Right Expression

# 展開後
Left Expression Assignment Operator  (Left ExpressionのTypeによるキャスト)(Left Expression 指定されたOperator  Right Expression)
</pre>
<p>
  たとえば,加算Assignment Operator の場合は,次のように展開されます。
</p>
<pre>
# 展開前 xは<a href="#language-type-byte">byte Type</a>
$x += 1;

# 展開後
$x = (byte)($x + 1)
</pre>
<p>
  <b>Special Assignment Operator のExample</b>
</p>
<p>
  Special Assignment Operator のExampleです。
</p>
<pre>
$x += 1;
$x -= 1;
$x *= 1;
$x /= 1;
$x &= 1;
$x |= 1;
$x ^= 1;
$x %= 1;
$x <<= 1;
$x >>= 1;
$x >>>= 1;
</pre>
<h4 id="language-expression-operator-ref">Reference Operator  </h4>
<p>
  Reference Operator  は,<a href="#language-type-numeric">Numeric Type</a>または<a href="#language-type-multi-numeric">Multi Numeric Type</a>の変数のアドレスを取得するOperator です。C言語のアドレスOperator "&"を実現するために設計されました。
</p>
<pre>
\変数
</pre>
<p>
  変数がNumeric TypeまたはMulti Numeric Typeでなかった場合は,a compile-time error occurs
</p>
<p>
  Reference Operator  はExpressionを返します。返されるTypeは,<a href="#language-type-ref">Reference Type</a>です。
</p>
<pre>
  <b>Reference Operator  のExample</b>
</pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
</pre>
<p>
  Referenceの詳しい解説については,<a href="#language-ref">Reference</a>を見てください。
</p>

<h4 id="language-expression-operator-array-length">Array Length Operator </h4>
<p>
  Array Length Operator は,<a href="#language-array">Array</a>の長さを取得するための"@"で表現される<a href="#language-expression-operator-binary">Unary Operator</a>です。
</p>
<pre>
@Right Expression
</pre>
<p>
  Right Expressionは,Array Typeでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Array Length Operator は,Array Lengthを<a href="#language-type-int">int Type</a> の値で返します。
</p>
<p>
  Array Length Operator は,<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  <b>Array Length Operator のExample</b>
</p>
<p>
  Array Length Operator のExampleです。
</p>
<pre>
my $nums = new byte[10];
my $length = @$nums;
</pre>
<p>
  SPVMにはPerlにおけるコンテキストという考え方はなく,Array Length Operator は,常にArray Lengthを返すことに注意してください。
</p>

<h4 id="language-expression-operator-string-length">String Length Operator </h4>
<p>
  String Length Operator は,<a href="#language-string">String</a>の長さを取得するための"length"で表現される<a href="#language-expression-operator-binary">Unary Operator</a>です。
</p>
<pre>
length Right Expression
</pre>
<p>
  Right Expressionは,<a href="#language-type-string-compatible">String Compatible Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  String Length Operator は,Stringの長さを<a href="#language-type-int">int Type</a> の値で返します。String Length Operator が返すStringの長さは,バイト列としてみたときの長さでです。
</p>
<p>
  String Length Operator は,<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  <b>String Length Operator のExample</b>
</p>
<p>
  String Length Operator のExampleです。
</p>
<pre>
my $nums = "abcde";
my $length = length $nums;
</pre>

<h4 id="language-expression-operator-scalar">Scalar Operator </h4>
<p>
  Scalar Operator は,何もしないで,与えられた値そのものを返すOperator です。<a href="#language-expression-operator-array-length">Array Length Operator</a>の意味を分かりやすくするためだけに用意されています。
</p>
<pre>
scalar Right Expression
</pre>
<p>
  Right Expressionは<a href="#language-expression-operator-array-length">Array Length Operator</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Scalar Operator returns Expression.
</p>
<p>
  <b>Scalar Operator のExample</b>
</p>
<p>
  Scalar Operator のExampleです。
</p>
<pre>
my $nums = new int[3];
foo(scalar @$nums);
</pre>

<h4 id="language-expression-operator-isweak">isweak Operator</h4>
<p>
  isweak Operator は,Fieldが,<a href="#language-weak-ref">Weaken Reference</a>かを確認するOperator です。
</p>
<pre>
isweak 変数->{Field Name};
</pre>
<p>
  オブジェクトExpressionのTypeは,<a href="#language-type-class">Class Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Field Nameは,存在するField Nameでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Fieldに保存される値のTypeは,<a href="#language-type-object">Object Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  実行時にFieldに保存されている値が,<a href="#language-undef">Undefined Value</a>だった場合は,偽を返します。これは,<a href="#language-expression">Expression</a>です。
</p>
<p>
  isweak Operator は,FieldがWeaken Referenceの場合は,<a href="#language-type-int">int Type</a> の1を,そうでない場合は0を返します。これは,<a href="#language-expression">Expression</a>です。
</p>

<h3 id="language-expression-operator-precedence">Operator Precidence</h3>
<p>
  Operator Precidenceは,the following 通りです。下にいくほど,優先順位が高くなります。
</p>
<table>
  <tr>
    <th>結合方向</th>
    <th>Operator </th>
  </tr>
  <tr>
    <td>
      右結合
    </td>
    <td>
      <ul>
      Assignment Operator "="<br>
      加算Assignment Operator "+="<br>
      減算Assignment Operator "-="<br>
      乗算Assignment Operator "*="<br>
      除算Assignment Operator "/="<br>
      剰余Assignment Operator "%="<br>
      Bit ANDAssignment Operator "&="<br>
      Bit ORAssignment Operator "|="<br>
      Bit 排他ORAssignment Operator "^="<br>
      左シフトAssignment Operator "<<="<br>
      算術右シフトAssignment Operator ">>="<br>
      Logical Right Shift Operator ">>>="<br>
      String結合Assignment Operator ".="
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Logical OR Operator "||"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Logical AND Operator  "&&"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Bit OR Operator "|"<br>
      Bit XOR Operator  "^"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Bit AND Operator "&"
    </td>
  </tr>
  <tr>
    <td>
      非結合
    </td>
    <td>
      数値等価Operator "=="<br>
      数値非等価Operator "!="<br>
      String等価Operator "eq"<br>
      String非等価Operator "ne"<br>
    </td>
  </tr>
  <tr>
    <td>
      非結合
    </td>
    <td>
      数値大なりOperator ">"<br>
      数値小なりOperator "<"<br>
      数値大なり等価Operator ">="<br>
      数値小なり等価Operator "<="<br>
      String大なりOperator "gt"<br>
      String大なり等価Operator "ge"<br>
      String小なりOperator "lt"<br>
      String小なり等価Operator "le"<br>
      isa Operator "isa"
    </td>
  </tr>
  <tr>
    <td>
      左結合 
    </td>
    <td>
      Left Shift Operator  "<<"<br>
      符号付き右Shift Operator ">>"<br>
      符号なし右Shift Operator ">>>"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Addition Operator "+"<br>
      Subtraction Operator "-"<br>
      String Concatenation Operator "."
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Multiplication Operator "*"<br>
      Division Operator "/"<br>
      Remainder Operator "%"
    </td>
  </tr>
  <tr>
    <td>
      右結合
    </td>
    <td>
      Logical NOT Operator "!"<br>
      Bit NOT Operator "~"<br>
      Reference Operator  "\"<br>
      Unary Plus Operator "+"<br>
      Unary Minus Operator "-"<br>
      Array Length Operator "@"<br>
      Dereference Operator "$"<br>
      Type Cast"(TypeName)"
      Scalar Operator "scalar"<br>
      String Length Operator "length"<br>
      require keyword "require"<br>
    </td>
  </tr>
  <tr>
    <td>
      非結合
    </td>
    <td>
      Pre Increment Operator "++"<br>
      Post Increment Operator "++"<br>
      Pre Decrement Operator "--"<br>
      Post Decrement Operator "--"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Arrow Operator "->"<br>
    </td>
  </tr>
</table>
<p>
  Operator Precidenceは"()"を使うことによって,最優先にすることができます。
</p>
<pre>
# a * b が先
a * b + c

# b + c が先
a * (b + c)
</pre>

<h3 id="language-Statement">Statement</h3>
<p>
  Statementは,ひとつの処理のことで<a href="#language-scope-scope-block">Scope Block</a>の中に複数記述することができます。<a href="#language-expression">Expression</a>のように値として評価されることはありません。
</p>
<p>
  <b>Statementの一覧</b>
</p>
<p>
  Statementの一覧です。
</p>
<ul class="list">
  <li><a href="#language-Statement-if">if Statement</a></li>
  <li><a href="#language-Statement-switch">switch Statement</a></li>
  <li><a href="#language-Statement-case">case Statement</a></li>
  <li><a href="#language-Statement-while">while Statement</a></li>
  <li><a href="#language-Statement-for">for Statement</a></li>
  <li><a href="#language-Statement-default">default Statement</a></li>
  <li><a href="#language-Statement-block-simple">Simple Block</a></li>
  <li><a href="#language-Statement-eval">eval Statement</a></li>
  <li><a href="#language-Statement-ifrequire">if requireStatement</a></li>
  <li><a href="#language-Statement-next">next Statement</a></li>
  <li><a href="#language-Statement-last">last Statement</a></li>
  <li><a href="#language-Statement-break">break Statement</a></li>
  <li><a href="#language-Statement-return">return Statement</a></li>
  <li><a href="#language-Statement-die">die Statement</a></li>
  <li><a href="#language-Statement-weaken">weaken Statement</a></li>
  <li><a href="#language-Statement-unweaken">unweaken Statement</a></li>
  <li><a href="#language-Statement-expression">expression Statement</a></li>
  <li><a href="#language-Statement-print">print Statement</a></li>
  <li><a href="#language-Statement-warn">warn Statement</a></li>
  <li><a href="#language-Statement-empty">empty Statement</a></li>
</ul>

<h4 id="language-Statement-if">if Statement</h4>
<p>
  if Statementは,条件分岐を行うためのStatementです。
</p>
<pre>
if (Expression) {

}
</pre>
<p>
  Expressionに<a href="#language-type-convertion-bool">Bool Type Convertion</a>が実行され,値が0以外の場合に,Block が実行されます。
</p>
<p>
  条件を複数書きたい場合には"elsif Statement"を続けることができます。 条件判定は上から実行され,それぞれのExpressionに<a href="#language-type-convertion-bool">Bool Type Convertion</a>が実行され,値が0以外の場合に対応するBlock が実行されます。
</p>
<pre>
if (Expression) {

}
elsif(Expression) {

}
</pre>
<p>
  "elseStatement"を使って,if Statementあるいは,elsif Statementが条件を満たさなかった場合の処理を記述することができます。if Statementとelsif Statementの条件判定がすべて偽であった場合にelseのBlock の内部のStatementが実行されます。elsif Statementは,なくてもかまいません。
</p>
<pre>
if (Expression) {

}
elsif(Expression) {

}
else {

}
</pre>
<p>
  <b>if StatementのExample</b>
</p>
<p>
  if StatementのExampleです。
</p>
<pre>
my $flag = 1;

if ($flag == 1) {
print "One\n";
}
elsif ($flag == 2) {
print "Tow\n";
}
else {
print "Other";
}
</pre>
<p>
  if Statementは,内部的には,目には見えないSimple Blockで囲まれています。
</p>
<pre>
{
if (Expression) {

}
}
</pre>
<p>
  elsifは,内部的には,if StatementとelseStatementに展開されます。
</p>
<pre>
# 展開前
if (Expression1) {

}
elsif (Expression2) {

}
else {

}

# 展開後
if (Expression1) {
}
else {
if (Expression2) {

}
else {

}
}
</pre>
<p>
  if Statementの条件部で,変数宣言を行うときは,目には見えない<a href="#language-scope-block-Statement-simple">Simple Block</a>で囲まれていることと,elsifは,内部的には,if StatementとelseStatementに展開されるということを,意識してください。
</p>
<pre>
# 展開前
my $num = 1;
if (my $num = 2) {

}
elsif (my $num = 3) {

}
else {

}

# 展開後
my $num = 1;
{
  if (my $num = 2) {

  }
  else {
    {
      if (my $num = 3) {
        
      }
      else {
        
      }
    }
  }
}
</pre>

<h4 id="language-Statement-switch">switch Statement</h4>
<p>
  switch Statementは,<a href="#language-type-int">int Type</a> の整数を条件にして,条件分岐を行うためのStatementです。条件が<a href="#language-type-int">int Type</a> の整数で,たくさんの分岐がある場合は,if Statementよりも高速です。
</p>
<pre>
switch (条件Expression) {
  case 定数1: {

    break;
  }
  case 定数2: {

    break;
  }
  case 定数n: {
    break;
  }
  default: {

  }
}
</pre>
<p>
  条件Expressionは,<a href="#language-expression">Expression</a>を指定できます。条件Expressionには,<a href="#language-type-convertion-bool">Bool Type Convertion</a>が実行されます。
</p>
<p>
  case Statementで指定される定数は,<a href="#language-type-byte">byte Type</a>か<a href="#language-type-int">int Type</a> の定数でなければなりません。<a href="#language-type-byte">byte Type</a>の定数の場合は,コンパイル時に,<a href="#language-type-int">int Type</a> にType Convertionされます。enumTypeの値や,<a href="#language-type-int">int Type</a> のConstant Subroutine は,<a href="#language-type-int">int Type</a> の定数として,syntax 解析時に展開されるので,利用することができます。
</p>
<p>
  case Statementに指定される定数は,重複してはいけません。重複している場合は,a compile-time error occurs
</p>
<p>
  条件Expressionで指定された値が,case Statementで指定された値にマッチした場合は,そのcase Statementの位置にジャンプします。
</p>
<p>
  マッチしなかった場合でdefault Statementが指定されている場合は,default Statementの位置にジャンプします。default Statementが指定されていなかった場合は,switch Blockは実行されません。
</p>
<p>
  switch Statementには,少なくともひとつのcase Statementが必要です。otherwise コンパイルエラーが発生します。
</p>
<p>
  default Statementは省略可能です。
</p>
<p>
  switch Blockの直下に記述できるのはcase Statementとdefault Statementだけです。
</p>
<p>
  caseとdefaultのBlock は省略することができます。
</p>
<pre>
switch (条件Expression) {
  case 定数1:
  case 定数2:
  {
    break;
  }
  default:
}
</pre>
<p>
  break Statementを使用した場合は,switch Blockから抜けることができます。
</p>

<pre>
switch (条件Expression) {
  case 定数1: {
    break;
  }
  case 定数2: {
    break;
  }
  case 定数n: {
    break;
  }
  default: {

  }
}
</pre>
<p>
  caseのBlock が存在する場合は,最後のStatementはbreak Statementあるいは,returnl Statementでなければなりません。otherwise コンパイルエラーが発生します。
</p>

<p>
  <b>switch StatementのExample</b>
</p>
<p>
  switch StatementのExampleです。
</p>
<pre>
my $code = 2;
switch ($code) {
  case 1: {
  print "1\n";
    break;
  }
  case 2: {
  print "2\n";
    break;
  }
  case 3: {
  print "3\n";
    break;
  }
  case 4:
  case 5:
  {
  print "4 or 5\n"; {
    break;
  }
  default: {
    print "Other\n";
  }
}
</pre>

<h4 id="language-Statement-switch">case Statement</h4>
<p>
  case Statementは,switch Blockの中で使うことができる,条件を指定するためのStatementです。case Statementについての詳細は,<a href="#language-Statement-switch">switch Statement</a>の解説を見てください。
</p>

<h4 id="language-Statement-switch">default Statement</h4>
<p>
  default Statementは,switch Blockの中で使うことができる,デフォルトの条件を指定するためのStatementです。default Statementについての詳細は,<a href="#language-Statement-switch">switch Statement</a>の解説を見てください。
</p>

<h4 id="language-Statement-while">while Statement</h4>
<p>
  while Statementは,繰り返しを行うためのStatementです。
</p>
<pre>
while (条件Expression) {

}
</pre>
<p>
  条件Expressionに,<a href="#language-expresssion">Expression</a>を記述できます。条件Expressionに<a href="#language-type-convertion-bool">Bool Type Convertion</a>が実行され,値が0以外の場合に,Block が実行されます。otherwise Block を抜けます。
</p>
<p>
  <b>while StatementのExample</b>
</p>
<p>
  while StatementのExampleです。
</p>
<pre>
my $i = 0;
while ($i < 5) {

  print "$i\n";

  $i++;
}
</pre>
<p>
  while Blockの内部では,<a href="#language-Statement-last">last Statement</a>を使って,while Blockを抜けることができます。
</p>
<pre>
while (1) {
  last;
}
</pre>

<p>
  while Blockの内部では,<a href="#language-Statement-next">next Statement</a>を使って,次に実行される条件Expressionの直前に移動することができます。
</p>
<pre>
my $i = 0;
while ($i < 5) {

  if ($i == 3) {
    $i++;
    next;
  }

  print "$i\n";
  $i++;
}
</pre>

<p>
  while Statementは,内部的には,目には見えない<a href="#language-scope-block-Statement-simple">Simple Block</a>で囲まれています。
</p>
<pre>
{
  while (条件Expression) {

  }
}
</pre>
<p>
  while Statementの条件部で,変数宣言を行うときは,目には見えない<a href="#language-scope-block-Statement-simple">Simple Block</a>で囲まれていることを意識してください。
</p>
<pre>
# 展開前
my $num = 5;
while (my $num = 3) {

  $i++;
}

# 展開後
my $num = 5;
{
  while (my $num = 3) {

    $i++;
  }
}
</pre>

<h4 id="language-Statement-for">for Statement</h4>
<p>
  for Statementは,繰り返しを行うためのStatementです。
</p>
<pre>
for (初期化Expression; 条件Expression; インクリメントExpression) {

}
</pre>
<p>
  初期化Expressionには,<a href="#language-expression">Expression</a>を記述できます。一般的には,ループ変数の初期化などのExpressionを記述します。初期化Expressionは省略することが可能です。
</p>
<p>
  条件Expression,<a href="#language-expresssion">Expression</a>を記述できます。条件Expressionに<a href="#language-type-convertion-bool">Bool Type Convertion</a>が実行され,値が0以外の場合に,Block が実行されます。otherwise Block を抜けます。
</p>
<p>
  インクリメントExpressionには,<a href="#language-expression">Expression</a>を記述できます。一般的には,ループ変数のインクリメントのExpressionを記述します。インクリメントExpressionは省略することが可能です。
</p>
<p>
  for Statementはthe following while Statementと同じ意味を持ちます。インクリメントExpressionは,Block の最後に実行されます。初期化Expressionは,<a href="#language-scope-block-Statement-simple">Simple Block</a>に囲まれています。
</p>
<pre>
{
  初期化Expression;
  while (条件Expression) {



    インクリメントExpression;
  }
}
</pre>
<p>
  <b>for StatementのExample</b>
</p>
<p>
  for StatementのExampleです。
</p>
<pre>
for (my $i = 0; $i < 5; $i++) {

  print "$i\n";
}
</pre>
<p>
  for Blockの内部では,<a href="#language-Statement-last">last Statement</a>を使って,for Blockを抜けることができます。
</p>

<pre>
for (初期化Expression; 条件Expression; インクリメントExpression) {

}
</pre>

<p>
  for Blockの内部では,<a href="#language-Statement-next">next Statement</a>を使って,次に実行されるインクリメントExpressionの直前に移動することができます。
</p>
<pre>
for (my $i = 0; $i < 5; $i++) {

  if ($i == 3) {
    next;
  }
}
</pre>

<h4 id="language-Statement-return">returnl Statement</h4>
<p>
  returnl Statementを使うと,Subroutine から脱出します。モータル変数に代入されているオブジェクトは,自動的に解放されます。
</p>
<pre>
return;
</pre>
<p>
  Return Valueがある場合は,<a href="#language-expression">Expression</a>を指定することができます。
</p>
<pre>
return Expression;
</pre>
<p>
  <a href="#language-sub-definition">Subroutine Definition</a>においてReturn ValueのTypeが<a href="#language-type-void">void Type</a>である場合は,Expressionが存在してはいけません。otherwise a compile-time error occurs.
</p>
<p>
  <a href="#language-sub-definition">Subroutine Definition</a>においてReturn ValueのTypeが<a href="#language-type-void">void Type</a>以外の場合は,ExpressionのTypeと一致していなければなりません。otherwise a compile-time error occurs.
</p>

<h4 id="language-Statement-die">die Statement </h4>
<p>
  die Statement は,例外を発生させるためのStatementです。
</p>
<pre>
die Expression;
</pre>
<p>
  Expressionは,String Compatible Typeでなければなりません。
</p>
<p>
  die Statement の詳しい解説については,<a href="#language-exception">Exception</a>を見てください。
</p>

<h4 id="language-Statement-weaken">weaken Statement </h4>
<p>
  weaken Statement は,Fieldに対して,<a href="#language-weak-ref">Weaken Reference</a>を設定するStatementです。
</p>
<pre>
weaken 変数->{Field Name};
</pre>
<p>
  オブジェクトExpressionのTypeは,<a href="#language-type-class">Class Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Field Nameは,存在するField Nameでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Fieldに保存される値のTypeは,<a href="#language-type-object">Object Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  実行時にFieldに保存されている値が,<a href="#language-undef">Undefined Value</a>だった場合は,weaken Statement は,何もしません。
</p>
<p>
  実行時にFieldに保存されている値が,<a href="#language-undef">Undefined Value</a>でない場合は,次のことが行われます。
</p>
<p>
  1. Fieldに保存されているオブジェクトのReference Countを1減らします。
</p>
<p>
  2. Fieldに,Weaken Referenceフラグを設定します。
</p>
<p>
  3. Fieldに保存されているオブジェクトのバックReferenceに,Fieldを追加します。
</p>
<p>
  Weaken Referenceフラグは,Fieldに保存されているオブジェクトに設定されるのではなく,Field自体に設定されることに注意してください。
</p>
<p>
  Fieldに保存されているオブジェクトのReference Countが,0になってしまった場合は,Weaken Referenceは作成されず,Fieldに保存されているオブジェクトは解放されます。
</p>
<p>
  バックReferenceとは,Fieldに保存されているオブジェクトが持つデータで,Weaken Referenceフラグが設定されたFieldを知るために,追加されます。これは,複数存在することがあります。
</p>
<pre>
# バックReferenceが,複数あるExample
my $foo = new Foo;
my $bar = new Bar;
my $baz = new Baz;

$foo->{bar} = $bar;
$foo->{baz} = $baz;

$bar->{foo} = $foo;
$baz->{foo} = $foo;

weaken $bar->{foo};
weaken $baz->{foo};
</pre>
<p>
  上記の例では"$bar->{foo}"と"$baz->{foo}"に,Weaken Referenceフラグが立ちます。$fooで表現されるオブジェクトは,バックReference"$bar->{foo}"と"$baz->{foo}"を持ちます。
</p>
<p>
  バックReferenceの情報が必要なのは,<a href="#language-garbage-collection">Garbage Collection</a>が行われるときに,バックReferenceが指すFieldにUndefined Valueを代入する必要があるからです。
</p>

<h4 id="language-Statement-unweaken">unweaken Statement</h4>
<p>
  unweaken Statementは,Fieldに対して,<a href="#language-weak-ref">Weaken Reference</a>を解除するStatementです。
</p>
<pre>
unweaken 変数->{Field Name};
</pre>
<p>
  オブジェクトExpressionのTypeは,<a href="#language-type-class">Class Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Field Nameは,存在するField Nameでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Fieldに保存される値のTypeは,<a href="#language-type-object">Object Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  実行時にFieldに保存されている値が,<a href="#language-undef">Undefined Value</a>だった場合は,unweaken Statementは,何もしません。
</p>
<p>
  実行時にFieldに保存されている値が,<a href="#language-undef">Undefined Value</a>でない場合は,次のことが行われます。
</p>
<p>
  1. Fieldに保存されているオブジェクトのReference Countを1増やします。
</p>
<p>
  2. FieldのWeaken Referenceフラグを解除します。
</p>
<p>
  3. Fieldに保存されているオブジェクトのバックReferenceから,Fieldを削除します。
</p>

<h4 id="language-Statement-next">next Statement</h4>
<p>
  "next Statement"は,次のループの先頭に移動するためのStatementです。<a href="#language-scope-block-Statement-while">while Block</a>,<a href="#language-scope-block-Statement-for">for Block</a>の中で使うことができます。
</p>
<pre>
next;
</pre>
<p>
  実際の動作については<a href="#language-Statement-while">while Statement</a>,<a href="#language-Statement-for">for Statement</a>の解説を見てください。
</p>

<h4 id="language-Statement-last">last Statement</h4>
<p>
  "last Statement"は,ループを脱出するためのStatementです。<a href="#language-scope-block-Statement-while">while Block</a>,<a href="#language-scope-block-Statement-for">for Block</a>の中で使うことができます。
</p>
<p>
  実際の動作については<a href="#language-Statement-while">while Statement</a>,<a href="#language-Statement-for">for Statement</a>の解説を見てください。
</p>
<pre>
last;
</pre>

<h4 id="language-Statement-break">break Statement</h4>
<p>
  "break Statement"は,switch Blockを脱出するためのStatementです。<a href="#language-scope-block-Statement-switch">switch Block</a>の中で使うことができます。
</p>
<p>
  実際の動作については<a href="#language-Statement-switch">switch Statement</a>の解説を見てください。
</p>
<pre>
break;
</pre>

<h4 id="language-Statement-warn">warn Statement</h4>

<p>
  警告を発生させるにはwarnStatementを使用します。
</p>
<pre>
warn Expression;
</pre>
<p>
  Expressionは,<a href="#language-type-string-compatible">String Compatible Type</a>でなければなりません。
</p>
<p>
  末尾が改行Character"\n"であった場合は,標準エラー出力にExpressionで指定されているStringが出力されます。
</p>
<p>
  末尾が改行Characterでない場合は,末尾にFile Nameと行番号が追加され,標準エラー出力されます。
</p>
<p>
  Expressionで指定されたStringの長さが0あるいは,Undefined Valueであった場合は,指定されたメッセージが"Warning: something's wrong"であるとしてふるまいます。
</p>
<p>
  標準エラー出力のバッファがフラッシュされます。
</p>

<h4 id="language-Statement-print">print Statement</h4>
<p>
  標準出力にStringを出力するにはprint Statementを使用します。
</p>
<pre>
print Expression;
</pre>
<p>
  Expressionは,<a href="#language-type-string-compatible">String Compatible Type</a>でなければなりません。
</p>
<p>
  ExpressionがUndefined Valueであった場合は,何もしません。
</p>

<h4 id="language-Statement-expression">expression Statement</h4>
<p>
  expression Statementは<a href="#language-expression">Expression</a>と";"で構成されるStatementのことです。
</p>
<pre>
Expression;
</pre>

<p>
  expression StatementのExampleです。
</p>
<pre>
1;
$var;
1 + 2;
foo();
my $num = 1 + 2;
</pre>

<h4 id="language-Statement-empty">empty Statement</h4>
<p>
  empty Statementは";"だけで終わるStatementのことです。
</p>
<pre>
;
</pre>


<h3 id="language-type"><a href="#language-type">Type</a></h3>
<ul class="list">
  <li><a href="#language-type-summary">Type Summary</a></li>
  <li><a href="#language-type-initial-value">Type Initial Value</a></li>
  <li><a href="#language-type-void">void Type</a></li>
  <li><a href="#language-type-numeric">Numeric Type</a></li>
  <li><a href="#language-type-integral">Integral Type</a></li>
  <li><a href="#language-type-byte">byte Type</a></li>
  <li><a href="#language-type-short">short Type</a></li>
  <li><a href="#language-type-int"><a href="#language-type-int">int Type</a></a></li>
  <li><a href="#language-type-long">long Type</a></li>
  <li><a href="#language-type-floating-point">Floating Point Type</a></li>
  <li><a href="#language-type-float">float Type</a></li>
  <li><a href="#language-type-double">double Type</a></li>
  <li><a href="#language-type-package">Package Type</a></li>
  <li><a href="#language-type-object">Object Type</a></li>
  <li><a href="#language-type-numeric-object">Numeric Object Type</a></li>
  <li><a href="#language-type-undef">Undefined Type</a></li>
  <li><a href="#language-type-class">Class Type</a></li>
  <li><a href="#language-type-callback">Callback Type</a></li>
  <li><a href="#language-type-any-object">Any Object Type</a></li>
  <li><a href="#language-type-self">self Type</a></li>
  <li><a href="#language-type-array">Array Type</a></li>
  <li><a href="#language-type-array-numeric">Numeric Array Type</a></li>
  <li><a href="#language-type-array-byte">byte[] Type</a></li>
  <li><a href="#language-type-array-object">Object Array Type</a></li>
  <li><a href="#language-type-array-mulnum">Multi Numeric Array Type</a></li>
  <li><a href="#language-type-any-object-array">Any Object Array Type</a></li>
  <li><a href="#language-type-string">string Type</a></li>
  <li><a href="#language-type-string-compatible">String Compatible Type</a></li>
  <li><a href="#language-type-multi-numeric">Multi Numeric Type</a></li>
  <li><a href="#language-type-ref">Reference Type</a></li>
  <li><a href="#language-type-ref-numeric">Numeric Reference Type</a></li>
  <li><a href="#language-type-ref-multi-numeric">Multi Numeric Reference Type</a></li>
</ul>
<h4 id="language-type-summary">Type Summary</h4>

SPVM is a static type language. All data has a static type.

<p>
  <a href="#language-lex-var-declaration">Lexical Variable Declaration</a>, <a href="#language-field-definition">Field Definition</a>, <a href="#language-package-var-definition">Package Variable Definition</a>, and <b>Arguments</b> and <b>Return Value</b> of <a href="#language-sub-definition">Subroutine Definition</a> must specify <b>Type</b>.
</p>

In <a href="#language-lex-var-declaration">Lexical Variable Declaration</a>, <a href="#language-type-inference">Type Inference</a> can be used.

<h4 id="language-type-initial-value">Type Initial Value</h4>
<p>
  Lexical Variable Initial Value,<a href="#language-package-var-initial-value">Package Variable Initial Value</a>,Create ObjectにおけるFieldの初期値は,Type Initial Valueによって決まります。
</p>
<p>
  Type Initial Valueの一覧です。データにおけるすべてのBit 列は0に設定されます。
</p>
</p>
<table>
  <tr>
    <th>
      <b>Type Name </b>
    </th>
    <th>
      初期値
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>Object Type </b>
    </td>
    <td>
      undef
    </td>
  </tr>
  <tr>
    <td>
      <b>Multi Numeric Type</b>
    </td>
    <td>
      すべてのFieldが0
    </td>
  </tr>
</table>

<h4 id="language-type-numeric">Numeric Type</h4>

Numeric Type is <a href="#language-type-integral">Integral Type</a> or <a href="#language-type-floating-point">Floating Point Type</a>.

<h4 id="language-type-integral">Integral Type</h4>

Integral Type are the following four types.

<table>
  <tr>
    <th>
      <b>Type</b>
    </th>
    <th>
      Description
    </th>
    <th>
      Size
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      signed 8-bit integer type
    </td>
    <td>
      1 byte
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      signed 16-bit integer type
    </td>
    <td>
      2 bytes
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      signed 32-bit integer type
    </td>
    <td>
      4 bytes
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      signed 64-bit integer type
    </td>
    <td>
      8 bytes
    </td>
  </tr>
</table>

See <a href="#language-expression-operator-arithmetic">Arithmetic Operator</a> for integer calculation rules.

Note that SPVM has only <b>singed</b> Integral Type, and don't has <b>unsigned</b> Integral Type.

<h4 id="language-type-byte"><a href="#language-type-byte">byte Type</a></h4>
<p>
  <a href="#language-type-byte">byte Type</a>は,符号付8bit整数を表現する<a href="#language-type-integral">Integral Type</a>です。C99のint8_tTypeと同じTypeです。
</p>
<h4 id="language-type-short">short Type</h4>
<p>
  <a href="#language-type-byte">byte Type</a>は,符号付16bit整数を表現する<a href="#language-type-integral">Integral Type</a>です。C99のint16_tTypeと同じTypeです。
</p>

<h4 id="language-type-int">int Type</h4>

<b>int Type</b> is a type that represents signed 32-bit integer.

This is same as <b>C99 int32_t Type</b>.

This is a <a href="#language-type-integral">Integral Type</a>.

<h4 id="language-type-long"><a href="#language-type-long">long Type</a></h4>
<p>
  <a href="#language-type-long">long Type</a>は,符号付64bit整数を表現する<a href="#language-type-integral">Integral Type</a>です。C99のint64_tTypeと同じTypeです。
</p>

<h4 id="language-type-floating-point">Floating Point Type</h4>

<b>Floating Point Type</b> are the following two.

<table>
  <tr>
    <th>
      <b>Type</b>
    </th>
    <th>
      Description
    </th>
    <th>
      Size
    </th>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      Single precision(32bit) floating po<a href="#language-type-int">int Type</a>
    </td>
    <td>
      4 bytes
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      Double precision(64bit) floating po<a href="#language-type-int">int Type</a>
    </td>
    <td>
      8 bytes
    </td>
  </tr>
</table>

See <a href="#language-expression-operator-arithmetic">Arithmetic Operator</a> for floating-point calculation rules.

<h4 id="language-type-float"><a href="#language-type-float">float Type</a></h4>
<p>
  <a href="#language-type-float">float Type</a>は,単精度浮動小数点(32bit)を表現する<a href="#language-type-floating-point">Floating Point Type</a>です。C99の<a href="#language-type-float">float Type</a>と同じTypeです。
</p>

<h4 id="language-type-double"><a href="#language-type-double">double Type</a></h4>
<p>
  <a href="#language-type-double">double Type</a>は,倍精度浮動小数点(64bit)を表現する<a href="#language-type-floating-point">Floating Point Type</a>です。C99の<a href="#language-type-double">double Type</a>と同じTypeです。
</p>

<h4 id="language-type-package">Package Type</h4>
<p>
  Package Typeとは<a href="#language-package-definition">Package Definition</a>によってDefinitionされるTypeのことをいいます。
</p>
<pre>
package Foo {

}
</pre>
<p>
  Package Typeは<a href="#language-type-class">Class Type</a><a href="#language-type-callback">Callback Type</a><a href="#language-type-multi-numeric">Multi Numeric Type</a>からなります。
</p>
<pre>
# Class Type
package Foo {

}

# Callback Type
package Foo : callback_t {

}

# Multi Numeric Type
package Foo : mulnum_t {

}
</pre>
<p>
  <a href="#language-type-pointer">Pointer Type</a>は,Class Typeでもあるので,Pointer TypeもPackage Typeになります。
</p>
<pre>
# Pointer Type
package Foo : pointer_t {

}
</pre>

<h4 id="language-type-object">Object Type </h4>
<p>
  Object Type とは<a href="#language-type-class">Class Type</a><a href="#language-type-callback">Callback Type</a><a href="#language-type-array">Array Type</a><a href="#language-type-string">string Type</a><a href="#language-type-any-object">Any Object Type</a>を合わせたものをいいます。"Multi Numeric Type""Reference Type "は含みません。
</p>
<p>
  Object Type の値は"Any Object Type "に代入できます。
</p>
<pre>
my $object : object = new Foo;
my $object : object = new Foo[];
my $object : object = "abc";
</pre>
<p>
  Object Type のSizeはC99における"sizeof(void*)"の値と一致していなければなりません。
</p>

<h4 id="language-type-numeric-object">Numeric Object Type </h4>
<p>
  <b>Numeric Object Type</b> are the following six.
</p>
<table>
  <tr>
    <th>
      <b>Type</b>
    </th>
    <th>
      Description
    </th>
  </tr>
  <tr>
    <td>
      SPVM::Byte
    </td>
    <td>
      Numeric Object Type with <a href="#language-type-byte">byte Type</a> data
    </td>
  </tr>
  <tr>
    <td>
      SPVM::Short
    </td>
    <td>
      Numeric Object Type with <a href="#language-type-short">short Type</a> data
    </td>
  </tr>
  <tr>
    <td>
      SPVM::Int
    </td>
    <td>
      Numeric Object Type with <a href="#language-type-int"><a href="#language-type-int">int Type</a></a> data
    </td>
  </tr>
  <tr>
    <td>
      SPVM::Long
    </td>
    <td>
      Numeric Object Type with <a href="#language-type-long">long Type</a> data
    </td>
  </tr>
  <tr>
    <td>
      SPVM::Float
    </td>
    <td>
      Numeric Object Type with <a href="#language-type-float">float Type</a> data
    </td>
  </tr>
  <tr>
    <td>
      SPVM::Double
    </td>
    <td>
      Numeric Object Type with <a href="#language-type-double">double Type</a> data
    </td>
  </tr>
</table>

For the conversion between <a href="#language-type-numeric">Numeric Type</a> and <b>Numeric Object Type</b>, see <a href="#language-type-convertion">Type Conversion</a>.

<h4 id="language-type-undef">Undefined Type</h4>
<p>
  Undefined Typeとは,<a href="#language-undef">Undefined Value</a>が持っているTypeのことです。明示的に利用することはできません。
</p>
<p>
  Undefined Typeの値は<a href="#language-undef">Undefined Value</a>のみです。
</p>
<p>
  Undefined Typeの値は,Object Type に代入できます。他のTypeに代入した場合は,a compile-time error occurs
</p>

<h4 id="language-type-class">Class Type</h4>
<p>
  Class Typeとは<a href="#language-package-definition">Package Definition</a>によってDefinitionされるTypeで"Multi Numeric Type""Callback Type"ではないTypeのことをいいます。
</p>
<pre>
packag Foo {

}
</pre>
<p>
  Class Typeはnew Operator によって,オブジェクトを生成することができます。
</p>
<pre>
my $foo = new Foo;
</pre>
<p>
  Class Typeは<a href="#language-type-object">Object Type</a>です。
</p>
<p>
  Class Typeは<a href="#language-type-package">Package Type</a>です。
</p>
<p>
  <a href="#language-type-pointer">Pointer Type</a>はClass Typeです。
</p>

<h4 id="language-type-pointer">Pointer Type</h4>
<p>
  Pointer Typeとは<a href="#language-package-definition">Package Definition</a>において"pointer_t Descriptor"が指定されたものをいいます。
</p>
<pre>
package Foo : pointer_t {

}
</pre>
<p>
  Pointer Typeは,Class Typeの一種です。
</p>
<p>
  Pointer Typeのデータには,C言語のポインタを保存することができます。
</p>
<p>
  Pointer Typeには,FieldをDefinitionすることはできません。Definitionされていた場合は,a compile-time error occurs
</p>

<h4 id="language-type-callback">Callback Type</h4>

Callback Type is a <a href="#language-type-package">Package Type</a> with <a href="#language-package-descriptor">Package Descriptor</a> "callback_t".

<pre>
package SPVM::Comparator : callback_t {
  sub : int ($self : self, $x1 : object, $x2 : object);
}
</pre>

Callback Type is designed to provide a feature corresponding to Function Pointer in C language.

Callback Type must have only one <a href="#language-sub-definition">Subroutine Definition</a>. Subroutine must be <a href="#language-sub-method">Method</a>.

Subroutine Name of Callback Type must be anonymouse.

Callback Type must not have any <a href="#language-field-definition">Field Definition</a> and <a href="#language-package-var-definition">Package Variable Definition</a>.

Callback Type is a <a href="#language-type-object">Object Type</a>.

Callback Type cannot be the operand of <a href="#language-expression-new">new Statement</a>.

The variable of Callback Type can be assigned a <a href="#language-type-class">Class Type</a> object that matches the Callback Type. "matches the Callback Type" means the following two cases.

1. Class Type object with anonimouse name and the <a href="#language-sub-signature">Signature</a> is same as Callback Type

<pre>
# Callback Type Definition
package SPVM::Comparator : callback_t {
  sub : int ($self : self, $x1 : object, $x2 : object);
}

# Class Definition
package SomeComparator {
  sub new : int () {
    return new SomeComparator;
  }

  sub : int ($self : self, $x1 : object, $x2 : object) {

  }
}

# The object can be assign to the variable of Callback Type
my $comparator : SPVM::Comparator = SomeComparator->new;
</pre>

2. Class Type object which is created by <a href="#language-sub-new-callback-object">Create Callback Object</a> and the <a href="#language-sub-signature">Signature</a> is same as Callback Type.

<pre>
# Callback TypeのDefinition
package SPVM::Comparator : callback_t {
  sub : int ($self : self, $x1 : object, $x2 : object);
}

# The object which is created by Create Callback Object can be assign to the variable of Callback Type
my $comparator : SPVM::Comparator = sub : int ($self : self, $x1 : object, $x2 : object) {

}
</pre>

<h4 id="language-type-any-object">Any Object Type </h4>
<p>
  Any Object Type は"object"で表現します。C言語の"void*"Typeを表現するために設計されました。
</p>
<pre>
my $object : object;
</pre>
<p>
  Any Object Type には"Object Type "の値を代入できます。
</p>
<pre>
my $object : object = new Foo;
my $object : object = "abc";
my $object : object = new Foo[3];
</pre>

<h4 id="language-type-self">self Type</h4>
<p>
  self Typeとは,自身の属するPackage Typeを表現し,引数がInvocant であることを示します。
</p>
<p>
  <a href="#language-sub-definition">Subroutine Definition</a>において第一引数のTypeとしてのみ利用できます。
</p>

<h4 id="language-type-void"><a href="#language-type-void">void Type</a></h4>

<b>void Type</b> is a special Type that can only be used in Return Type of <a href="#language-sub-definition">Subroutine Definition</a> and indicates the Subroutine has no Return Value.

<h4 id="language-type-basic">Basic Type</h4>
<p>
  次元を持たないTypeをBasic Typeと呼びます。<a href="#language-type-numeric">Numeric Type</a>,<a href="#language-type-package">Package Type</a>,<a href="#language-type-any-object">Any Object Type</a>,<a href="#language-type-string">string Type</a>は,Basic Typeです。
</p>

<h4 id="language-type-array">Array Type</h4>
<p>
  Array Typeは,連続した複数のデータ領域を表現します。<a href="#language-type-basic">Basic Type</a>は,Arrayにすることができます。
</p>
<pre>
int[]
double[]
Point[]
object[]
string[]
</pre>
<p>
  Arrayは次元を持ち最大255次元まで表現できます。
</p>
<pre>
# 二次元
int[][]

# 三次元
int[][][]
</pre>
<p>
  Array Typeは,<a href="#language-type-object">Object Type</a>です。
</p>
<p>
  Arrayを作成するには,new Operator を使用します。the following 例では,要素数が3の<a href="#language-type-int">int Type</a> のArrayを作成しています。
</p>
<p>
my $nums = new int[3];
</p>
<p>
  多次元Arrayを作成するときも,new Operator を使用します。the following 例では,要素数が3のint[]TypeのArrayを作成しています。
</p>
<p>
my $nums = new int[][3];
</p>
<h4 id="language-type-array-numeric">Numeric Array Type</h4>
<p>
  Numeric Array Typeとは,<a href="#language-type-numeric">Numeric Type</a>の値を要素に持つ<a href="#language-type-array">Array Type</a>のことです。
</p>
<p>
  <b>Numeric Array Typeの一覧</b>
</p>
<ul class="list">
  <li>
    byte[]
  </li>
  <li>
    short[]
  </li>
  <li>
    int[]
  </li>
  <li>
    long[]
  </li>
  <li>
    float[]
  </li>
  <li>
    double[]
  </li>
</ul>
<p>
  Numeric Array Typeによって表現されるデータは,要素が<a href="#language-type-numeric">Numeric Type</a>のSizeで,Array Lengthの個数で連続していなければなりません。
</p>
<p>
  Numeric Array Typeのすべての要素は,Create Arrayが行われたときに<a href="#language-type-initial-value">Type Initial Value</a>によって初期化されます。
</p>
<h4 id="language-type-array-byte">byte[] Type</h4>
<p>
  SPVMにおいては,byte[] Typeは<a href="#language-type-string-compatible">String Compatible Type</a>であるという点において特別なTypeです。
</p>
<pre>
byte[]
</pre>
<p>
  <a href="#language-type-string">string Type</a>は,コンパイル時には<a href="#language-type-string">string Type</a>として扱われますが,実行時にはbyte[] Typeになります。
</p>

<h4 id="language-type-array-object">Object Array Type</h4>
<p>
  Object Array Typeとは,<a href="#language-type-object">Object Type</a>の値を要素に持つ<a href="#language-type-array">Array Type</a>のことです。
</p>
<p>
  <b>Object Array TypeのExample</b>
</p>
<ul class="list">
  <li>
    Foo[]
  </li>
  <li>
    Foo[][]
  </li>
  <li>
    Comparable[]
  </li>
  <li>
    object[]
  </li>
</ul>
<p>
  Object Array Typeによって表現されるデータは,要素が<a href="#language-type-object">Object Type</a>のSizeで,Array Lengthの個数で連続していなければなりません。
</p>
<p>
  Object Array Typeのすべての要素は,Create Arrayが行われたときに<a href="#language-type-initial-value">Type Initial Value</a>によって初期化されます。
</p>

<h4 id="language-type-array-mulnum">Multi Numeric Array Type</h4>
<p>
  Multi Numeric Array Typeとは,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値を要素に持つ<a href="#language-type-array">Array Type</a>のことです。
</p>
<p>
  <b>Multi Numeric Array TypeのExample</b>
</p>
<ul class="list">
  <li>
    Complex_2d[]
  </li>
  <li>
    Complex_2f[]
  </li>
</ul>
<p>
  Multi Numeric Array Typeによって表現されるデータは,要素が<a href="#language-type-numeric">Multi Numeric Type</a>のSizeで,Array Lengthの個数で連続していなければなりません。
</p>
<p>
  Multi Numeric Array Typeのすべての要素は,Create Arrayが行われたときに<a href="#language-type-initial-value">Type Initial Value</a>によって初期化されます。
</p>

<h4 id="language-type-any-object-array">Any Object Array Type</h4>
<p>
  Any Object Array Typeとは,oarrayで表現される,<a href="#language-type-object">Object Type</a>の値を要素として持つ任意の<a href="#language-type-array">Array Type</a>の値を代入できるTypeです。C言語のqsort関数の第一引数には,任意のArray Typeをvoid*Typeにキャストして渡すことができますが,これに該当する機能を実現するために,Any Object Array Typeは設計されました。
</p>
<pre>
my $array : oarray = new Point[3];
my $array : oarray = new object[3];
</pre>
<p>
  Object Type 以外のTypeを持つ値が代入された場合は,a compile-time error occurs
</p>
<p>
  "oarrayType"は"object[]Type"と異なるTypeであることに注意してください。oarrayTypeは,Object Type の値を要素として持つ任意のArray Typeの値を代入できるTypeであるのに対して,"object[]Type"は,"objectTypeの値を要素に持つArray"を表現するTypeで,任意のArray Typeの値を代入することはできません。
</p>
<p>
  Any Object Array Typeは,<a href="#language-type-array">Array Type</a>です。<a href="#language-expression-operator-array-length">Array Length Operator</a>によって長さを取得すること,<a href="#language-expression-set-array-element">Set Array Element Value</a>,<a href="#language-expression-get-array-element">Get Array Element Value</a>ができます。
</p>
<pre>
my $array : oarray = new SPVM::Int[3];

# Any Object Array Typeの要素の長さを取得
my $legnth = @$array;

# Any Object Array Typeの要素の値の取得
my $num = (SPVM::Int)$array->[0];

# Any Object Array Typeの要素の値の設定
$array->[0] = SPVM::Int->new(5);
</pre>
<p>
  Any Object Array Typeの要素の値の設定においては,要素のTypeが,ArrayのType Dimensionよりも1だけ小さくなっているかの実行時チェックが入ります。チェックに失敗した場合は,例外が発生します。Any Object Array Typeは,実行時Type安全性を保証します。
</p>

<h4 id="language-type-string"><a href="#language-type-string">string Type</a></h4>
<p>
  <a href="#language-type-string">string Type</a>は,Stringを表現するTypeです。stringによって表現します。C言語の"const char*"を表現するために設計されました。
</p>
<pre>
my $str : string;
</pre>
<p>
  String Literal によって,生成されたStringオブジェクトを代入できます。
</p>
<pre>
my $str : string = "abc";
</pre>
<p>
  SPVMのStringは,要素を変更できないバイトTypeのArrayです。Arrayアクセスを行って,Characterを取得することができます。
</p>
<pre>
# Characterの取得
my $ch = $str->[1];
</pre>
<p>
  要素を変更しようとした場合は,a compile-time error occurs
</p>
<pre>
# 要素の変更はコンパイルエラー
$str->[1] = 'd';
</pre>
<p>
  <a href="#language-type-string">string Type</a>は,コンパイルが終わった後は,バイトTypeのArrayとまったく同じものになります。たとえば,一つ目の表現は,二つ目の表現として扱われます。
</p>
<pre>
# isa <a href="#language-type-string">string Type</a>
if ($str isa string) {

}

# isa バイトTypeのArray
if ($str isa byte[]) {

}
</pre>
<p>
  SPVMのStringは,変更不可ですが,これは,コンパイル時チェックであることに注意してください。
</p>
<p>
  <a href="#language-type-string">string Type</a>は,byte[] Typeに,キャストすることができ,実行時にStringを変更することができます。
</p>
<pre>
my $bytes = (byte[])$str;
$bytes->[1] = 'd';
</pre>
<p>
  Stringは,常に変更が可能であるものとして,扱ってください。
</p>

<h4 id="language-type-string-compatible">String Compatible Type</h4>
<p>
  String Compatible Typeとは,<a href="#language-type-string">string Type</a>と<a href="#language-type-array-byte">byte[] Type</a>のことを言います。
</p>
<p>
  String Compatible Typeの値が生成される場合には,値のために確保されたメモリ領域の最後のひとつ後ろは"\0"になることが保証されます。(たとえば"abc"であれば"c"の後ろは"\0")SPVM言語から見た場合,この"\0"は意味を持ちませんが,ネイティブAPIを使う場合は,String Compatible Typeを,C言語のStringとして扱うことができます。
</p>

<h4 id="language-type-multi-numeric">Multi Numeric Type</h4>
<p>
  Multi Numeric Typeとは,連続した数値を表現できるTypeです。
</p>
<p>
  <a href="#language-package-definition">Package Definition</a>において"mulnum_t"Descriptorを指定することで,Multi Numeric TypeをDefinitionできます。
</p>
<pre>
package Point_3i : mulnum_t {
  has x : int;
  has y : int;
  has z : int;
}
</pre>
<p>
  Multi Numeric Typeの詳しい解説については,<a href="#language-mulnum">値</a>を見てください。
</p>

<h4 id="language-type-ref">Reference Type </h4>
<p>
  Reference Type とは,変数のアドレスが格納できるTypeのことです。<a href="#language-type-numeric">Numeric Type</a>あるいは<a href="#language-type-multi-numeric">Multi Numeric Type</a>の後ろに"&"を付けることでDefinitionできます。
</p>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $point : Point_3i;;
my $point_ref : Point_3i& = \$point;
</pre>
<p>
  Reference Type の値に代入できるのは,<a href="#language-expression-operator-ref">Reference Operator</a>で取得したLexical Variable のアドレスだけです。
</p>
<p>
  Reference Type のLexical Variable Declaration だけが行われた場合は,a compile-time error occurs
</p>
<p>
  Reference Type は,<a href="#language-lex-var-declaration">Lexical Variable Declaration</a>のTypeとして利用できます。必ずReference Operator  によって,Lexical Variable のアドレスが格納される必要があります。Lexical Variable Declaration だけの場合は,a compile-time error occurs
</p>
<p>
  Reference Type は,<a href="#language-sub-definition">Subroutine Definition</a>における引数のTypeとして利用できます。
</p>
<p>
  Reference Type は,<a href="#language-sub-definition">Subroutine Definition</a>におけるReturn ValueのTypeとして利用できません。
</p>
<p>
  Reference Type は,<a href="#language-package-definition">Package Definition</a>におけるFieldのTypeとして利用できません。
</p>
<p>
  Reference Type は,<a href="#language-package-definition">Package Definition</a>におけるPackage Variable のTypeとして利用できません。
</p>
<p>
  Invalid 場所で,Reference Type が使用された場合は,a compile-time error occurs
</p>
<p>
  Referenceの詳しい解説については,<a href="#language-ref">Reference</a>を見てください。
</p>

<h4 id="language-type-ref-numeric">Numeric Reference Type</h4>

<p>
  Numeric Reference Type とは,<a href="#language-type-numeric">Numeric Type</a>の変数に対する<a href="#language-type-ref">Reference Type</a>のことをいいます。
</p>

<h4 id="language-type-ref-multi-numeric">Multi Numeric Reference Type</h4>

<p>
  Multi Numeric Reference Type とは,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の変数に対する<a href="#language-type-ref">Reference Type</a>のことをいいます。
</p>

<h3 id="language-type-inference">Type Inference</h3>
<p>
  Type Inferenceによって,<a href="#language-lex-var-declaration">Lexical Variable Declaration</a>するときに,<a href="#language-type">Type</a>の指定を省略することができます。Type Inferenceは,常にAssignment Operator の右辺のTypeによって,行われます。
</p>
<pre>
# int
my $num = 1;

# double
my $num = 1.0;

# Foo
my $foo = new Foo;
</pre>
<h3 id="language-type-compatible">Type Compatibility</h3>
<p>
  Typeに互換性があるというのは,<a href="#language-expression-typecast">Type Cast</a>を行わないで,値が移動ができるTypeのことです。
</p>
<p>
  Typeに互換性があるのは次の場合です。
</p>
<p>
  <b>移動元と移動先のTypeが同一の場合</b>
</p>
<p>
  移動元と移動先のTypeが同一の場合は,Type Compatibilityがあります。
</p>
<pre>
my $num1 : int;
my $num2 : int;
$num1 = $num2;
</pre>
<p>
  <b>移動元のTypeがbyte[] Typeで,移動先のTypeが<a href="#language-type-string">string Type</a>の場合</b>
</p>
<p>
  移動元のTypeがbyte[] Typeで,移動先のTypeが<a href="#language-type-string">string Type</a>の場合は,Type Compatibilityがあります。
</p>
<pre>
my $bytes = new byte[3];
my $str : string;
$str = $bytes;
</pre>
<p>
  <b>移動元のTypeがObject Type で,移動先のTypeがAny Object Type の場合</b>
</p>
<pre>
my $foo : Foo = new Foo;
my $object : object;
$object = $foo;
</pre>
<p>
  <b>移動元のTypeと移動先のTypeが,Any Object Type あるいは,Any Object Type のArrayで,移動元のType Dimension数が,移動先のType Dimension数以上の場合</b>
</p>
<pre>
my $objects_dim2_src : object[];
my $objects_dim1_dist : object;
$objects_dim1_dist = $objects_dim2_src;
</pre>
<p>
  注意点として,汎用オブジェクトのArrayとBasic TypeのArrayには互換性はありません。
</p>
<pre>
# コンパイルエラー
my $objets : object[] = new int[3];
</pre>
<p>
  Typeに互換性がない場合は,<a href="#language-type-convertion-implicite">暗黙的なType Convertion</a>が試みられます。暗黙のType Convertionに失敗した場合は,a compile-time error occurs
</p>

<h3 id="language-type-convertion">Type Convertion</h3>
<ul class="list">
  <li><a href="#language-type-convertion-typecast">Type Cast</a></li>
  <li><a href="#language-type-convertion-typecast">Numeric Type Type Convertion</a></li>
  <li><a href="#language-type-convertion-implicite">暗黙的なType Convertion</a></li>
  <li><a href="#language-type-convertion-numeric-type-order">Numeric Type Order</a></li>
  <li><a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a></li>
  <li><a href="#language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</a></li>
  <li><a href="#language-type-convertion-numeric-narrowing">Numeric Narrowing Type Convertion</a></li>
  <li><a href="#language-type-convertion-numeric-widening">Numeric Widening Type Convertion</a></li>
  <li><a href="#language-type-convertion-numeric-to-string">Numeric-to-<a href="#language-type-string">string Type</a> Convertion</a></li>
  <li><a href="#language-type-convertion-boxing">Boxing Type Convertion</a></li>
  <li><a href="#language-type-convertion-unboxing">Unboxing Type Convertion</a></li>
  <li><a href="#language-type-convertion-bool">Bool Type Convertion</a></li>
</ul>

<h4 id="language-type-convertion-typecast">Type Cast</h4>
<p>
  Type Castとは,明示的に記述して行うType Convertionのことを言います。
</p>
<pre>
# Type Cast
(Type)Expression
</pre>
<p>
  <a href="#language-type-int">int Type</a> の値を<a href="#language-type-long">long Type</a>に変換するExampleはthe following ようになります。
</p>
<pre>
my $num = (long)3;
</pre>
<p>
  Type Castは,<a href="#language-expression">Expression</a>を返します。
</p>
<p>
  移動元のTypeと指定したTypeが同一の場合は,単に値のコピーになります。
</p>
<pre>
my $num : int = (int)4;
</pre>
<p>
  <b>Type CastにおけるType Convertionの一覧</b>
</p>
<p>
  Type CastにおけるType Convertionの一覧です。この表にないType Castが行われた場合は,a compile-time error occurs
</p>
<table>
  <tr>
    <th>
      <b>指定したType</b>
    </th>
    <th>
      <b>移動元のType</b>
    </th>
    <th>
      変換の内容
    </th>
  </tr>
  <tr>
    <td>
      <b>byte[]</b>
    </td>
    <td>
      <b>string</b>
    </td>
    <td>
      アドレス値がコピーされます。
    </td>
  </tr>
  <tr>
    <td>
      <b>string</b>
    </td>
    <td>
      <b>byte[]</b>
    </td>
    <td>
      アドレス値がコピーされます。
    </td>
  </tr>
  <tr>
    <td>
      <b>Numeric Type</b>
    </td>
    <td>
      <b>Numeric Type</b>
    </td>
    <td>
      <a href="#language-type-convertion-numeric-widening">Numeric Type Type Convertion</a>が行われます。
    </td>
  </tr>
  <tr>
    <td>
      <b>Numeric Object Type </b>
    </td>
    <td>
      <b>Numeric Type</b>
    </td>
    <td>
      <a href="#language-type-convertion-boxing">Boxing Type Convertion</a>が行われます。Numeric TypeとNumeric Object Type が表現するNumeric Typeは,同じでなければなりません。たとえば,Numeric Typeがintの場合は,Numeric Object Type はSPVM::Int Type でなければなりません。
    </td>
  </tr>
  <tr>
    <td>
      <b>Any Object Type </b>
    </td>
    <td>
      <b>Numeric Type</b>
    </td>
    <td>
      <a href="#language-type-convertion-boxing">Boxing Type Convertion</a>が行われます。
    </td>
  </tr>
  <tr>
    <td>
      <b>Numeric Type</b>
    </td>
    <td>
      <b>Numeric Object Type </b>
    </td>
    <td>
      <a href="#language-type-convertion-unboxing">Unboxing Type Convertion</a>が行われます。Numeric TypeとNumeric Object Type が表現するNumeric Typeは,同じでなければなりません。たとえば,Numeric Typeがintの場合は,Numeric Object Type はSPVM::Int Type でなければなりません。
    </td>
  </tr>
  <tr>
    <td>
      <b>Numeric Type</b>
    </td>
    <td>
      <b>Any Object Type </b>
    </td>
    <td>
      <a href="#language-type-convertion-unboxing">Unboxing Type Convertion</a>が行われます。
    </td>
  </tr>
  <tr>
    <td>
      <b><a href="#language-type-string">string Type</a></b>
    </td>
    <td>
      <b>Numeric Type</b>
    </td>
    <td>
      数値が,C標準のsprintf関数の"%g"フォーマットを使って,String化されます。
    </td>
  </tr>
</table>

<h4 id="language-type-convertion-numeric">Numeric Type Type Convertion</h4>
<p>
  Numeric Type Type Convertionとは,<a href="#language-type-numeric">Numeric Type</a>から<a href="#language-type-numeric">Numeric Type</a>への変換のことです。
</p>
<p>
  Numeric Type Type Convertionは,対応するC言語におけるNumeric TypeによるType Convertionと全く同じ処理を行います。例えば,SPVMにおけるintからlongへのType Convertionは,C言語のint32_tTypeからint64_tTypeへのType Convertionと同じ処理を行います。
</p>
<pre>
# SPVMの変換
my $src : int = 5;
my $dist = (long)$src;

# C言語における対応
int32_t src = 5;
int64_t dist = (int64_t)src;
</pre>
<p>
  Typeの対応については,<a href="#language-c99-type">C99とのTypeの対応</a>を見てください。
</p>
<p>
  大きなTypeから小さなTypeに変換した場合や,浮動小数点からIntegral Typeに変換した場合は,Valid 情報が保持されない場合があります。SPVMでは,C99に対応するType Convertionをそのまま行っているので,Valid 情報が保持されない場合に,どの値に変換されるかは,C99の仕様と同じです。
</p>

<h4 id="language-type-convertion-implicite">暗黙的なType Convertion</h4>
<p>
  暗黙的なType Convertionとは,SPVMによって行われる自動的なType Convertionのことです。次の箇所が,暗黙的なType Convertionが行われる可能性のある個所です。
</p>
<ul class="list">
  <li>異なるTypeに代入する場合</li>
  <li>異なるTypeのSubroutine Argumentsに渡す場合</li>
  <li>Return Valueとは異なるTypeを返却する場合</li>
</ul>
<p>
  次の場合に暗黙的なType Convertionが行われます。
</p>
<p>
  移動元と移動先のTypeがどちらもNumeric Typeで,移動元のTypeよりも移動先のTypeが大きい場合は,<a href="#language-type-convertion-numeric-widening">Numeric Widening Type Convertion</a>が行われます。
</p>
<pre>
# 暗黙の拡大Type Convertion
my $num : long = 123;
my $num : double = 12.5f;
</pre>
<p>
  移動元と移動先のTypeがどちらもNumeric Typeで,移動元のTypeよりも移動先のTypeが小さい場合で,移動元の値が,Integer Literal  かつ移動先のTypeの値の範囲で表現できる場合は,<a href="#language-type-convertion-numeric-narrowing">Numeric Narrowing Type Convertion</a>が行われます。
</p>
<pre>
# 暗黙の縮小Type Convertion
my $num : byte = 123;
my $num : short = 134;
</pre>
<p>
  移動元のTypeがNumeric Typeで,移動先のTypeがAny Object Type の場合は,対応するNumeric Object Type への<a href="#language-type-convertion-boxing">Boxing Type Convertion</a>が行われます。the following 場合の例では,SPVM::Int Type のオブジェクトに変換されたものが,汎用オブジェクトに代入されます。
</p>
<pre>
# objectTypeへの暗黙のBoxing Type Convertion
my $num = 123;
my $object : object = $num;
</pre>
<p>
  移動元のTypeがNumeric Typeで,移動先のTypeが対応するNumeric Object Type の場合は,対応するNumeric Object Type への<a href="#language-type-convertion-boxing">Boxing Type Convertion</a>が行われます。
</p>
<pre>
# objectTypeへの暗黙のBoxing Type Convertion
my $num = 123;
my $object : SPVM::Int = $num;
</pre>
<p>
  移動元のTypeがAny Object Type で,移動先のTypeがNumeric Typeの場合は,対応するNumeric Typeにおける<a href="#language-type-convertion-unboxing">Unboxing Type Convertion</a>が行われます。the following 場合の例では,SPVM::Int Type のオブジェクトから<a href="#language-type-int">int Type</a> への変換が試みられます。
</p>
<pre>
# objectTypeからの暗黙のUnboxing Type Convertion - 
my $object : object;
my $num : int = $object;
</pre>
<p>
  移動元のTypeがNumeric Object Type で,移動先のTypeが対応するNumeric Typeの場合は,対応するNumeric Typeにおける<a href="#language-type-convertion-unboxing">Unboxing Type Convertion</a>が行われます。
</p>
<pre>
# Numeric Object Type からの暗黙のUnboxing Type Convertion
my $num_obj = SPVM::Int->new(3);
my $num : int = $num_obj;
</pre>
  移動元のTypeがNumeric Typeで,移動先のTypeが,<a href="#language-type-string">string Type</a>の場合は,<a href="#language-type-convertion-numeric-to-string">Numeric-to-<a href="#language-type-string">string Type</a> Convertion</a>が行われます。the following 場合の例では,数値の"123"がString""123""に変換されたものが代入されます。
</p>
<pre>
# <a href="#language-type-string">string Type</a>への暗黙のBoxing Type Convertion
my $num = 123;
my $str : string = $num;
</pre>

<h4 id="language-type-convertion-numeric-type-order">Numeric Type Order</h4>
<p>
  <a href="#language-type-numeric">Numeric Type</a>は,Typeの順序を持ちます。Typeの順序は小さい方から"byte""short""int""long""float""double"です。
</p>
<h4 id="language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</h4>
<p>
  Unary Numeric Widening Type Convertionとは,<a href="#language-expression">Expression</a>が<a href="#language-type-byte">byte Type</a>あるいはshort Typeであった場合に,<a href="#language-type-int">int Type</a> へ<a href="#language-type-convertion-numeric-widening">Numeric Widening Type Convertion</a>を行うことをいいます。
</p>
<p>
  Unary Numeric Widening Type Convertionが行われるのはthe following 場合です。
</p>
<ul class="list">
  <li>Arrayのインデックス</li>
  <li>Arrayを作成する場合の次元</li>
  <li>Unary Plus Operator のオペランド</li>
  <li>Unary Minus Operator のオペランド</li>
  <li>Shift Operator "<<"">>"">>>"の左右のオペランド</li>
</ul>
<h4 id="language-type-convertion-binary-numeric-widening">Binary Numeric Widening Type Convertion</h4>
<p>
  Binary Numeric Widening Type Convertionとは,左辺と右辺にNumeric TypeをとるBinary Operator  において,Left ExpressionとRight Expressionに適用される<a href="#language-type-convertion-numeric-widening">Numeric Widening Type Convertion</a>のことをいいます。
</p>
<p>
  次のルールが適用されます。
</p>
<p>
  1. 一方のExpressionが,<a href="#language-type-double">double Type</a>の場合は,他方のTypeは<a href="#language-type-double">double Type</a>に変換されます。
</p>
<p>
  2. 一方のExpressionが,<a href="#language-type-float">float Type</a>の場合は,他方のTypeは<a href="#language-type-float">float Type</a>に変換されます。
</p>
<p>
  3. 一方のExpressionが,<a href="#language-type-long">long Type</a>の場合は,他方のTypeは<a href="#language-type-long">long Type</a>に変換されます。
</p>
<p>
  4. それ以外の場合は,<a href="#language-type-int">int Type</a> に変換されます。
</p>
<p>
  Binary Numeric Widening Type Convertionが行われるのはthe following 場合です。
</p>
<ul class="list">
  <li><a href="#language-expression-operator-add">Addition Operator</a></li>
  <li><a href="#language-expression-operator-subtract">Subtraction Operator</a></li>
  <li><a href="#language-expression-operator-multiply">Multiplication Operator</a></li>
  <li><a href="#language-expression-operator-divide">Division Operator</a></li>
  <li><a href="#language-expression-operator-remainder">Remainder Operator</a></li>
  <li><a href="#language-expression-operator-bit-and">Bit AND Operator</a></li>
  <li><a href="#language-expression-operator-bit-or">Bit OR Operator</a></li>
  <li><a href="#language-expression-operator-comparison-numeric">Numeric Comparison Operator</a></li>
</ul>

<h4 id="language-type-convertion-numeric-narrowing">Numeric Narrowing Type Convertion</h4>
<p>
  Numeric Narrowing Type Convertionとは,<a href="#language-type-numeric">Numeric Type</a>において大きいTypeから小さいTypeへの変換が行われる場合に適用される変換の規則のことです。
</p>

<h4 id="language-type-convertion-numeric-widening">Numeric Widening Type Convertion</h4>
<p>
  Numeric Widening Type Convertionとは,<a href="#language-type-numeric">Numeric Type</a>において小さいTypeから大きいTypeへの変換が行われる場合に適用される変換の規則のことです。
</p>

<h4 id="language-type-convertion-boxing">Boxing Type Convertion</h4>
<p>
  Boxing Type Convertionとは,Numeric Typeの値を,Numeric Object Type に変換する操作のことをいいます。
</p>

<h4 id="language-type-convertion-unboxing">Unboxing Type Convertion</h4>
<p>
  Unboxing Type Convertionとは,Numeric Object Type の値を,対応するNumeric Typeの値に変換する操作のことをいいます。
</p>

<h4 id="language-type-convertion-bool">Bool Type Convertion</h4>
<p>
  Bool Type Convertionとは,if Statementの条件部などで適用される,真偽値判定のために,適用される変換のことです。
</p>
<p>
  <b>Bool Type Convertionが行われる場所</b>
</p>
<p>
  <b>if Statementのかっこの中</b>
</p>
<pre>
if (条件部) {

}
</pre>
<p>
  <b>unless Statementのかっこの中</b>
</p>
<pre>
unless (条件部) {

}
</pre>
<p>
  <b>forのかっこの中の二つ目</b>
</p>
<pre>
for (初期化;条件部;次の値;) {

}
</pre>
<p>
  <b>whileのかっこの中</b>
</p>
<pre>
while (条件部) {

}
</pre>
<p>
  <b>Logical AND Operator の左右</b>
</p>
<pre>
条件部 && 条件部
</pre>
<p>
  <b>Logical OR Operator の左右</b>
</p>
<pre>
条件部 || 条件部
</pre>
<p>
  <b>Logical NOT Operator の右側</b>
</p>
<pre>
!条件部
</pre>
<p>
  Bool Type Convertionで指定されるExpressionは,<a href="#language-type-numeric">Numeric Type</a>あるいは<a href="#language-type-object">Object Type</a>あるいは<a href="#language-type-undef">Undefined Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Bool Type ConvertionのReturn Valueは,<a href="#language-type-int">int Type</a> のExpressionです。
</p>
<p>
  Expressionが<a href="#language-undef">Undefined Value</a>である場合は,0が返されます。
</p>
<p>
  Expressionが,<a href="#language-type-numeric">Numeric Type</a>の場合は,<a href="#language-type-convertion-unary-numeric-widening">Unary Numeric Widening Type Convertion</a>が行われます。
</p>
<p>
  Expressionが<a href="#language-type-int">int Type</a> の場合は,その値が返されます。
</p>
<p>
  Expressionが<a href="#language-type-long">long Type</a>,<a href="#language-type-float">float Type</a>,<a href="#language-type-double">double Type</a>,Object Type である場合は,C99におけるthe following 演算と完全に一致する演算を行い,結果が返されます。
</p>
<pre>
!!x
</pre>
<p>
  ExpressionがObject Type の場合は,Undefined Valueの場合は0,そうでない場合は1が返されます。
</p>

<h3 id="language-exception">Exception</h3>

<ul class="list">
  <li><a href="#language-exception-summary">Exception の概要</a></li>
  <li><a href="#language-exception-occur">例外の発生</a></li>
  <li><a href="#language-exception-catch">Exception Variableのキャッチ</a></li>
  <li><a href="#language-exception-var">Exception Variable</a></li>
</ul>

<h4 id="language-exception-summary">Exception の概要</h4>
<p>
  SPVMはException の仕組みを持っています。Exception は,例外の発生と例外のキャッチからなります。
</p>

<h4 id="language-exception-occur">例外の発生</h4>
<p>
  例外の発生を行うには,die Statement を使用します。
</p>
<pre>
die Expression;
</pre>
<p>
  Expressionは,<a href="#language-type-string-compatible">String Compatible Type</a>でなければなりません。
</p>
<p>
  die Statement が実行されると,スタックトレースとExpressionで指定されたStringを表示して,プログラムは終了します。スタックトレースは,Package Name,Subroutine Name,File Name,行番号を含みます。File Nameは,Moduleをロードしたパスからの相対File Nameです。
</p>
<pre>
Error
from TestCase::Minimal->sum2 at TestCase/Minimal.spvm line 1640
from TestCase->main at TestCase.spvm line 1198
</pre>

<h4 id="language-exception-occur">例外のキャッチ</h4>
<p>
  例外のキャッチとは,例外がスローされた場合に,プログラムが終了するのを止め,エラーメッセージを取得できる機能のことです。
</p>
<p>
  例外のキャッチは,eval BlockStatementを使って行います。eval BlockStatementは,末尾にセミコロンが必要なので気をつけてください。
</p>
<pre>
eval {
  # 例外を投げる可能性のある処理
};
</pre>
<p>
  eval Blockで例外をキャッチした場合は,プログラムの終了は止められ,<a href="#language-exception-var">Exception Variable</a>に<a href="#language-exception-occur">例外の発生</a>で指定したメッセージが代入されます。
</p>

<h4 id="language-exception-var">Exception Variable</h4>
<p>
  Exception Variableは"$@"で表現されるグローバル変数のことです。
</p>
<pre>
$@
</pre>
<p>
  Exception Variableは,本当の意味では,グローバル変数ではありません。Exception Variableは,実は,スレッド変数です。SPVMはシングルスレッド設計なので,Exception Variableは,グローバル変数として振舞うように見えます。ネイティブにおいてスレッドを利用する場合に,違いがあります。
</p>
<p>
  Get Exception Variable Valueについては,<a href="#language-expression-get-exception-var">Get Exception Variable Value</a>を見てください。
</p>
<p>
  Set Exception Variable Valueについては,<a href="#language-expression-set-exception-var">Set Exception Variable Value</a>を見てください。
</p>

<h3 id="language-garbage-collection">Garbage Collection</h3>
<p>
  オブジェクトは,Reference Countが0になるとメモリから解放されます。
</p>
<p>
  オブジェクトが,Object Type の値を要素として持つArrayだった場合は,Garbage Collectionの前に,Undefined ValueではないすべてのArrayの要素のReference Countが1減らされます
</p>
<p>
  オブジェクトが,Class Typeで,Object Type のFieldを持つときは,Garbage Collectionの前に,Undefined ValueではないすべてのObject Type のFieldが所有するオブジェクトのReference Countが1減らされます。Fieldに保存されているオブジェクトにWeaken Referenceが設定されていた場合は,Reference Countが1減らされる前に,Weaken Referenceが解除されます。
</p>
<p>
  オブジェクトがBack references of Weaken Referenceを持つときは,バックReferenceとして登録されているFieldすべてに,Undefined Valueを代入し,バックReferenceをすべて削除します。
</p>
<p>
  上記の処理は,再帰的に行われます。
</p>

<h3 id="language-callback">Callback</h3>

<ul class="list">
  <li><a href="#language-sub-new-callback-object">Create Callback Object</a></li>
  <li><a href="#language-sub-capture">Capture</a></li>
</ul>

<p>
  SPVMにおけるCallback Typeとは,実装を持たない名前のないMethodが一つだけDefinitionされたPackage Typeのことをいいます。<a href="#language-package-definition">Package Definition</a>においてcallback_tDescriptorを指定すると,Callback Typeになります。
</p>
<p>
  Callback Typeの目的は,異なるオブジェクトが,同じMethodDefinitionを持つときに,どちらも代入できるTypeを提供することにあります。C言語の関数ポインタに該当する機能をSPVMにおいて実現するものと考えてください。
</p>
<pre>
package Foo1 {
  sub new : Foo1 () {
    new Foo1;
  }
  sub : int ($self : self, $num : int) {
    return 1 + $num;
  }
}

package Foo2 {
  sub new : Foo2 () {
    new Foo2;
  }
  sub : int ($self : self, $num : int) {
    return 2 + $num;
  }
}

package FooCallback : callback_t {
sub : int ($self : self, $num : int);
}
</pre>

<p>
  Foo1とFoo2は同じMethodDefinition"sub : int ($self : self, $num : int)"を持ちます。ここで,選択的にFoo1またはFoo2のMethodを呼び出したいとします。
</p>
<p>
  この場合に,同じMethodDefinitionを持つCallback TypeFooCallbackをDefinitionすると,このTypeにどちらのオブジェクトも代入できます。そして,このオブジェクトから,Methodを呼び出すことができます。
</p>
<pre>
my $foo1 = Foo1->new;
my $foo2 = Foo2->new;

my $foo : FooCallback;

my $flag = 1;
if ($flag) {
  $foo = $foo1;
}
else {
  $foo = $foo2;
}

my $ret = $foo->(5);
</pre>
<p>
  $flagが1の場合は,Foo1の無名Methodが,そうでない場合はFoo2の無名Methodが呼び出されます。
</p>
<p>
  Callback Typeの詳細については,<a href="#language-type-callback">Callback Type</a>を見てください。
</p>

<h4 id="language-sub-new-callback-object">Create Callback Object</h4>

<p>
  Create Callback Objectとは,Callbackの用途で,特別なsyntax を使って,Callback Typeに適合するオブジェクトを生成するSyntaxのことです。
</p>

<pre>
sub : Type Name  ($self : self, 引数1, 引数2, ..., 引数n) {

}
</pre>

<p>
  Create Callback Objectを行うと,内部的に,<a href="#language-package-definition">Package Definition</a>がおこなわれ,そのPackage を元にしたオブジェクトが生成され,<a href="#language-expression">Expression</a>として返されます。the following ように変数に代入することが可能です。
</p>

<pre>
my $cb_obj = sub : Type Name  ($self : self, 引数1, 引数2, ..., 引数n) {

};
</pre>

<p>
  Create Callback ObjectでDefinitionされるSubroutine は,<a href="#language-sub-method">Method</a>でなければなりません。また名前を持たないSubroutine でなければなりません。
</p>

<p>
  <b>Create Callback ObjectのExample</b>
</p>

<pre>
my $comparator = sub : int ($self : self, $x1 : object, $x2 : object) {

}
</pre>

<p>
  Create Callback Objectによって生成されたオブジェクトは,通常のオブジェクトなので,Methodを呼び出すことができます。Create Callback Objectの呼び出しについては,<a href="#language-expression-callsub">Subroutine Call</a>を見てください。
<p>

<h4 id="language-sub-capture">Capture</h4>
<p>
  Create Callback Objectにおいては,Captureというsyntax を使って,Create Callback ObjectによってDefinitionされたSubroutine の外側でDefinitionされた変数を,Create Callback ObjectによってDefinitionされたSubroutine の内側で使うことができます。
</p>
<pre>
# Capture
[変数名1 : Type1, 変数名2 : Type2] sub Subroutine Name : int ($self : self, $x1 : object, $x2 : object) {

};
</pre>

CaptureのExample。

<pre>
my $foo = 1;
my $bar = 5L;

my $comparator = [$foo : int, $bar : long] sub : int ($self : self, $x1 : object, $x2 : object) {

  print "$foo\n";
  print "$bar\n";
}
</pre>
<p>
  Captureで使用する変数名は,<a href="#language-lex-identifier-field-name">Field Name</a>の先頭に"$"を付けたものでなければなりません。
</p>
<p>
  Captureは,実際には,ClassのFieldとしてDefinitionされます。Captureは,Field Definitionと値の設定のシンタックスシュガーです。
</p>
<p>
  Scope内で,Capture変数と同名の<a href="#language-lex-var">Lexical Variable</a>が存在する場合は,Lexical Variable にアクセスします。
</p>
<p>
  Capture変数と同名の<a href="#language-package-var">Package Variable</a>が存在する場合は,Capture変数にアクセスします。
</p>
<p>
  Create Callback ObjectとCaptureをシンタックスシュガーを使わないで記述すると次のようになります。
</p>

<pre>
package ComapartorImpl {
  has foo : int;
  has bar : long;

  sub : int ($self : self, $x1 : object, $x2 : object) {
    print $self->{foo} . "\n";
    print $self->{bar} . "\n";
  }
}
</pre>

<pre>
my $foo = 1;
my $bar = 5L;

my $comparator = new ComparatorImpl;

$comparator->{foo} = $foo;
$comparator->{bar} = $bar;
</pre>

Captureは,このような長い記述を,短く書くためのSyntaxです。

<h3 id="language-weak-ref">Weaken Reference</h3>
<p>
  Weaken Referenceとは,Reference Countを増やさない参照のことです。Weaken Referenceを使用すると,循環参照の問題を解決することができます。
</p>
<p>
  SPVMは,Reference CountTypeのGCを持ちます。Reference CountTypeのGCにおいては,Reference Countが0になった場合に,オブジェクトは自動的に開放されますが,循環参照が発生した場合は,Reference Countが0にならず,オブジェクトが自動的に解放されません。
</p>
<p>
  オブジェクトのFieldが,循環参照している場合のExampleです。
</p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;

  $foo->{bar} = $bar;
  $bar->{foo} = $foo;
}
</pre>
<p>
  この場合は,Scopeが終了しても,両方のオブジェクトは解放されません。なぜなら,循環参照が発生しており,Reference Countが0にならないためです。
</p>
<p>
  Weaken Referenceは,Reference CountGCを持つプログラミング言語において,循環参照が発生した場合に,オブジェクトの破棄を正しく行うための機能です。
</p>
<p>
  このような場合は,ひとつのFieldを,<a href="#language-Statement-weaken">weaken Statement</a>を使って,Weaken Referenceに設定することで,正しく解放することができます。
</p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;

  $foo->{bar} = $bar;
  $bar->{foo} = $foo;

  weaken $foo->{bar};
}
</pre>
<p>
  weaken Statement が実行される前の,$fooのReference Countは2,$barのReference Countは2です。
</p>
<p>
  もしweaken Statement がない場合は,Scopeが終了したとしても,$fooのReference Countも,$barのReference Countも0にならず,解放されません。
</p>
<p>
  weaken Statement が実行されるとは,$fooのReference Countは2,$barのReference Countは1になります。
</p>
<p>
  Scopeが終了すると,$barのReference Countが1減らされ0になるので,正しく解放されます。
</p>
<p>
  3つの循環参照の場合でも,ひとつのFieldにWeaken Referenceを設定すれば,正しく解放できます。
</p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;
  my $baz = new Baz;

  $foo->{bar} = $bar;
  $bar->{baz} = $baz;
  $baz->{foo} = $foo;

  weaken $foo->{bar};
}
</pre>
<p>
  Weaken Reference関連のSyntaxとして,Weaken Referenceを解除できる<a href="#language-Statement-weaken">weaken Statement</a>と,FieldがWeaken Referenceかどうかを確認できる<a href="#language-expression-operator-isweak">isweak Operator</a>があります。
</p>
