<h2>SPVM 1.0 Language Specification</h2>

Last modified 2020-02-06

<b>SPVM 1.0 language specification</b> is described in this document.

SPVM is in beta testing for the 1.0 release. Language specifications will be changed without warning.

<h2 id="language-c99">C99 compliant</h2><!-- 2019/2/27 almost ok -->
<ul class="list">
  <li><a href="#language-c99-spec">C99 compliant compiler and runtime</a>
  <li><a href="#language-c99-type">Type correspondence with C99</a>
</ul>

<h3 id="language-c99-spec">C99 compliant compiler and runtime</h3><!-- 2019/2/27 almost ok -->

The source code of the SPVM compiler and SPVM runtime is written in C and conforms to C99.

Note that this does not mean that users cannot call the functions of C versions other than C99 (C11, GNU extensions, etc.) or call the functions of C++ from SPVM.

This means that the SPVM compiler and runtime must be C99 compliant.

<h3 id="language-c99-type">Type correspondence with C99</h3><!-- 2019/2/27 almost ok -->

SPVM types are exactly the same as the following C99 types:

<table>
  <tr>
    <th>
      <b> SPVM type </ b>
    </ th>
    <th>
      <b> C99 type </ b>
    </ th>
    <th>
      <b> Description </ b>
    </ th>
  </ tr>
  <tr>
    <td>
      <b> byte </ b>
    </ td>
    <td>
      int8_t
    </ td>
    <td>
      SPVM <a href="#language-type-byte"> byte type</a> matches C99 int8_t type.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> short </ b>
    </ td>
    <td>
      int16_t
    </ td>
    <td>
      SPVM <a href="#language-type-short"> short type</a> matches the C99 int16_t type.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> int </ b>
    </ td>
    <td>
      int32_t
    </ td>
    <td>
      SPVM <a href="#language-type-int"> int type</a> matches the C99 int32_t type.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> long </ b>
    </ td>
    <td>
      int64_t
    </ td>
    <td>
      SPVM <a href="#language-type-long"> long type</a> matches C99 int64_t type.
    </ td>
  </ tr>

<tr>
    <td>
      <b> float </ b>
    </ td>
    <td>
      float
    </ td>
    <td>
      SPVM <a href="#language-type-float"> float type</a> matches the C99 float type.
    </ td>
  <tr>
    <td>
      <b> double </ b>
    </ td>
    <td>
      double
    </ td>
    <td>
      SPVM <a href="#language-type-double"> double type</a> matches C99 double.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> Object type </ b>
    </ td>
    <td>
      void*
    </ td>
    <td>
      SPVM <a href="#language-type-object"> object type</a> matches the C99 void* type.
    </ td>
  </ tr>        
  <tr>
    <td>
      <b> Multiple numeric type </ b>
    </ td>
    <td>
      Numeric array type that matches the type and length in SPVM multiple numeric type fields
    </ td>
    <td>
      <p>
        For example, if SPVM <a href="#language-type-multi-numeric">multiple numeric type</a>
      </ p>
      <p>
        <b>package Point_2i: mulnum_t {has x: int; has y: int;}</b>
      </ p>
      <p>
        matches the type declared in C99
      </ p>
      <p>
        <b>int32_t var[2];</b>
      </p>
    </ td>
  </ tr>
</table>

<h2 id="language-lex">Lexical Analysis</h2>

This topic specifies the Lexical Analysis of the SPVM language.

<ul class="list">
  <li><a href="#language-lex-lalr">LALR(1)</a>
  <li><a href="#language-lex-charset">Character Set</a>
  <li><a href="#language-lex-component">Component</a>
  <li><a href="#language-lex-line-terminator">Line Terminater</a>
  <li><a href="#language-lex-space-character">Space Character</a>
  <li><a href="#language-lex-identifier">Identifier</a>
  <li><a href="#language-lex-separator">Separator</a>
  <li><a href="#language-lex-operator">Operator</a>
  <li><a href="#language-lex-syntax-definition">Syntax Definition</a></li>
</ul>

<h3 id="language-lex-lalr">LALR(1)</h3><!-- 2019/2/27 almost ok -->

SPVM language can be analyzed by the LALR(1). It can be parsed by the parser generator generated by yacc/bison.

<h3 id="language-lex-lalr">Character Set</h3>

SPVM programs are written in UTF-8.

<h3 id="language-lex-component">Component</h3><!-- 2019/2/27 almost ok -->

Component in SPVM is "<a href="#language-lex-space-character">Space Character</a>","<a href="#language-comment">Comment</a>", "<a href="#language-pod">POD</a>", "<a href="#language-literal">Literal</a>", "<a href="#language-lex-identifier">Identifier</a>", "<a href="#language-lex-keyword"> Keyword</a>", "<a href="#language-lex-separator">Separator</a>", or "<a href="#language-lex-operator">Operator</a>".

<h3 id="language-lex-line-terminator">Line Terminator</h3><!-- 2019/7/1 check -->

Line Terminator in SPVM are ASCII Code "LF", "CR", "CRLF".

When a line terminator appears, the line number is incremented.Line Terminator in a program is converted to ASCII Code "LF".

<h3 id="language-lex-space-character">Space Character</h3><!-- 2019/2/27 almost ok -->

Space Character in SPVM is ASCII Code "SP", "HT", "FF" or "<a href="#language-lex-line-terminator">Line Terminator</a>".

Space Character has no meaning in the program execution.

<h3 id="language-lex-identifier">Identifier</h3><!-- 2019/2/27 maybe ok -->

Identifier in SPVM is "Package Name", ""Subroutine Name", "Field Name", "Package Variable Name", or "Lexical Variable Name".

<ul class="list">
  <li><a href="#language-lex-identifier-package-name">Package Name</a></li>
  <li><a href="#language-lex-identifier-sub-name">Subroutine Name</a></li>
  <li><a href="#language-lex-identifier-field-name">Field Name</a></li>
  <li><a href="#language-lex-identifier-package-var-name">Package Variable Name</a></li>
  <li><a href="#language-lex-identifier-lex-var-name">Lexical Variable Name</a></li>
</ul>

<h4 id="language-lex-identifier-package-name">Package Name</h4><!-- 2019/2/27 almost ok -->

Package Name is one or more alphabet(a-zA-Z), number(0-9), underscore(_) or "::" of ASCII Code.

It is not necessary to include "::" in the Package Name.

Package Name must start a uppercase letter in ASCII Code

"::" cannot be continued twice. Last characters cannot end with "::".

Underscore cannot be continued twice.

<pre>
# Valid Package Name
Foo
Foo::Bar
Foo::Bar::Baz3
Foo::bar
Foo_Bar::Baz_Baz

# Invalid Package Name
foo
_Foo
Foo::Bar::
Foo__Bar
</pre>

If Package Name is invalid, a compile-time error occurs.

<h4 id="language-lex-identifier-sub-name">Subroutine Name</h4><!-- 2019/2/27 almost ok -->

Subroutine Name is one or more alphabet(a-zA-Z), number(0-9), or underscore(_) of ASCII Code.

First character must not number character.

Underscore cannot be continued twice.

<pre>
# Valid Subroutine Name
FOO
FOO_BAR3
foo
foo_bar
_foo
_foo_bar_

# Invalid Subroutine Name
foo__bar
</pre>

<h4 id="language-lex-identifier-field-name">Field Name</h4><!-- 2019/2/27 almost ok -->

Field Name is one or more alphabet(a-zA-Z), number(0-9), or underscore(_) of ASCII Code.

First character must not number character.
  
Underscore cannot be continued twice.

<pre>
# Valid Field Name
FOO
FOO_BAR3
foo
foo_bar
_foo
_foo_bar_

# Invalid Field Name
3foo
foo__bar
</pre>

<h4 id="language-lex-identifier-package-var-name">Package Variable Name</h4><!-- 2019/2/27 maybe ok -->

Package Variable Name starts with "$", followed more alphabet(a-zA-Z), number(0-9), underscore(_) or "::" of ASCII Code.

Followed character must not start with number.

"::" cannot be continued twice. Last characters cannot end with "::".

Underscore cannot be continued twice.

<pre>
# Valid Package Variable Name
$FOO::BAR
$Foo::Bar3
$FOO
$FOO_BAR
$foo

# Invalid Package Variable Name
$FOO__BAR
$3FOO

<h4 id="language-lex-identifier-lex-var-name">Lexical Variable Name</h4><!-- 2019/2/27 maybe ok -->

Lexical Variable Name starts with "$", followed more alphabet characters of ASCII Code.

Followed character must not start with number.

Underscore cannot be continued twice.

<pre>
# Valid Lexical Variable Name
$foo
$foo_bar3
$_foo
$FOO

# Invalid Lexical Variable Name
$foo__bar
$3foo
</pre>

<h3 id="language-lex-keyword">Keywords</h3><!-- 2019/2/27 maybe ok -->

Keywords in SPVM are the followings.

<pre>
allow byte BEGIN case die warn print default double elsif else enum eq
eval for float gt ge has if callback_t isa int last break length
lt le long my native ne next new our object package private
public precompile pointer_t return require rw ro self switch
sub string short scalar undef unless use void mulnum_t while
weaken wo __END__ __PACKAGE__ __FILE__ __LINE__
</pre>

<h3 id="language-lex-separator">Separators</h3><!-- 2019/2/27 almost ok -->

Separators in SPVM are the followings.

<pre>
( ) { } [ ] ; , -> =>
</pre>

<h3 id="language-lex-operator">Operators</h3><!-- 2019/2/27 almost ok -->

Operators in SPVM are the followings.

<pre>
=   >   <   !   ~
==  <=  >=  !=  &&  ||  ++  --
+   -   *   /   &   |   ^   %   <<   >>   >>>
+=  -=  *=  /=  &=  |=  ^=  %=  <<=  >>=  >>>=
\   $   @   .   .=
</pre>

<h2 id="language-parsing">Parsing</h2>

<h3 id="language-parsing-syntax-definition">Parsing Definition</h3><!-- 2019/2/27 not ok -->

The following is Parsing Definition in SPVM, using the syntax in yacc/bison. 

<pre>
%token <opval> PACKAGE HAS SUB OUR ENUM MY SELF USE REQUIRE ALLOW
%token <opval> DESCRIPTOR
%token <opval> IF UNLESS ELSIF ELSE FOR WHILE LAST NEXT SWITCH CASE DEFAULT BREAK EVAL
%token <opval> NAME VAR_NAME CONSTANT EXCEPTION_VAR
%token <opval> UNDEF VOID BYTE SHORT INT LONG FLOAT DOUBLE STRING OBJECT
%token <opval> DOT3 FATCAMMA RW RO WO BEGIN NEW
%token <opval> RETURN WEAKEN DIE WARN CURRENT_PACKAGE UNWEAKEN '[' '{' '('

%type <opval> grammar
%type <opval> opt_packages packages package package_block refcnt
%type <opval> opt_declarations declarations declaration
%type <opval> enumeration enumeration_block opt_enumeration_values enumeration_values enumeration_value
%type <opval> sub cb_obj opt_args args arg invocant has use require our string_length
%type <opval> opt_descriptors descriptors sub_names opt_sub_names
%type <opval> opt_statements statements statement if_statement else_statement 
%type <opval> for_statement while_statement switch_statement case_statement default_statement
%type <opval> block eval_block begin_block switch_block if_require_statement
%type <opval> unary_op binary_op num_comparison_op str_comparison_op isa logical_op
%type <opval> call_sub opt_vaarg
%type <opval> array_access field_access weaken_field unweaken_field isweak_field convert array_length
%type <opval> deref ref assign inc dec allow
%type <opval> new array_init
%type <opval> my_var var
%type <opval> expression opt_expressions expressions opt_expression case_statements
%type <opval> field_name sub_name
%type <opval> type basic_type array_type array_type_with_length ref_type  type_or_void

%right <opval> ASSIGN SPECIAL_ASSIGN
%left <opval> LOGICAL_OR
%left <opval> LOGICAL_AND
%left <opval> BIT_OR BIT_XOR
%left <opval> '&'
%nonassoc <opval> NUMEQ NUMNE STREQ STRNE
%nonassoc <opval> NUMGT NUMGE NUMLT NUMLE STRGT STRGE STRLT STRLE ISA
%left <opval> SHIFT
%left <opval> '+' '-' '.'
%left <opval> MULTIPLY DIVIDE REMAINDER
%right <opval> LOGICAL_NOT BIT_NOT '@' REF DEREF PLUS MINUS CONVERT SCALAR LENGTH ISWEAK REFCNT
%nonassoc <opval> INC DEC
%left <opval> ARROW

%%

grammar
: opt_packages

opt_packages
:	/* Empty */
|	packages

packages
: packages package
| package

package
: PACKAGE basic_type package_block
| PACKAGE basic_type ':' opt_descriptors package_block
| PACKAGE basic_type ';'
| PACKAGE basic_type ':' opt_descriptors ';'

package_block
: '{' opt_declarations '}'

opt_declarations
:	/* Empty */
|	declarations

declarations
: declarations declaration
| declaration

declaration
: has
| sub
| enumeration
| our ';'
| use
| allow
| begin_block

begin_block
: BEGIN block

use
: USE basic_type ';'
| USE basic_type '(' opt_sub_names ')' ';'

require
: REQUIRE basic_type

allow
: ALLOW basic_type ';'

enumeration
: opt_descriptors ENUM enumeration_block

enumeration_block 
: '{' opt_enumeration_values '}'

opt_enumeration_values
:	/* Empty */
|	enumeration_values

enumeration_values
: enumeration_values ',' enumeration_value 
| enumeration_values ','
| enumeration_value

enumeration_value
: sub_name
| sub_name ASSIGN CONSTANT

our
: OUR PACKAGE_VAR_NAME ':' opt_descriptors type

has
: HAS field_name ':' opt_descriptors type ';'

sub
: opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' block
| opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' ';'

cb_obj
: opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block
| '[' args ']' opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block

opt_args
:	/* Empty */
|	args
| invocant
| invocant ',' args

args
: args ',' arg
| args ','
| arg

arg
: var ':' type

opt_vaarg
: /* Empty */
| DOT3

invocant
: var ':' SELF

opt_descriptors
:	/* Empty */
|	descriptors

descriptors
: descriptors DESCRIPTOR
| DESCRIPTOR

opt_statements
:	/* Empty */
|	statements

statements
: statements statement 
| statement

statement
: if_statement
| for_statement
| while_statement
| block
| switch_statement
| case_statement
| default_statement
| eval_block
| if_require_statement
| expression ';'
| LAST ';'
| NEXT ';'
| RETURN ';'
| RETURN expression ';'
| DIE ';'
| DIE expression ';'
| WARN ';'
| WARN expression ';'
| PRINT expression ';'
| weaken_field ';'
| unweaken_field ';'
| ';'

for_statement
: FOR '(' opt_expression ';' expression ';' opt_expression ')' block

while_statement
: WHILE '(' expression ')' block

switch_statement
: SWITCH '(' expression ')' switch_block

switch_block
: '{' case_statements '}'
| '{' case_statements default_statement '}'

case_statements
: case_statements case_statement
| case_statement

case_statement
: CASE expression ':' block
| CASE expression ':'

default_statement
: DEFAULT ':' block
| DEFAULT ':'

if_require_statement
: IF '(' require ')' block
| IF '(' require ')' block ELSE block

if_statement
: IF '(' expression ')' block else_statement
| UNLESS '(' expression ')' block else_statement

else_statement
: /* NULL */
| ELSE block
| ELSIF '(' expression ')' block else_statement

block 
: '{' opt_statements '}'

eval_block
: EVAL block ';'

opt_expressions
:	/* Empty */
|	expressions

opt_expression
: /* Empty */
| expression

expression
: var
| EXCEPTION_VAR
| package_var_access
| CONSTANT
| UNDEF
| call_sub
| field_access
| array_access
| convert
| new
| array_init
| array_length
| string_length
| refcnt
| my_var
| binary_op
| unary_op
| ref
| deref
| assign
| inc
| dec
| '(' expressions ')'
| CURRENT_PACKAGE
| isweak_field
| num_comparison_op
| str_comparison_op
| isa
| logical_op

refcnt
: REFCNT var
expressions
: expressions ',' expression
| expressions ','
| expression

unary_op
: '+' expression %prec PLUS
| '-' expression %prec MINUS
| BIT_NOT expression

inc
: INC expression
| expression INC

dec
: DEC expression
| expression DEC

binary_op
: expression '+' expression
| expression '-' expression
| expression MULTIPLY expression
| expression DIVIDE expression
| expression REMAINDER expression
| expression BIT_XOR expression
| expression '&' expression
| expression BIT_OR expression
| expression SHIFT expression
| expression '.' expression

num_comparison_op
: expression NUMEQ expression
| expression NUMNE expression
| expression NUMGT expression
| expression NUMGE expression
| expression NUMLT expression
| expression NUMLE expression

str_comparison_op
: expression STREQ expression
| expression STRNE expression
| expression STRGT expression
| expression STRGE expression
| expression STRLT expression
| expression STRLE expression

isa
: expression ISA type

logical_op
: expression LOGICAL_OR expression
| expression LOGICAL_AND expression
| LOGICAL_NOT expression

assign
: expression ASSIGN expression
| expression SPECIAL_ASSIGN expression

new
: NEW basic_type
| NEW array_type_with_length
| cb_obj

array_init
: '[' opt_expressions ']'

convert
: '(' type ')' expression %prec CONVERT

array_access
: expression ARROW '[' expression ']'
| array_access '[' expression ']'
| field_access '[' expression ']'

call_sub
: NAME '(' opt_expressions  ')'
| basic_type ARROW sub_name '(' opt_expressions  ')'
| basic_type ARROW sub_name
| expression ARROW sub_name '(' opt_expressions ')'
| expression ARROW sub_name
| expression ARROW '(' opt_expressions ')'

field_access
: expression ARROW '{' field_name '}'
| field_access '{' field_name '}'
| array_access '{' field_name '}'

weaken_field
: WEAKEN var ARROW '{' field_name '}'

unweaken_field
: UNWEAKEN var ARROW '{' field_name '}'

isweak_field
: ISWEAK var ARROW '{' field_name '}'

array_length
: '@' expression
| '@' '{' expression '}'
| SCALAR '@' expression
| SCALAR '@' '{' expression '}'

string_length
: LENGTH expression

deref
: DEREF var

ref
: REF var

my_var
: MY var ':' type
| MY var

var
: VAR_NAME

package_var_access
: PACKAGE_VAR_NAME

type
: basic_type
| array_type
| ref_type

basic_type
: NAME
| BYTE
| SHORT
| INT
| LONG
| FLOAT
| DOUBLE
| OBJECT
| STRING

ref_type
: basic_type '&'
array_type
: basic_type '[' ']'
| array_type '[' ']'

array_type_with_length
: basic_type '[' expression ']'
| array_type '[' expression ']'

type_or_void
: type
| VOID

field_name
: NAME

sub_name
: NAME

opt_sub_names
:	/* Empty */
|	sub_names

sub_names
: sub_names ',' sub_name
| sub_names ','
| sub_name
%%
</pre>

The following is a correspondence table between tokens in yacc/bison and keywords and operators in SPVM.

<table>
  <tr>
    <th>Tokens in yacc/bison</th><th>Keywords and Operators in SPVM</th>
  </tr>
  <tr>
    <td>PACKAGE</td><td>package</td>
  </tr>
  <tr>
    <td>SUB</td><td>sub</td>
  </tr>
  <tr>
    <td>OUR</td><td>our</td>
  </tr>
  <tr>
    <td>ENUM</td><td>enum</td>
  </tr>
  <tr>
    <td>MY</td><td>my</td>
  </tr>
  <tr>
    <td>SELF</td><td>self</td>
  </tr>
  <tr>
    <td>USE</td><td>use</td>
  </tr>
  <tr>
    <td>REQUIRE</td><td>require</td>
  </tr>
  <tr>
    <td>ALLOW</td><td>allow</td>
  </tr>
  <tr>
    <td>DESCRIPTOR</td><td>descriptor</td>
  </tr>
  <tr>
    <td>IF</td><td>if</td>
  </tr>
  <tr>
    <td>UNLESS</td><td>unless</td>
  </tr>
  <tr>
    <td>ELSIF</td><td>elsif</td>
  </tr>
  <tr>
    <td>ELSE</td><td>else</td>
  </tr>
  <tr>
    <td>FOR</td><td>for</td>
  </tr>
  <tr>
    <td>WHILE</td><td>while</td>
  </tr>
  <tr>
    <td>LAST</td><td>last</td>
  </tr>
  <tr>
    <td>BREAK</td><td>break</td>
  </tr>
  <tr>
    <td>NEXT</td><td>next</td>
  </tr>
  <tr>
    <td>SWITCH</td><td>switch</td>
  </tr>
  <tr>
    <td>CASE</td><td>case</td>
  </tr>
  <tr>
    <td>DEFAULT</td><td>default</td>
  </tr>
  <tr>
    <td>EVAL</td><td>eval</td>
  </tr>
  <tr>
    <td>NAME</td><td>name</td>
  </tr>
  <tr>
    <td>VAR</td><td>var</td>
  </tr>
  <tr>
    <td>CONSTANT</td><td>Literal </td>
  </tr>
  <tr>
    <td>PACKAGE_VAR_NAME</td><td>Package Variable Name</td>
  </tr>
  <tr>
    <td>EXCEPTION_VAR</td><td>$@</td>
  </tr>
  <tr>
    <td>UNDEF</td><td>undef</td>
  </tr>
  <tr>
    <td>VOID</td><td>void</td>
  </tr>
  <tr>
    <td>BYTE</td><td>byte</td>
  </tr>
  <tr>
    <td>SHORT</td><td>short</td>
  </tr>
  <tr>
    <td>INT</td><td>int</td>
  </tr>
  <tr>
    <td>LONG</td><td>long</td>
  </tr>
  <tr>
    <td>FLOAT</td><td>float</td>
  </tr>
  <tr>
    <td>DOUBLE</td><td>double</td>
  </tr>
  <tr>
    <td>STRING</td><td>string</td>
  </tr>
  <tr>
    <td>OBJECT</td><td>object</td>
  </tr>
  <tr>
    <td>DOT3</td><td>...</td>
  </tr>
  <tr>
    <td>FATCAMMA</td><td>=></td>
  </tr>
  <tr>
    <td>RW</td><td>rw</td>
  </tr>
  <tr>
    <td>RO</td><td>ro</td>
  </tr>
  <tr>
    <td>WO</td><td>wo</td>
  </tr>
  <tr>
    <td>BEGIN</td><td>BEGIN</td>
  </tr>
  <tr>
    <td>NEW</td><td>new</td>
  </tr>
  <tr>
    <td>RETURN</td><td>return</td>
  </tr>
  <tr>
    <td>WEAKEN</td><td>weaken</td>
  </tr>
  <tr>
    <td>DIE</td><td>die</td>
  </tr>
  <tr>
    <td>WARN</td><td>warn</td>
  </tr>
  <tr>
    <td>PRINT</td><td>print</td>
  </tr>
  <tr>
    <td>CURRENT_PACKAGE</td><td>__PACKAGE__</td>
  </tr>
  <tr>
    <td>UNWEAKEN</td><td>unweaken</td>
  </tr>
  <tr>
    <td>ASSIGN</td><td>=</td>
  </tr>
  <tr>
    <td>SPECIAL_ASSIGN</td><td>+=  -=  *=  /=  &=  |=  ^=  %=  &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;= .=</td>
  </tr>
  <tr>
    <td>LOGICAL_OR</td><td>||</td>
  </tr>
  <tr>
    <td>LOGICAL_AND</td><td>&&</td>
  </tr>
  <tr>
    <td>BIT_OR</td><td>|</td>
  </tr>
  <tr>
    <td>BIT_XOR</td><td>&</td>
  </tr>
  <tr>
    <td>NUMEQ</td><td>==</td>
  </tr>
  <tr>
    <td>NUMNE</td><td>!=</td>
  </tr>
  <tr>
    <td>STREQ</td><td>eq</td>
  </tr>
  <tr>
    <td>STRNE</td><td>ne</td>
  </tr>
  <tr>
    <td>NUMGT</td><td>&gt;</td>
  </tr>
  <tr>
    <td>NUMGE</td><td>&gt;=</td>
  </tr>
  <tr>
    <td>NUMLT</td><td>&lt;</td>
  </tr>
  <tr>
    <td>NUMLE</td><td>&lt;=</td>
  </tr>
  <tr>
    <td>STRGT</td><td>gt</td>
  </tr>
  <tr>
    <td>STRGE</td><td>ge</td>
  </tr>
  <tr>
    <td>STRLT</td><td>lt</td>
  </tr>
  <tr>
    <td>STRLE</td><td>le</td>
  </tr>
  <tr>
    <td>ISA</td><td>isa</td>
  </tr>
  <tr>
    <td>SHIFT</td><td>&lt;&lt;  &gt;&gt;  &gt;&gt;&gt;</td>
  </tr>
  <tr>
    <td>MULTIPLY</td><td>*</td>
  </tr>
  <tr>
    <td>DIVIDE</td><td>/</td>
  </tr>
  <tr>
    <td>REMAINDER</td><td>%</td>
  </tr>
  <tr>
    <td>LOGICAL_NOT</td><td>!</td>
  </tr>
  <tr>
    <td>BIT_NOT</td><td>~</td>
  </tr>
  <tr>
    <td>REF</td><td>\</td>
  </tr>
  <tr>
    <td>DEREF</td><td>$</td>
  </tr>
  <tr>
    <td>PLUS</td><td>+</td>
  </tr>
  <tr>
    <td>MINUS</td><td>-</td>
  </tr>
  <tr>
    <td>CONVERT</td><td>(TypeName)</td>
  </tr>
  <tr>
    <td>SCALAR</td><td>scalar</td>
  </tr>
  <tr>
    <td>LENGTH</td><td>length</td>
  </tr>
  <tr>
    <td>ISWEAK</td><td>isweak</td>
  </tr>
  <tr>
    <td>REFCNT</td><td>refcnt</td>
  </tr>
  <tr>
    <td>INC</td><td>++</td>
  </tr>
  <tr>
    <td>DEC</td><td>--</td>
  </tr>
  <tr>
    <td>ARROW</td><td>-></td>
  </tr>
</table>

<h2 id="language-comment">Comment</h2>

Comment begins with "#" and ends with <a href="#language-lex-line-terminator">Line Terminator</a>.

<pre>
# Comment
</pre>

Comment has no meaning in the program execution.

<h2 id="language-pod">POD</h2>

POD(Plain Old Document) is a syntax to write documents easily.

You can use POD as Multi-Line comments.

POD starts from the line beginning with "=", followed by any character string of one or more characters, and ending with <a href="#language-lex-line-terminator">Line Terminator</a>.

POD ends from the line beginning with "=cut", and ending with <a href="#language-lex-line-terminator">Line Terminator</a>.

<b>POD Example:</b>

<pre>
=pod

Multi-Line
Comment

=cut
</pre>

<pre>
=head1

Multi-Line
Comment

=cut
</pre>

POD has no meaning in the program execution.

<h2 id="language-package">Package</h2>
<ul class="list">
  <li><a href="#language-package-definition">Package Definition</a></li>
  <li><a href="#language-package-descriptor">Package Descriptor</a></li>
  <li><a href="#language-package-destructor">Destructor</a></li>
</ul>

<h3 id="language-package-definition">Package Definition</h3>

Package Definition is the following syntax.

<pre>
package PACAKGE_NAME {

}
</pre>

PACAKGE_NAME must follow the rule for <a href="#language-lex-identifier-package-name">Package Name</a>.

<a href="#language-package-descriptor">Package Descriptor</a> can be specified by the following syntax.

<pre>
package PACAKGE_NAME : PACAKGE_DESCRIPTOR {

}

package PACAKGE_NAME : PACAKGE_DESCRIPTOR1 PACAKGE_DESCRIPTOR2 PACAKGE_DESCRIPTORN {

}
</pre>

<b>Package Definition Example:</b>

<pre>
# Package Name
package Point {

}
</pre>

<pre>
# Package Name and Package Descriptor
package Point : public {

}
</pre>

In direct children of the package block, <a href="#language-module-use">use</a>, "<a href="#language-package-var-definition">our</a>, <a href="#language-field-definition">has</a>, <a href="#language-enum-definition">enum</a>, <a href="#language-sub-definition">sub</a> can be defined.

<pre>
package Foo {
  # use
  use Point;

  # Package Variable Definition
  our $VAR int;

  # Field Defintion
  has var : int;

  # Enumeration Definition
  enum {
    CONST_VAL1,
    CONST_VAL2,
  }

  # Subroutine Definition
  sub foo : int ($num : int) {

  }
}
</pre>

<h3 id="language-package-descriptor">Package Descriptor</h3>

The descriptions of Package Descriptors.

<table>
  <tr>
    <th>
      Descriptor Name
    </th>
    <th>
      Meaning
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      This package is public. Other packages can <a href="#language-expression-new-object">new</a> this package.
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      This package is private. Other packages can't <a href="#language-expression-new-object">new</a> this package. This is default setting.
    </td>
  </tr>
  <tr>
    <td>
      <b>callback_t</b>
    </td>
    <td>
      This package is <a href="#language-type-callback">Callback Type</a>.
    </td>
  </tr>
  <tr>
    <td>
      <b>mulnum_t</b>
    </td>
    <td>
      This package is <a href="#language-type-multi-numeric">Multi Numeric Type</a>.
    </td>
  </tr>
  <tr>
    <td>
      <b>pointer_t</b>
    </td>
    <td>
      This package is <a href="#language-type-pointer">Pointer Type</a>.
    </td>
  </tr>
</table>

If both "public" and "private" are specifed, a compile-time error occurs.

If more than one of "callback_t", "mulnum_t", "pointer_t" are specified, a compile-time error occurs.

<h3 id="language-package-destructor">Destructor</h3>

If the package is <a href="#language-type-class">Class Type</a>, the package defined a destructor.

Destructor is a special <a href="#language-sub">Subroutine</a> called when the object of this class is freed.

Destructor name must be "DESTROY".

Destructor Retrun Value must be <a href="#language-type-void">void type</a>, otherwise a compile-time error occurs.

Destructor arguments must be one and the type must be <a href="#language-type-self">self type</a>, otherwise a compile-time error occurs.

<pre>
sub DESTROY : void ($self : self) {

}
</pre>

If a <a href="#language-exception-occur">Exception</a> occurs in Destructor, the program don't exit, print the message of the exception to STDERR.

<b>Destructor Example:</b>

<pre>
package Foo {
  sub new : Foo {
    return new Foo;
  }

  sub DESTROY : void ($self : self) {
    print "DESTROY";
  }
}
</pre>

<h2 id="language-module">Module</h2>
<ul class="list">
  <li><a href="#language-module-summary">Module Summary</a></li>
  <li><a href="#language-module-file-name">Module File Name</a></li>
  <li><a href="#language-module-use">Module Loading</a></li>
  <li><a href="#language-module-if-require">Selective Module Loading</a></li>
</ul>

<h3 id="language-module-summary">Module Summary</h3>

Module is a single file that can be read as SPVM source code.

<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}
</pre>


Module can contain multiple Packages.

<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}

package Foo::Bar::Baz {

}
</pre>

<h3 id="language-module-file-name">Module File Name</h3>

Modules must be placed in the module loading path with the following File Name.

Change "::" to "/". Add ".spvm" at the end.

<pre>
Foo.spvm
Foo/Bar.spvm
Foo/Bar/Baz.spvm
</pre>

<h3 id="language-module-use">Module Loading</h3>

Use use keyword to load a Module.

<pre>
use Foo;
use Foo::Bar;
</pre>


Modules are loaded at compile-time.


If the Module does not exist, a compile-time error will occur.


use Keyword must be defined directly under <a href="#language-package-definition">Package Definition</a>.

<pre>
package Foo {
  use Foo;
}
</pre>

<h3 id="language-module-if-require">Selective Module Loading</h3>

In SPVM, there is an if require statement that loads a Module only if it exists in the module path, and if it does not exist, the block does not exist.

It was designed to implement a part of features of "#ifdef" in C language.

<pre>
if (require Foo) {

}
</pre>

if require statement can be followed by else statement. 

<pre>
if (require Foo) {

}
else {

}
</pre>

Note that elsif statement cannot be followed.


Let's look at an example. if Foo does not exist, no compile-time error occurs and it is assumed that there is no if block

Therefore, "$foo = new Foo;" does not result in a compile-time error because it is assumed that there is no if block.

In the other hand, the else block exists, so a warning is issued.

<pre>
my $foo : object;
if (require Foo) {
  $foo = new Foo;
}
else {
  warn "Warning: Can't load Foo";
}
</pre>

<h2 id="language-allow-access">Access Allowing</h2>

By default, private Subroutines, Fields, and Package Variables cannot be accessed from outside the Package.

Also, Private Package cannot <a href="#language-expression-new-object">Create Object</a> from outside of Package.


If the package allow other package, the other package can access private Subroutines, Fields, and Package Variables, and can <a href="#language-expression-new-object">Create Object</a> of the package.

<pre>
allow PACKAGE_NAME;
</pre>


allow must be defined directory under <a href="#language-package-definition">Package Definition</a>.

<pre>
package Foo {
  allow Bar;
}
</pre>

In this example, Bar can access the private Subroutine, Field, and Package Variable of Foo can be accessed and can Create Object of Foo.

<h2 id="language-package-var">Package Variable </h2>
<ul class="list">
  <li><a href="#language-package-var-definition">Package Variable Definition</a></li>
  <li><a href="#language-package-var-initial-value">Package Variable Initial Value</a></li>
  <li><a href="#language-package-var-access">Package Variable Access</a></li>
</ul>
<h3 id="language-package-var-definition">Package Variable Definition</h3>
<p>
  Package Variable とは,Package に属する,プログラムの開始から終了まで維持されるグローバル変数のことです。
</p>
<p>
  "our"  Keyword を使用してPackage Variable を定義することができます。
</p>
<pre>
our Package Variable Name : Type Name ;
</pre>
<p>
  Package Variable Definitionは"<a href="#language-package-definition">Package Definition</a>"の直下で行う必要があります。
</p>
<p>
  Package Variable Definitionには"<a href="#language-type">Type Name</a>"が必要です。Type Name には"numeric type"と"object type "を指定できます。
</p>
<p>
  Package Variable Nameは,<a href="#language-lex-identifier-package-var-name">Package Variable Name</a>で定義されている名前の規則に従い,かつ"::"が含まれていてはいけません。otherwise a compile-time error occurs.
</p>
<p>
  Package Variable 定義には,Descriptorを合わせて指定することができます。複数のDescriptorを空白を使って並べることができます。
</p>
<pre>
our Package Variable Name : Descriptor Type Name ;
</pre>
<p>
  <b>Package Variable Descriptor</b>
</p>
<p>
  Package Variable で指定できるDescriptorの一覧です。
</p>
<table>
  <tr>
    <th>
      Descriptor Name
    </th>
    <th>
      役割
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      このPackage Variable は,外部のPackage からアクセスできます。
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      このPackage Variable は,外部のPackage からアクセスできません。デフォルトの設定です。
    </td>
  </tr>
  <tr>
    <td>
      <b>ro</b>
    </td>
    <td>
      このPackage Variable は,読み込み用のPackage Variable アクセッサを持ちます。Package Variable アクセッサ名は,Package Variable Nameから"$"を除いたものです。Package Variable Nameが"$FOO"の場合は,Package Variable アクセッサ名は"FOO"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>wo</b>
    </td>
    <td>
      このPackage Variable は,書き込み用のPackage Variable アクセッサを持ちます。Package Variable アクセッサ名は,"SET_Package Variable Nameから$を除いたもの"になります。Package Variable Nameが"$FOO"の場合は,Package Variable アクセッサ名は"SET_FOO"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>rw</b>
    </td>
    <td>
      このPackage Variable は,読み込み用のPackage Variable アクセッサと書き込み用のPackage Variable アクセッサを持ちます。読み込み用のPackage Variable アクセッサ名は"ro"で説明したものと同じです。書き込み用のPackage Variable アクセッサ名は"wo"で説明したものと同じです。
    </td>
  </tr>
</table>
<p>
  "public"と"private"の両方のDescriptorが指定された場合は,a compile-time error occurs
</p>
<p>
  "ro""wo""rw"のひとつより多くが同時に指定されている場合は,a compile-time error occurs
</p>
<p>
  Package Variable アクセッサとは,Package Variable にアクセスするためのクラスメソッドのことです。
</p>
<p>
  書き込み用のPackage Variable アクセッサのReturn Valueは"void type"です。
</p>
<p>
  SPVMのソースコードの中からPackage Variable アクセッサが呼び出された場合は,Package Variable アクセッサはInline Expansionされます。それ以外の場合は,Inline Expansionされません。
</p>
<p>
  <b>Package Variable 定義のExample</b>
</p>
<p>
  Package Variable 定義のExampleです。
</p>
<pre>
package Foo {
  our $NUM1 : byte;
  our $NUM2 : short;
  our $NUM3 : int;
  our $NUM4 : long;
  our $NUM5 : float;
  our $NUM6 : double;

  our $NUM_PUBLIC : public int;
  our $NUM_RO : ro int;
  our $NUM_WO : wo int;
  our $NUM_RW : rw int;
}
</pre>
<h3 id="language-package-var-initial-value">Package Variable Initial Value</h3>
<p>
  Package Variable は,コンパイルが終了して,実行時に入る前に,<a href="#language-type-initial-value">Type Initial Value</a>で初期化されます。
</p>
<p>
  この初期値は,<a href="#language-begin-block">BEGIN Block</a>を使うことで,変更することができます。
</p>
<pre>
package Foo {
  our $VAR : int;

  BEGIN {
    $VAR = 3;
  }
}
</pre>
<h3 id="language-package-var-access">Package Variable Access</h3>
<p>
  Package Variable Accessとは,Package Variable にアクセスして,値を取得したり,設定したりする操作のことです。
</p>
<p>
  Package Variable の値の取得については,<a href="#language-expression-get-package-var">Package Variable の値の取得</a>を見てください。
</p>
<p>
  Package Variable の値の設定については,<a href="#language-expression-set-package-var">Package Variable の値の設定</a>を見てください。
</p>

<h2 id="language-field">フィールド</h2>
<ul class="list">
  <li><a href="#language-field-definition">Field Definition</a></li>
  <li><a href="#language-field-access">Field Access</a></li>
</ul>
<h3 id="language-field-definition">Field Definition</h3>
<p>
  フィールドとは"new"を使ってオブジェクト生成した場合に,オブジェクトからアクセスできるデータ領域のことです。
</p>
<p>
  "has"  Keyword を使用してフィールドを定義することができます。
</p>
<pre>
has Field Name : Type Name ;
</pre>
<p>
  フィールド定義は"<a href="#language-package-definition">Package Definition</a>"の直下で行う必要があります。
</p>
<p>
  フィールド定義には"<a href="#language-type">Type Name</a>"が必要です。Type Name には"numeric type"と"object type "を指定できます。
</p>
<p>
  Field Nameは,1文字以上の"a～z""A～Z""0～9""_"で構成する必要があります。先頭は,数字から始めることはできません。連続した"_"を使用することはできません。
</p>
<p>
  Field Nameには,<a href="#language-lex-keyword"> Keyword</a>と同じ名前を使用することができます。
</p>
<p>
  フィールド定義には,Descriptorを合わせて指定することができます。複数のDescriptorを空白を使って並べることができます。
</p>
<pre>
has Field Name : Descriptor Type Name ;
</pre>
<p>
  <b>フィールドDescriptor</b>
</p>
<p>
  フィールドで指定できるDescriptorの一覧です。
</p>
<table>
  <tr>
    <th>
      Descriptor Name
    </th>
    <th>
      役割
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      このフィールドは,外部のPackage からアクセスできます。
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      このフィールドは,外部のPackage からアクセスできません。デフォルトの設定です。
    </td>
  </tr>
  <tr>
    <td>
      <b>ro</b>
    </td>
    <td>
      このフィールドは,読み込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は,Field Nameと同じです。Field Nameが"foo"の場合は,フィールドアクセッサ名は"foo"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>wo</b>
    </td>
    <td>
      このフィールドは,書き込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は,"set_Field Name"になります。Field Nameが"foo"の場合は,フィールドアクセッサ名は"set_foo"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>rw</b>
    </td>
    <td>
      このフィールドは,読み込み用のフィールドアクセッサと書き込み用のフィールドアクセッサを持ちます。読み込み用のフィールドアクセッサ名は"ro"で説明したものと同じです。書き込み用のフィールドアクセッサ名は"wo"で説明したものと同じです。
    </td>
  </tr>
</table>
<p>
  "public"と"private"の両方のDescriptorが指定された場合は,a compile-time error occurs
</p>
<p>
  "ro""wo""rw"のひとつより多くが同時に指定されている場合は,a compile-time error occurs
</p>
<p>
  フィールドアクセッサとは,フィールドにアクセスするためのメソッドのことです。
</p>
<p>
  書き込み用のフィールドアクセッサのReturn Valueは"void type"です。
</p>
<p>
  SPVMのソースコードの中からフィールドアクセッサが呼び出された場合は,フィールドアクセッサはInline Expansionされます。それ以外の場合は,Inline Expansionされません。
</p>
<p>
  <b>フィールド定義のExample</b>
</p>
<p>
  フィールド定義のExampleです。
</p>
<pre>
package Foo {
  has num1 : byte;
  has num2 : short;
  has num3 : int;
  has num4 : long;
  has num5 : float;
  has num6 : double;

  has num_public : public int;
  has num_ro : ro int;
  has num_wo : wo int;
  has num_rw : rw int;
}
</pre>
<h3 id="language-field-access">Field Access</h3>
<p>
  Field Accessとは,フィールドにアクセスして,値を取得したり,設定したりする操作のことです。また,the following 記述そのものを指します。
</p>
<pre>
Invocant ->{Field Name}
</pre>
<p>
  Field Accessは,一種類のsyntax で,三つの異なる意味を持ちます。
</p>
<p>
  <b>1. Class TypeのField Access</b>
</p>
<p>
  <a href="#language-type-class">Class Type</a>を元に<a href="#language-expression-new-object">Object Creating</a>が行われた場合は,オブジェクトからフィールドにアクセスすることができます。
</p>
<pre>
my $point = new Point;
$point->{x} = 1;
</pre>

<p>
  Class Typeのフィールドの取得については,<a href="#language-expression-get-field-class">Class Typeのフィールドの値の取得</a>を見てください。
</p>
<p>
  Class Typeのフィールドの設定については,<a href="#language-expression-set-field-class">Class Typeのフィールドの値の設定</a>を見てください。
</p>
<p>
  <b>2. Multi Numeric TypeのField Access</b>
</p>
<p>
  2. <a href="#language-type-multi-numeric">Multi Numeric Type</a>におけるフィールドは,Multi Numeric Typeの変数の宣言をすれば,その変数からフィールドにアクセスできます。これは,Lexical Variable 領域におけるアクセスです。
</p>
<pre>
my $z : SPVM::Complex_2d;
$z->{re} = 1;
$z->{im} = 3;
</pre>
<p>
  Multi Numeric Typeのフィールドの取得については,<a href="#language-expression-get-field-multi-numeric">Multi Numeric Typeのフィールドの値の取得</a>を見てください。
</p>
<p>
  Multi Numeric Typeのフィールドの設定については,<a href="#language-expression-set-field-multi-numeric">Multi Numeric Typeのフィールドの値の設定</a>を見てください。
</p>
<p>
  <b>3. Dereference によるMulti Numeric Typeのフィールドのアクセス</b>
</p>
<p>
  Multi Numeric Typeの変数に対するreference type から,Dereference を行って直接にMulti Numeric Typeのフィールドにアクセスできます。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{re} = 1;
$z_ref->{im} = 3;
</pre>
<p>
  Dereference によるMulti Numeric Typeのフィールドの取得については,<a href="#language-expression-get-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの取得</a>を見てください。
</p>
<p>
  Dereference によるMulti Numeric Typeのフィールドの設定については,<a href="#language-expression-set-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの設定</a>を見てください。
</p>

<h2 id="language-sub">Subroutine </h2>
<ul class="list">
  <li><a href="#language-sub-definition">Subroutine Definition</a></li>
  <li><a href="#language-sub-constant">Constant Subroutine</a></li>
  <li><a href="#language-sub-new-callback-object">コールバックObject Creating</a></li>
  <li><a href="#language-sub-capture">キャプチャ</a></li>
  <li><a href="#language-sub-method">メソッド</a></li>
  <li><a href="#language-sub-signature">シグネチャ</a></li>
  <li><a href="#language-sub-invocant">Invocant</a></li>
  <li><a href="#language-sub-stack">Subroutine Callstack</a></li>
</ul>
<h3 id="language-sub-definition">Subroutine Definition</h3>
<p>
  "sub"  Keyword を使用してSubroutine を定義することができます。
</p>
<pre>
sub Subroutine Name : Return ValueのType Name  (引数名1 : 引数のType Name 1, 引数名2 : 引数のType Name 2, 以下続く) {

}
</pre>
<p>
  Subroutine Definitionは"<a href="#language-package-definition">Package Definition</a>"の直下で行う必要があります。
</p>
<p>
  Subroutine Nameは,1文字以上の"a～z""A～Z""0～9""_"で構成する必要があります。先頭は,数字から始めることはできません。連続した"_"を使用することはできません。
</p>
<p>
  Subroutine Nameには,<a href="#language-lex-keyword"> Keyword</a>と同じ名前を使用することができます。
</p>
<p>
  戻りのType Name には,"void type""numeric type""object type "を指定することができます。
</p>
<p>
  Subroutine Definitionには"Return ValueのType Name "と"0個以上の引数の定義"が必要です。"引数の定義"は"引数名"と"引数のType Name "からなります。
</p>
<p>
  引数名は,変数名でなければなりません。
</p>
<p>
  引数のType Name には,"numeric type""object type ""reference type "を指定することができます。
</p>

<p>
  Subroutine Blockの中には,0個以上のステートメントを記述できます。
</p>

<p>
  Subroutine Definitionには,Descriptorを合わせて指定することができます。複数のDescriptorを空白を使って並べることができます。
</p>
<pre>
Descriptor Name sub Subroutine Name : Return ValueのType Name  (引数の変数名1 : 引数のType Name 1, 引数の変数名2 : 引数のType Name 2, 以下続く) {

}
</pre>
<p>
  <b>Subroutine Descriptor</b>
</p>
<p>
  Subroutine で指定できるDescriptorの一覧です。
</p>
<table>
  <tr>
    <th>
      Descriptor Name
    </th>
    <th>
      役割
    </th>
  </tr>
  <tr>
    <td>
      <b>native</b>
    </td>
    <td>
      このSubroutine は,ネイティブSubroutine です。
    </td>
  </tr>
  <tr>
    <td>
      <b>precompile</b>
    </td>
    <td>
      このSubroutine はプリコンパイルされます。
    </td>
  </tr>
</table>
<p>
  "native"と"precompile"の両方のDescriptorが指定された場合は,a compile-time error occurs
</p>

<p>
  引数のType Name の後ろに"..."を続けると,可変長引数となります。最後の引数のみ可変長引数にすることができます。
</p>
<pre>
# 可変長引数の定義
sub Subroutine Name : Return ValueのType Name  (引数名1 : 引数のType Name 1, 引数名2 : 引数のType Name 2...) {

}
</pre>
<p>
  <b>可変長引数のExample</b>
</p>
<p>
  可変長引数のExampleです。
</p>
<pre>
# 可変長引数を持つSubroutine Definition
sub sprintf : string ($format : string, $values : object[]...) {

}

# 可変長引数を持つSubroutine Call
foo("aaa %d %f", SPVM::Int->new(1), SPVM::Double->new(2.0));
</pre>
<p>
  可変長引数を持つSubroutine に配列を渡すと,配列のまま呼び出す事ができます。
</p>
<pre>
foo("aaa %d %f", [(object)SPVM::Int->new(1), SPVM::Double->new(2.0)]);
</pre>
<p>
  もし,array typeの値を,可変長引数の個々の要素として扱いたい場合は,array typeではない型にキャストしてください。
</p>
<pre>
foo("aaa %d %f", (object)[(object)SPVM::Int->new(1), SPVM::Double->new(2.0)]);
</pre>

<p>
  定義されたSubroutine は,呼び出すことができます。Subroutine Callについては,<a href="language-expression-callsub">Subroutine Call</a>を見てください。
</p>

<h3 id="language-sub-constant">Constant Subroutine </h3>
<p>
  numeric typeのReturn Valueを持つSubroutine で,Return Valueが定数であるSubroutine をConstant Subroutine といいます。
</p>
<pre>
sub foo : int () { return 5; }
sub foo : long () { return 5L; }
sub foo : float () { return 5.0f; }
sub foo : double () { return 5.0; }
</pre>
<p>
  Constant Subroutine は,Inline Expansionされます。
</p>
<p>
  SPVMは定数畳み込み最適化を行わないので,定数が演算されている場合は,Constant Subroutine にならず,Inline Expansionされないことに注意してください。
</p>
<pre>
# Constant Subroutine ではなくInline Expansionされない
sub foo : int () { return 5 + 3; }
</pre>

<h3 id="language-sub-new-callback-object">コールバックObject Creating</h3>
<p>
  コールバックObject Creatingとは,コールバックの用途で,特別なsyntax を使って,Callback Typeに適合するオブジェクトを生成する文法のことです。
</p>
<pre>
sub : Type Name  ($self : self, 引数1, 引数2, ..., 引数n) {

}
</pre>
<p>
  コールバックObject Creatingを行うと,内部的に,Package Definitionがおこなわれ,そのPackage を元にしたオブジェクトが生成され,<a href="#language-expression">式</a>として返されます。the following ように変数に代入することが可能です。
</p>
<pre>
my $cb_obj = sub : Type Name  ($self : self, 引数1, 引数2, ..., 引数n) {

};
</pre>
<p>
  コールバックObject Creatingで定義されるSubroutine は,<a href="#language-sub-method">メソッド</a>でなければなりません。また名前を持たないSubroutine でなければなりません。
</p>
<p>
  <b>コールバックObject CreatingのExample</b>
</p>
<pre>
my $comparator = sub : int ($self : self, $x1 : object, $x2 : object) {

}
</pre>
<p>
  コールバックObject Creatingによって生成されたオブジェクトは,通常のオブジェクトなので,メソッドを呼び出すことができます。コールバックObject Creatingの呼び出しについては,<a href="language-expression-callsub">Subroutine Call</a>を見てください。
<p>

<h3 id="language-sub-capture">キャプチャ</h3>
<p>
  コールバックObject Creatingにおいては,キャプチャというsyntax を使って,コールバックObject Creatingによって定義されたSubroutine の外側で定義された変数を,コールバックObject Creatingによって定義されたSubroutine の内側で使うことができます。
</p>
<pre>
# キャプチャ
[変数名1 : 型1, 変数名2 : 型2] sub Subroutine Name : int ($self : self, $x1 : object, $x2 : object) {

};
</pre>

キャプチャのExample。

<pre>
my $foo = 1;
my $bar = 5L;

my $comparator = [$foo : int, $bar : long] sub : int ($self : self, $x1 : object, $x2 : object) {

  print "$foo\n";
  print "$bar\n";
}
</pre>
<p>
  キャプチャで使用する変数名は,<a href="#language-lex-identifier-field-name">Field Name</a>の先頭に"$"を付けたものでなければなりません。
</p>
<p>
  キャプチャは,実際には,クラスのフィールドとして定義されます。キャプチャは,Field Definitionと値の設定のシンタックスシュガーです。
</p>
<p>
  スコープ内で,キャプチャ変数と同名の<a href="#language-lex-var">Lexical Variable</a>が存在する場合は,Lexical Variable にアクセスします。
</p>
<p>
  キャプチャ変数と同名の<a href="#language-package-var">Package Variable</a>が存在する場合は,キャプチャ変数にアクセスします。
</p>
<p>
  コールバックObject Creatingとキャプチャをシンタックスシュガーを使わないで記述すると次のようになります。
</p>
<pre>
package ComapartorImpl {
  has foo : int;
  has bar : long;

  sub : int ($self : self, $x1 : object, $x2 : object) {

  print $self->{foo} . "\n";
  print $self->{bar} . "\n";
  }
}
</pre>

</pre>
my $foo = 1;
my $bar = 5L;

my $comparator = new ComparatorImpl;

$comparator->{foo} = $foo;
$comparator->{bar} = $bar;
</pre>

キャプチャは,このような長い記述を,短く書くための文法です。

<h3 id="language-sub-method">メソッド</h3>
<p>
  メソッドとは,第一引数に<a href="#language-type-self">self type</a>を持つSubroutine のことです。
</p>
<pre>
sub Subroutine Name : Type Name  ($self : self, 引数1 : 型1, 引数2 : 型2, ..., 引数n : 型n) {

}
</pre>
<p>
  メソッドは,<a href="#language-expression-new-object">Object Creating</a>によって生成されたオブジェクトから呼び出すことができます。Method Call については,<a href="language-expression-callsub">Subroutine Call</a>を見てください。
</p>

<h3 id="language-sub-invocant">Invocant </h3>
<p>
  Invocant とは,self typeが指定された第一引数のことをいいます。
</p>
<pre>
sub Subroutine Name : Type Name  ($self : self, 引数1 : 型1, 引数2 : 型2, ..., 引数n : 型n) {

}
</pre>
<p>
  上記の例では$selfは,Invocant と呼ばれます。
</p>

<h3 id="language-sub-signature">シグネチャ</h3>
<p>
  シグネチャとは,Subroutine Retrun Valueと引数を次の規則で並べたものをいいます。引数は,存在しなくても構いません。間に空白を含むことはできません。
</p>
<p>
  1. Return ValueのType Name 
</p>
<p>
  2. (
</p>
<p>
  3. 引数1,引数2, 引数3, 引数n
</p>
<p>
  4. )
</p>
<p>
  シグネチャのExampleです。
</p>
<pre>
# Subroutine 定義
sub foo : int ($num1 : double, $num2 : long[])

# シグネチャ
int(double,long[])

# Subroutine 定義
sub foo : void ()

# シグネチャ
void()
</pre>
<p>
  シグネチャは,SPVMを記述しているときには,意識する必要はありません。ネイティブからSPVMのSubroutine を呼び出すときに使用します。
</p>

<h3 id="language-sub-stack">Subroutine Callstack</h3>
<p>
  Subroutine Callstackとは,<a href="#language-expression-callsub">Subroutine Call</a>が行われるときに,確保されるメモリ領域のことを指します。
</p>
<p>
  Subroutine Callstackには,the following 情報が保存されます。
</p>
<p>
  1. <a href="#language-lex-var">Lexical Variable</a>のためのメモリ領域
</p>
<p>
  2. モータル変数の場所
</p>

<h2 id="language-enum">列挙</h2>
<ul class="list">
  <li>
    <a href="#language-enum-definition">Enumeration Definition</a>
  </li>
  <li>
    <a href="#language-enum-call">列挙の呼び出し</a>
  </li>
</ul>
<h3 id="language-enum-definition">Enumeration Definition</h3>
<p>
  列挙はint type の定数を定義したい場合に利用します。連続したint type の定数を簡単に定義できます。"enum"  Keyword を使って定義します。
</p>
<pre>
enum {
  FLAG1,
  FLAG2,
  FLAG3
}
</pre>
<p>
  Enumeration Definitionは"<a href="#language-package-definition">Package Definition</a>"の直下で行う必要があります。
</p>
<pre>
package Foo {
  enum {
    FLAG1,
    FLAG2,
    FLAG3
  }
}
</pre>

<p>
  最初の値は"0"から始まります。値は"1"づつインクリメントされます。この例の場合は"FLAG1"は"0","FALG2"は"1","FLAG3は"2"になります。
</p>
<p>
  列挙の末尾の要素の後ろには","をつけることができます。
</p>
<pre>
enum {
  FLAG1,
  FLAG2,
  FLAG3,
}
</pre>
<p>
  列挙はint type をReturn Valueとする"Constant Subroutine "のエイリアスです。次のSubroutine Definitionと等価です。
</p>
<pre>
sub FLAG1 : int () { return 0; }
sub FLAG2 : int () { return 1; }
sub FLAG3 : int () { return 2; }
</pre>
<p>
  enumの要素には,int type の値を設定することができます。
</p>
<pre>
enum {
  FLAG1,
  FLAG2 = 4,
  FLAG3,
}
</pre>
<p>
  上記の場合は"FLAG1"は"0","FALG2"は"4","FLAG3"は"5"になります。
</p>
<p>
  enumの定義がInvalid 場合は,a compile-time error occurs
</p>

<p>
  <b>列挙Descriptor</b>
</p>
<p>
  列挙には,Descriptorを指定することができます。
</p>
<pre>
private enum {
  FLAG1,
  FLAG2 = 4,
  FLAG3,
}
</pre>
<p>
  列挙で指定できるDescriptorの一覧です。
</p>
<table>
  <tr>
    <th>
      Descriptor Name
    </th>
    <th>
      役割
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      この列挙は,外部のPackage からアクセスできます。デフォルトの設定です。
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      この列挙は,外部のPackage からアクセスできません。
    </td>
  </tr>
</table>
<p>
  "public"と"private"の両方のDescriptorが指定された場合は,a compile-time error occurs
</p>

<h3 id="language-enum-call">列挙の呼び出し</h3>
<p>
  列挙は,Constant Subroutine のエイリアスなので,Subroutine 呼び出しとまったく同じ方法で呼び出すことができます。
</p>
<pre>
my $flag1 = Foo->FLAG1;
my $flag2 = Foo->FLAG2;
my $flag3 = Foo->FLAG3;
</pre>
<p>
  switch statementのcase statementにおいて利用することもできます。
</p>
<pre>
switch ($num) {
  case Foo->FLAG1: {

    break;
  }
  case Foo->FLAG2: {

    break:
  }
  case Foo->FLAG3: {

    break:
  }
  default: {

  }
}
</pre>
<h2 id="language-begin-block">BEGIN Block </h2>
<p>
  BEGIN Block とは,コンパイル時が終了し,実行時に入る前に,実行されるブロックのことです。
</p>
<p>
  BEGIN  Keyword を使用してBEGIN Block を定義することができます。
</p>
<pre>
BEGIN {

}
</pre>
<p>
  BEGIN Block は,Package Definitionの直下にある必要があります。
</p>
<pre>
package Foo {
  BEGIN {

  }
}
</pre>
<p>
  BEGIN Block の中には,0個以上の<a href="#language-statement">文</a>を書くことができます。
</p>
<pre>
BEGIN {
  my $foo = 1 + 1;
  my $bar;
}
</pre>
<p>
  returnl statementを書くことはできません。BEGIN Block は,引数がなく,Return ValueがvoidのSubroutine として定義されます。
</p>
<p>
  BEGIN Block は,いくつでも定義できます。
</p>
<p>
  BEGIN Block の実行順序は,保証されません。他のPackage にBEGIN Block が定義されている場合は,そのBEGIN Block が先に実行されることを想定しないでください。
</p>
<p>
  BEGIN Block の一般的な用途は,<a href="#language-package-var">Package Variable</a>を初期化することです。
</p>
<pre>
package Foo {
  our $NUM : int;
  our $POINT : Point;
  BEGIN {
  $NUM = 3;
    $POINT = Point->new;
  }
}
</pre>

<h2 id="language-lex-var">Lexical Variable </h2>
<ul class="list">
  <li><a href="#language-lex-var-declaration">Lexical Variable Declaration</a></li>
  <li><a href="#language-lex-var-initial-value">Lexical Variable Initial Value</a></li>
  <li><a href="#language-lex-var-access">Lexical Variable Access</a></li>
</ul>
<h3 id="language-lex-var-declaration">Lexical Variable Declaration </h3>
<p>
  Lexical Variable とは,<a href="#language-scope-block">Scope Block</a>の中で利用できる,<a href="#language-scope">スコープ</a>を持つ変数のことです。C言語のローカル変数に該当します。
</p>
<pre>
{
  my $num : int;
}
</pre>
<p>
  Lexical Variable は"my"  Keyword によって宣言します。":"の後ろに"<a href="#language-type">型</a>"を指定する必要があります。
</p>
<pre>
my $num : int;
</pre>
<p>
  Lexical Variable is initialized by <a href="#language-lex-var-initial-value">Lexical Variable Initial Value</a>.
</p>
<pre>
# 0で初期化される
my $num : int;

# 0で初期化される
my $num : double;

# undefで初期化される
my $point : Point;

# reは0, imは0で初期化される
my $z : SPVM::Complex_2d;
</pre>
<p>
  Lexical Variable Declaration と同時に初期化を行うことができます。
</p>
<pre>
# 1で初期化される
my $num : int = 1;

# 2.5で初期化される
my $num : double = 2.5;

# Pointオブジェクトで初期化される
my $point : Point = new Point;
</pre>
<p>
  <a href="#language-type-inference">型推論</a>を使うと,宣言するときに,型の指定を省略することができます。
</p>
<pre>
# int
my $num = 1;

# double
my $num = 1.0;
</pre>
<p>
  Lexical Variable Declaration は,Lexical Variable の値を返します。これは,<a href="#language-expression">式</a>として利用できます。
</p>
<pre>
my $ppp = my $bar = 4;

if (my $bar = 1) {

}

while (my $bar = 1) {

}
</pre>

<p>
  Lexical Variable Declaration は,Lexical Variable が<a href="#language-type-object">object type</a>であった場合に,Lexical Variable を,モータル変数として,実行時に登録します。モータル変数として登録されたLexical Variable に代入されているオブジェクトは,<a href="#language-scope">スコープ</a>の末尾で,Reference Countが自動的に1減らされます。
</p>

<h3 id="language-lex-var-initial-value">Lexical Variable Initial Value</h3>
<p>
  Lexical Variable is initialized by <a href="#language-type-initial-value">Type Initial Value</a>.
</p>

<h3 id="language-lex-var-access">Lexical Variable Access</h3>
<p>
  Lexical Variable Accessとは,Lexical Variable にアクセスして,値を取得したり,設定したりする操作のことです。
</p>
<p>
  <b>Lexical Variable の値の取得</b>については,<a href="#language-expression-get-lex-var">Lexical Variable の値の取得</a>を見てください。
</p>
<p>
  <b>Lexical Variable の値の設定</b>については,<a href="#language-expression-set-lex-var">Lexical Variable の値の設定</a>を見てください。
</p>
<p>
  Lexical Variable と同名の<a href="#language-package-var">Package Variable</a>が存在した場合は,Lexical Variable にアクセスします。
</p>

<h2 id="language-block">ブロック</h2>
<p>
  "{"と"}"で囲まれた部分のことをブロックと呼びます。
</p>
<pre>
# ブロック
{

}
</pre>
<p>
  ブロックの中には,スコープを作る<a href="#language-scope-block">Scope Block</a>があります。
</p>

<h2 id="language-scope">スコープ</h2>
<ul class="list">
  <li><a href="#language-scope-role">スコープの役割</a>
  <li><a href="#language-scope-block">Scope Block</a>
</ul>

<h3 id="language-scope-role">スコープの役割</h3>
<p>
  スコープとは<a href="#language-scope-block">Scope Block</a>に囲まれた範囲のことをいいます。
</p>
<pre>
# Scope Block 
{

}
</pre>
<p>
  スコープの中で宣言されたLexical Variable は,実行時に,宣言されている位置で,モータルなLexical Variable として登録されます。
</p>
<pre>
{
  # Lexical Variable をモータルとして登録
  my $num = new Foo;
}
</pre>
<p>
  モータルなLexical Variable に代入されたオブジェクトが,Undefined Valueではない場合は,Reference Countが1増やされます。
</p>
<p>
  スコープの終わりに到達すると,モータルなLexical Variable に代入されているオブジェクトは,Undefined Valueでない場合,Reference Countが1減らされ,0になった場合は,解放されます。
</p>
<h3 id="language-scope-block">Scope Block </h3>
<p>
  Scope Block とは,スコープを作るブロックのことです。Scope Block には,0個以上の<a href="#language-statement">文</a>を記述することができます。
</p>
<pre>
# Scope Block 
{
  my $num = 1;
  $num++;
}
</pre>
<p>
  <b>Scope Block の一覧</b>
<p>
<ul class="list">
  <li><a href="#language-block-statement-simple">Simple Block</a></li>
  <li><a href="#language-block-statement-sub">Subroutine Block</a></li>
  <li><a href="#language-block-statement-eval">evalブロック</a></li>
  <li><a href="#language-block-statement-if">ifブロック</a></li>
  <li><a href="#language-block-statement-elsif">elsifブロック</a></li>
  <li><a href="#language-block-statement-else">elseブロック</a></li>
  <li><a href="#language-block-statement-for">forブロック</a></li>
  <li><a href="#language-block-statement-while">whileブロック</a></li>
  <li><a href="#language-block-statement-switch">switchブロック</a></li>
</ul>

<h4 id="language-block-statement-simple">Simple Block</h4>
<pre>
# Simple Block
{

}
</pre>

<h4 id="language-block-statement-sub">Subroutine Block</h4>
<pre>
# Subroutine Block
sub foo : int () {

}
</pre>

<h4 id="language-block-statement-eval">evalブロック</h4>
<pre>
# evalブロック
eval {

}
</pre>

<h4 id="language-block-statement-if">ifブロック</h4>
<pre>
# ifブロック
if (式) {

}
</pre>

<h4 id="language-block-statement-elsif">elsifブロック</h4>
<pre>
#elsifブロック
elsif (式) {

}
</pre>

<h4 id="language-block-statement-else">elseブロック</h4>
<pre>
# elseブロック
else {

}
</pre>

<h4 id="language-block-statement-for">forブロック</h4>
<pre>
# for ブロック
for (my $i = 0; $i < 3; $i++) {

}
</pre>

<h4 id="language-block-statement-while">whileブロック</h4>
<pre>
# whileブロック
while (式) {

}
</pre>

<h4 id="language-block-statement-switch">switchブロック</h4>
<pre>
switch (式) {

}
</pre>
<h2 id="language-warn">警告</h2>
<h3 id="language-exception-summary">警告を発生させる</h3>
<p>
  警告を発生させるにはwarn文を使用します。
</p>
<pre>
warn 式;
</pre>
<p>
  式は,<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
  末尾が改行文字"\n"であった場合は,標準エラー出力に式で指定されている文字列が出力されます。
</p>
<p>
  末尾が改行文字でない場合は,末尾にFile Nameと行番号が追加され,標準エラー出力されます。
</p>
<p>
  式で指定された文字列の長さが0あるいは,Undefined Valueであった場合は,指定されたメッセージが"Warning: something's wrong"であるとしてふるまいます。
</p>
<p>
  標準エラー出力のバッファがフラッシュされます。
</p>

<h2 id="language-print">print文</h2>
<p>
  標準出力に文字列を出力するにはprint文を使用します。
</p>
<pre>
print 式;
</pre>
<p>
  式は,<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
  式がUndefined Valueであった場合は,何もしません。
</p>

<h2 id="language-exception">Exception Handling </h2>
<ul class="list">
  <li><a href="#language-exception-summary">Exception Handling の概要</a></li>
  <li><a href="#language-exception-occur">例外の発生</a></li>
  <li><a href="#language-exception-catch">例外変数のキャッチ</a></li>
  <li><a href="#language-exception-var">例外変数</a></li>
</ul>

<h3 id="language-exception-summary">Exception Handling の概要</h3>
<p>
  SPVMはException Handling の仕組みを持っています。Exception Handling は,例外の発生と例外のキャッチからなります。
</p>

<h3 id="language-exception-occur">例外の発生</h3>
<p>
  例外の発生を行うには,die statement を使用します。
</p>
<pre>
die 式;
</pre>
<p>
  式は,<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
  die statement が実行されると,スタックトレースと式で指定された文字列を表示して,プログラムは終了します。スタックトレースは,Package Name,Subroutine Name,File Name,行番号を含みます。File Nameは,Moduleをロードしたパスからの相対File Nameです。
</p>
<pre>
Error
from TestCase::Minimal->sum2 at TestCase/Minimal.spvm line 1640
from TestCase->main at TestCase.spvm line 1198
</pre>

<h3 id="language-exception-occur">例外のキャッチ</h3>
<p>
  例外のキャッチとは,例外がスローされた場合に,プログラムが終了するのを止め,エラーメッセージを取得できる機能のことです。
</p>
<p>
  例外のキャッチは,evalブロック文を使って行います。evalブロック文は,末尾にセミコロンが必要なので気をつけてください。
</p>
<pre>
eval {
  # 例外を投げる可能性のある処理
};
</pre>
<p>
  evalブロックで例外をキャッチした場合は,プログラムの終了は止められ,<a href="#language-exception-var">例外変数</a>に<a href="#language-exception-occur">例外の発生</a>で指定したメッセージが代入されます。
</p>

<h3 id="language-exception-var">例外変数</h3>
<p>
  例外変数は"$@"で表現されるグローバル変数のことです。
</p>
<pre>
$@
</pre>
<p>
  例外変数は,本当の意味では,グローバル変数ではありません。例外変数は,実は,スレッド変数です。SPVMはシングルスレッド設計なので,例外変数は,グローバル変数として振舞うように見えます。ネイティブにおいてスレッドを利用する場合に,違いがあります。
</p>
<p>
  例外変数の値の取得については,<a href="#language-expression-get-exception-var">例外変数の値の取得</a>を見てください。
</p>
<p>
  例外変数の値の設定については,<a href="#language-expression-set-exception-var">例外変数の値の設定</a>を見てください。
</p>

<h2 id="language-weak-ref">Weaken Reference</h2>
<p>
  Weaken Referenceとは,Reference Countを増やさない参照のことです。Weaken Referenceを使用すると,循環参照の問題を解決することができます。
</p>
<p>
  SPVMは,Reference Count型のGCを持ちます。Reference Count型のGCにおいては,Reference Countが0になった場合に,オブジェクトは自動的に開放されますが,循環参照が発生した場合は,Reference Countが0にならず,オブジェクトが自動的に解放されません。
</p>
<p>
  オブジェクトのフィールドが,循環参照している場合のExampleです。
</p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;

  $foo->{bar} = $bar;
  $bar->{foo} = $foo;
}
</pre>
<p>
  この場合は,スコープが終了しても,両方のオブジェクトは解放されません。なぜなら,循環参照が発生しており,Reference Countが0にならないためです。
</p>
<p>
  Weaken Referenceは,Reference CountGCを持つプログラミング言語において,循環参照が発生した場合に,オブジェクトの破棄を正しく行うための機能です。
</p>
<p>
  このような場合は,ひとつのフィールドを,<a href="#language-statement-weaken">weaken statement</a>を使って,Weaken Referenceに設定することで,正しく解放することができます。
</p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;

  $foo->{bar} = $bar;
  $bar->{foo} = $foo;

  weaken $foo->{bar};
}
</pre>
<p>
  weaken statement が実行される前の,$fooのReference Countは2,$barのReference Countは2です。
</p>
<p>
  もしweaken statement がない場合は,スコープが終了したとしても,$fooのReference Countも,$barのReference Countも0にならず,解放されません。
</p>
<p>
  weaken statement が実行されるとは,$fooのReference Countは2,$barのReference Countは1になります。
</p>
<p>
  スコープが終了すると,$barのReference Countが1減らされ0になるので,正しく解放されます。
</p>
<p>
  3つの循環参照の場合でも,ひとつのフィールドにWeaken Referenceを設定すれば,正しく解放できます。
</p>
<pre>
{
  my $foo = new Foo;
  my $bar = new Bar;
  my $baz = new Baz;

  $foo->{bar} = $bar;
  $bar->{baz} = $baz;
  $baz->{foo} = $foo;

  weaken $foo->{bar};
}
</pre>
<p>
  Weaken Reference関連の文法として,Weaken Referenceを解除できる<a href="#language-statement-weaken">weaken statement</a>と,フィールドがWeaken Referenceかどうかを確認できる<a href="#language-operator-isweak">isweakOperator</a>があります。
</p>

<h2 id="language-callback">コールバック</h2>
<p>
  SPVMにおけるCallback Typeとは,実装を持たない名前のないメソッドが一つだけ定義されたPackage 型のことをいいます。<a href="#language-package-definition">Package Definition</a>においてcallback_tDescriptorを指定すると,Callback Typeになります。
</p>
<p>
  Callback Typeの目的は,異なるオブジェクトが,同じメソッド定義を持つときに,どちらも代入できる型を提供することにあります。C言語の関数ポインタに該当する機能をSPVMにおいて実現するものと考えてください。
</p>
<pre>
package Foo1 {
  sub new : Foo1 () {
    new Foo1;
  }
  sub : int ($self : self, $num : int) {
    return 1 + $num;
  }
}

package Foo2 {
  sub new : Foo2 () {
    new Foo2;
  }
  sub : int ($self : self, $num : int) {
    return 2 + $num;
  }
}

package FooCallback : callback_t {
sub : int ($self : self, $num : int);
}
</pre>

<p>
  Foo1とFoo2は同じメソッド定義"sub : int ($self : self, $num : int)"を持ちます。ここで,選択的にFoo1またはFoo2のメソッドを呼び出したいとします。
</p>
<p>
  この場合に,同じメソッド定義を持つCallback TypeFooCallbackを定義すると,この型にどちらのオブジェクトも代入できます。そして,このオブジェクトから,メソッドを呼び出すことができます。
</p>
<pre>
my $foo1 = Foo1->new;
my $foo2 = Foo2->new;

my $foo : FooCallback;

my $flag = 1;
if ($flag) {
  $foo = $foo1;
}
else {
  $foo = $foo2;
}

my $ret = $foo->(5);
</pre>
<p>
  $flagが1の場合は,Foo1の無名メソッドが,そうでない場合はFoo2の無名メソッドが呼び出されます。
</p>
<p>
  Callback Typeの詳細については,<a href="#language-type-callback">Callback Type</a>を見てください。
</p>

<h2 id="language-array">配列</h2>
<ul class="list">
  <li><a href="#language-array-summary">Array Summary</a></li>
  <li><a href="#language-array-new">Array Creating</a></li>
  <li><a href="#language-array-access">Array Access</a></li>
</ul>
<h3 id="language-array-summary">Array Summary</h3>
<p>
  配列とは,複数の値の連続領域を表現するためのデータ構造です。
</p>
<p>
  配列には次の種類があります。
</p>
<ul class="list">
  <li>
    numeric typeの配列
  </li>
  <li>
    object type の配列
  </li>
  <li>
    Multi Numeric Typeの配列
  </li>
</ul>
<p>
  numeric typeの配列とは,<a href="#language-type-numeric">numeric type</a>の値が連続に並んだ配列のことです。
</p>
<p>
  object type の配列とは,<a href="#language-type-object">object type</a>の値が連続に並んだ配列のことです。
</p>
<p>
  Multi Numeric Typeの配列とは,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値が連続に並んだ配列のことです。
</p>

<h3 id="language-array-summary">Array Creating</h3>
<p>
  配列を生成については,<a href="#language-expression-new-array">Array Creating</a>を見てください。
</p>

<h3 id="language-array-access">Array Access</h3>
<p>
  Array Accessとは,配列にアクセスして,値を取得したり,設定したりする操作のことです。また,the following 記述そのものを指します。
</p>
<pre>
配列->[添え字]
</pre>

<p>
  配列の取得については,<a href="#language-expression-get-array-element">配列の要素の値の取得</a>を見てください。
</p>
<p>
  配列の設定については,<a href="#language-expression-set-set-array-element">配列の要素の値の設定</a>を見てください。
</p>

<h2 id="language-value">値</h2>
<ul class="list">
  <li><a href="#language-value-definition">Multi Numeric Typeの定義</a></li>
  <li><a href="#language-value-usage">Multi Numeric Typeの使用</a></li>
  <li><a href="#language-value-access">Multi Numeric TypeのField Access</a></li>
</ul>

<h3 id="language-value-definition">Multi Numeric Typeの定義</h2>
<p>
  SPVMには,他の言語ではあまり見ることのない値というものがあります。
</p>
<p>
  値は,連続した数値を表現します。たとえば,連続した32bit符号付整数が3つであるとか,連続した倍精度浮動小数点が2つなどです。3次元の点,複素数,四元数などを表現することが想定されています。
</p>
<p>
  値を使用するには,最初に,Multi Numeric Typeを定義します。Multi Numeric Typeは,<a href="#language-package-definition">Package Definition</a>において,mulnum_tDescriptorを指定することで定義できます。
</p>
<pre>
# 連続した32bit符号付整数が3つ
package Point_3i : mulnum_t {
  has x : int;
  has y : int;
  has z : int;
}

連続した倍精度浮動小数点が2つ
package Complex_2d : mulnum_t {
  x : double;
  y : double;
}
</pre>
<p>
  すべてのフィールドは同じ<a href="#language-type-numeric">numeric type</a>でなければなりません。
</p>
<p>
  Multi Numeric Typeの末尾は"_""フィールドの個数""Multi Numeric Typeのサフィックス"でなければなりません。
</p>
<p>
  <b>Multi Numeric Typeのサフィクスの一覧</b>
</p>
<table>
  <tr>
    <th>
      <b>numeric type</b>
    </th>
    <th>
      サフィックス
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      b
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      s
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      i
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      l
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      f
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      d
    </td>
  </tr>
</table>
<p>
  サフィックスは,実際に定義されているnumeric typeと対応している必要があります。
</p>
<p>
  numeric typeの定義において,フィールドの個数の最大は16です。
</p>
<p>
  Invalid Multi Numeric Typeの定義の場合は,a compile-time error occurs
</p>
<p>
  Multi Numeric Typeは,<a href="#language-lex-var-declaration">Lexical Variable Declaration</a>の型として利用することができます。
</p>
<p>
  Multi Numeric Typeは,<a href="#language-sub-definition">Subroutine Definition</a>における引数の型として利用することができます。
</p>
<p>
  Multi Numeric Typeは,<a href="#language-sub-definition">Subroutine Definition</a>におけるReturn Valueの型として利用することができます。
</p>
<p>
  Multi Numeric Typeは<a href="#language-type-array">array type</a>の<a href="#language-type-basic">基本型</a>として利用することができます。
</p>
<pre>
my $points = new Point_3i[5];
</pre>
<p>
  Multi Numeric Typeは,フィールドの型として利用することはできません。
</p>
<p>
  Multi Numeric Typeは,Package Variable の型として利用することはできません。
</p>
<p>
  Multi Numeric Typeの値に対しては,リファレンスを生成することができます。
</p>
<pre>
my $point : Point_3i;
my $point_ref = \$point;
</pre>
<p>
  Multi Numeric Typeの値に,Undefined Valueを代入することはできません。代入しようとした場合は,a compile-time error occurs
</p>

<h2 id="language-value-array">値の配列</h2>
<ul class="list">
  <li><a href="language-array-summary">値のArray Summary</a></li>
  <li><a href="language-array-access">値のArray Access</a></li>
</ul>

<h3 id="language-array-summary">値のArray Summary</h3>
<p>
  Multi Numeric Typeの値は,<a href="#language-array">配列</a>にすることができます。
</p>
<pre>
my $points = new Point_3i[5];

my $zs = new Complex_2d[5];
</pre>
<p>
  値の配列は,Multi Numeric Typeの値が,連続したデータ構造をとります。配列の要素は,オブジェクトではなく,数値がメモリ上に一直線に並んで,配置されます。
</p>
<p>
  たとえば,Point_3i型の5の長さの配列であれば,Point_3i型は,int type の数値が3つ並んだ型で,長さが5なので,"5 * 3 = 15"個のint type の数値が,メモリ上に一直線に並んだデータになります。
</p>
<p>
  値の配列の型は,<a href="#language-type-array">array type</a>です。
</p>
<p>
  値の配列の要素の型は,<a href="#language-type-multi-numeric">Multi Numeric Type</a>です。
</p>

<h3 id="language-array-access">値のArray Access</h3>
<p>
  値のArray Accessとは,値の配列にアクセスして,値を取得したり,設定したりする操作のことです。また,the following 記述そのものを指します。
</p>
<pre>
配列->[添え字]
</pre>
<p>
  値のArray Accessは,配列のアクセスと同じsyntax で行うことができます。
</p>
<p>
  配列の取得については,<a href="#language-expression-get-array-element">配列の要素の値の取得</a>を見てください。
</p>
<p>
  配列の設定については,<a href="#language-expression-set-set-array-element">配列の要素の値の設定</a>を見てください。
</p>

<h3 id="language-value-usage">Multi Numeric Typeの使用</h2>
<p>
  Multi Numeric Typeを使用するにはuse文を使って,Moduleをロードします。
</p>
<pre>
use Point_3i;
use Complex_2d;
</pre>
<p>
  次に,Lexical Variable Declaration を行います。Lexical Variable Declaration を行うと,連続した領域が,<a href="#language-sub-stack">Subroutine Callstack</a>上に確保されます。フィールドのすべての値は,<a href="language-type-initial-value">Type Initial Value</a>で初期化されます。
</p>
<pre>
my $point : Point_3i;
my $z : Complex_2d;
</pre>
<p>
  Multi Numeric Typeの値は,オブジェクトではないので,<a href="#language-expression-new-object">Object Creating</a>のsyntax では生成できないことに注意してください。
</p>

<h3 id="language-value-access">Multi Numeric TypeのField Access</h2>
<p>
  Multi Numeric TypeのField Accessとは,Multi Numeric Typeのフィールドにアクセスして,値を取得したり,設定したりする操作のことです。また,the following 記述そのものを指します。
</p>
<pre>
Invocant ->{Field Name}
</pre>
<p>
  Multi Numeric Typeのフィールドの取得については,<a href="#language-expression-get-field-multi-numeric">Multi Numeric Typeのフィールドの値の取得</a>を見てください。
</p>
<p>
  Multi Numeric Typeのフィールドの設定については,<a href="#language-expression-set-field-multi-numeric">Multi Numeric Typeのフィールドの値の設定</a>を見てください。
</p>
<p>
  <b>Multi Numeric Typeのフィールドの値の取得・設定のExample</b>
</p>
<p>
  Multi Numeric Typeのフィールドの値の取得・設定のExampleです。
</p>
<pre>
$ival2->{x} = 1;
my $y = $ival2->{y};

$dval4->{t} = 2.5;
my $z = $dval4->{z};
</pre>

<h2 id="language-ref">リファレンス</h2>
<ul>
  <li><a href="language-ref-summary">リファレンスの概要</a></li>
  <li><a href="language-ref-deref">Dereference</a></li>
</ul>

<h3 id="language-ref">リファレンスの概要</h3>
<p>
  リファレンスとは,Lexical Variable のアドレスのことをいいます。リファレンスは,C言語のポインタに該当する機能を実現するために,設計されました。
</p>
<p>
  Lexical Variable のアドレスは,<a href="#language-operator-ref">Reference Operator</a>を使用して取得できます。<a href="#language-type-ref">reference type</a>は,<a href="#language-type-numeric">numeric type</a>あるいは<a href="#language-type-multi-numeric">Multi Numeric Type</a>の後ろに"&"を続けたものになります。
</p>
<pre>
# numeric typeの変数のリファレンス
my $num : int;
my $num_ref : int& = \$num;

# Multi Numeric Typeの変数のリファレンス
my $point : Point_3d;
my $point_ref : Point_3d& = \$point;
</pre>
<p>
  $num_refの値は,Lexical Variable "$num"のアドレスになります。$point_refの値は,Lexical Variable "$point"のアドレスになります。
</p>
<p>
  Reference Operator  の対象は,<a href="#language-type-numeric">numeric type</a>あるいは<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値が格納された変数だけです。object type の変数や定数に対して,使うことはできません。
</p>
<p>
  <a href="#language-type-ref">reference type</a>の値は,Subroutine Argumentsとして利用することができます。
</p>
<pre>
# Subroutine Definition
sub sum : void ($out_ref : int&, $in1 : int, $in2 : int) {
  $$out_ref = $in1 + $in2;
}

# Subroutine の利用
my $num1 = 1;
my $num2 = 2;
my $out : int;
my $out_ref = \$out;
sum($out_ref, $num1, $num2);
</pre>

<h3 id="language-ref-deref">Dereference </h3>
<p>
  Dereference とは,アドレスの場所にあるLexical Variable の値を取得・設定する操作をいいます。
</p>
<p>
  Dereference することで,アドレスを通して値を取得したり,変更することができます。
</p>
<pre>
# numeric typeの値を取得
my $num2 = $$num_ref;

# numeric typeの値を変更
$$num_ref = 3;

# Multi Numeric Typeの値を取得
my $point2 = $$point_ref;

# Multi Numeric Typeの値を設定
$$point_ref = $point2;
</pre>

<p>
  reference type の対象がMulti Numeric Typeであった場合に,Multi Numeric Typeのフィールドの設定と取得は,アローOperator で行うことができます。
</p>
<pre>
# reference type の対象がMulti Numeric Typeであった場合に,Multi Numeric Typeのフィールドを取得
my $x = $point_ref->{x};

# reference type の対象がMulti Numeric Typeであった場合に,Multi Numeric Typeのフィールドを設定
$point_ref->{x} = 1;
</pre>

<h3 id="language-type-ref-numeric">数値のreference type </h3>
<p>
  数値のreference type とは,<a href="#language-type-numeric">numeric type</a>の変数に対する<a href="#language-type-ref">reference type</a>のことをいいます。
</p>
<h3 id="language-type-ref-multi-numeric">複数数値のreference type </h3>
<p>
  複数数値のreference type とは,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の変数に対する<a href="#language-type-ref">reference type</a>のことをいいます。
</p>

</p>

<h2 id="language-expression">式</h2>
<ul class="list">
  <li class="language-expression-summary">式とは</li>
  <li class="language-expression-current-package">Current Package Nameの取得</li>
  <li class="language-expression-current-file">Current File Nameの取得</li>
  <li class="language-expression-current-line">Current Line Numberの取得</li>
</ul>

<h3 id="language-expression">式とは</h3>
<p>
  式とは,値の評価が可能な<a href="#language-expresssion">式</a>のことです。
</p>
<p>
  <b>式の一覧</b>
</p>
<ul class="list">
  <li><a href="#language-expression-get-lex-var">Lexical Variable の値の取得</a></li>
  <li><a href="#language-expression-set-lex-var">Lexical Variable の値の設定</a></li>
  <li><a href="#language-expression-get-package-var">Package Variable の値の設定</a></li>
  <li><a href="#language-expression-set-package-var">Package Variable の値の取得</a></li>
  <li><a href="#language-expression-get-exception-var">例外変数の値の設定</a></li>
  <li><a href="#language-expression-set-exception-var">例外変数の値の取得</a></li>
  <li><a href="#language-literal">Literal</a></li>
  <li><a href="#language-undef">Undefined Value</a></li>
  <li><a href="#language-expression-callsub">Subroutine Call</a></li>
  <li><a href="#language-expression-get-field-class">Class Typeのフィールドの値の取得</a></li>
  <li><a href="#language-expression-set-field-class">Class Typeのフィールドの値の設定</a></li>
  <li><a href="#language-expression-get-field-multi-numeric">Multi Numeric Typeのフィールドの値の取得</a></li>
  <li><a href="#language-expression-set-field-multi-numeric">Multi Numeric Typeのフィールドの値の設定</a></li>
  <li><a href="#language-expression-get-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの取得</a></li>
  <li><a href="#language-expression-set-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの設定</a></li>
  <li><a href="#language-expression-get-array-element">配列の要素の値の取得</a></li>
  <li><a href="#language-expression-set-array-element">配列の要素の値の設定</a></li>
  <li><a href="#language-expression-typecast">型キャスト</a></li>
  <li><a href="#language-expression-new-object">Object Creating</a></li>
  <li><a href="#language-expression-new-array">Array Creating</a></li>
  <li><a href="#language-expression-release-object">オブジェクトの解放</a></li>
  <li><a href="#language-expression-array-init">Array Initialization</a></li>
  <li><a href="#language-operator-array-length">Array Length Operator</a></li>
  <li><a href="#language-operator-string-length">String Length Operator</a></li>
  <li><a href="#language-operator-arithmetic">Arithmetic Operator</a></li>
  <li><a href="#language-operator-bit">Bit Operator</a></li>
  <li><a href="#language-operator-shift">Shift Operator</a></li>
  <li><a href="#language-operator-concat">文字列連結Operator</a></li>
  <li><a href="#language-operator-ref">Reference Operator</a></li>
  <li><a href="#language-operator-assign">Assignment Operator</a></li>
  <li><a href="#language-operator-array-length">Array Length Operator</a></li>
  <li><a href="#language-operator-string-length">String Length Operator</a></li>
  <li><a href="#language-operator-scalar">Scalar Operator</a></li>
  <li><a href="#language-expression-current-package">Current Package Nameの取得</a></li>
  <li><a href="#language-expression-current-file">Current File Nameの取得</a></li>
  <li><a href="#language-expression-current-line">Current Line Numberの取得</a></li>
  <li>(式)</li>
</ul>

<h3 id="language-expression-get-lex-var">Lexical Variable の値の取得</h3>
<p>
  Lexical Variable の値の取得をするには,Lexical Variable 自体を記述します。
</p>
<pre>
$var
</pre>
<p>
  Lexical Variable の値の取得は,<a href="#language-expression">式</a>です。
</p>

<h3 id="language-expression-set-lex-var">Lexical Variable の値の設定</h3>
<p>
  Lexical Variable の値の設定を行うには,<a href="#language-operator-assign">Assignment Operator</a>を使用します。
</p>
<pre>
$var = Right Expression
</pre>
<p>
  代入が<a href="#language-type-compatible">型の互換性</a>を満たさない場合は,a compile-time error occurs
</p>
<p>
  Lexical Variable の値の設定は,設定後の値を返します。
</p>
<p>
  Lexical Variable の値の設定は,<a href="#language-expression">式</a>です。
</p>
<p>
  Right Expressionが,object type であった場合は,オブジェクトのReference Countが1増やされます。
</p>
<p>
  代入前に,すでに$varにオブジェクトが代入されていた場合は,そのオブジェクトのReference Countが1減らされます。
</p>

<h3 id="language-expression-get-package-var">Package Variable の値の取得</h3>
<p>
  Package Variable の値を取得するにはthe following syntax を使用します。
</p>
<pre>
$クラス名::Package Variable Name
</pre>
<p>
  自分自身のPackage に属するPackage Variable の場合は"クラス名::"を省略できます。
</p>
<pre>
$Package Variable Name
</pre>
<p>
 Package Variable の値の取得は,<a href="#language-expression">式</a>を返します。
</p>
<p>
  定義されていないPackage Variable の値を取得しようとした場合は,a compile-time error occurs
</p>
<p>
  Package 外側からプライベートなPackage Variable にアクセスしようとした場合は,a compile-time error occurs
</p>
<p>
  <b>Package Variable の値の取得のExample</b>
</p>
<pre>
package Foo {
  our $VAR : int;

  sub bar : int () {
    my $var1 = $Foo::VAR;
    my $var2 = $VAR;
  }
}
</pre>

<h3 id="language-expression-set-package-var">Package Variable の値の設定</h3>
<p>
  Package Variable の値を設定するにはthe following syntax を使用します。
</p>
<pre>
$クラス名::Package Variable Name = Right Expression
</pre>
  自分自身のPackage に属するPackage Variable の場合は"クラス名::"を省略できます。
</p>
<pre>
$Package Variable Name = Right Expression
</pre>
<p>
  Package Variable 設定は,<a href="#language-expression">式</a>を返します。返される結果は,代入後のPackage Variable の値です。
</p>
<p>
  定義されていないPackage Variable の値を設定しようとした場合は,コンパイル時エラーが設定します。
</p>
<p>
  Package 外側からプライベートなPackage Variable にアクセスしようとした場合は,a compile-time error occurs
</p>
<p>
  <b>Package Variable の値の設定のExample</b>
</p>
<pre>
package Foo {
  our $VAR : int;

  sub bar : int () {
    $Foo::VAR = 1;
    $VAR = 3;
  }
}
</pre>

<h3 id="language-expression-get-exception-var">例外変数の値の取得</h3>
<p>
  例外変数の値を取得するにはthe following syntax を使用します。
</p>
<pre>
$@
</pre>
<p>
 例外変数の値の取得は,<a href="#language-expression">式</a>を返します。
</p>
<p>
 例外変数の値の取得は,<a href="#language-type-string">文字列型</a>の値を返します。
</p>
<p>
  <b>例外変数の値の取得のExample</b>
</p>
<p>
  例外変数の値の取得のExampleです。
</p>
<pre>
eval {
  foo();
};

if (my $message = $@) {

}
</pre>

<h3 id="language-expression-set-exception-var">例外変数の値の設定</h3>
<p>
  例外変数の値を設定するにはthe following syntax を使用します。
</p>
<pre>
$@ = Right Expression
</pre>
<p>
  Right Expressionは<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
 例外変数の値の設定は,<a href="#language-expression">式</a>を返します。
</p>
<p>
 例外変数の値の設定は,設定後の例外変数の値を返します。これは,<a href="#language-type-string">文字列型</a>です。
</p>
<p>
  <b>例外変数の値の設定のExample</b>
</p>
<p>
  例外変数の値の設定のExampleです。
</p>
<pre>
$@ = "Error";
</pre>

<h3 id="language-expression-get-field-class">Class Typeのフィールドの値の取得</h3>
<p>
  Class Typeのフィールドの値の取得は,次のように記述します。
</p>
<pre>
Invocant 式->{Field Name}
</pre>
<p>
  Invocant 式は,<a href="#language-type-class">Class Type</a>の値でなければなりません。Invocant 式が,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric">Multi Numeric Typeのフィールドの値の取得</a>になり,<a href="#language-type-ref-multi-numeric">複数数値のreference type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの取得</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Class Typeのフィールドの値の取得は,オブジェクトに保存されているフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は,フィールドの型です。
</p>
<p>
  <b>Class Typeのフィールドの値の取得のExample</b>
</p>
<p>
  Class Typeのフィールドの値の取得のExampleです。
</p>
<pre>
my $point = Point->new;
my $x = $point->{x};
</pre>

<h3 id="language-expression-set-field-class">Class Typeのフィールドの値の設定</h3>
<p>
  Class Typeのフィールドの値の設定は,次のように記述します。
</p>
<pre>
Invocant 式->{Field Name} = Right Expression
</pre>
<p>
  Invocant 式は,<a href="#language-type-class">Class Type</a>の値でなければなりません。Invocant 式が,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric">Multi Numeric Typeのフィールドの値の設定</a>になり,<a href="#language-type-ref-multi-numeric">複数数値のreference type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの設定</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Right Expressionの型は,フィールドの型と同じでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Class Typeのフィールドの値の設定は,設定後のオブジェクトに保存されているフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は,フィールドの型です。
</p>
<p>
  Right Expressionが,object type であった場合は,オブジェクトのReference Countが1増やされます。
</p>
<p>
  代入前に,すでにフィールドにオブジェクトが代入されていた場合は,そのオブジェクトのReference Countが1減らされます。
</p>
<p>
  <b>Class Typeのフィールドの値の設定のExample</b>
</p>
<p>
  Class Typeのフィールドの値の設定のExampleです。
</p>
<pre>
my $point = Point->new;
$point->{x} = 1;
</pre>

<h3 id="language-expression-get-field-multi-numeric">Multi Numeric Typeのフィールドの値の取得</h3>
<p>
  Multi Numeric Typeのフィールドの値の取得は,次のように記述します。
</p>
<pre>
Invocant 式->{Field Name}
</pre>
<p>
  Invocant 式は,<a href="#language-type-class">Multi Numeric Type</a>の値でなければなりません。Invocant 式が,<a href="#language-type-class">Class Type</a>の値であった場合は,<a href="#language-expression-get-field-class">Class Typeのフィールドの値の取得</a>になり,<a href="#language-type-ref-multi-numeric">複数数値のreference type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの取得</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Multi Numeric Typeのフィールドの値の取得は,<a href="#language-sub-stack">Subroutine Callstack</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は,フィールドの型です。
</p>
<p>
  <b>Multi Numeric Typeのフィールドの値の取得のExample</b>
</p>
<p>
  Multi Numeric Typeのフィールドの値の取得のExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $re = $z->{re};
</pre>

<h3 id="language-expression-set-field-multi-numeric">Multi Numeric Typeのフィールドの値の設定</h3>
<p>
  Multi Numeric Typeのフィールドの値の設定は,次のように記述します。
</p>
<pre>
Invocant 式->{Field Name} = Right Expression
</pre>
<p>
  Invocant 式は,<a href="#language-type-class">Multi Numeric Type</a>の値でなければなりません。Invocant 式が,<a href="#language-type-class">Class Type</a>の値であった場合は,<a href="#language-expression-set-field-class">Class Typeのフィールドの値の設定</a>になり,<a href="#language-type-ref-multi-numeric">複数数値のreference type</a>の値であった場合は,<a href="#language-expression-set-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの設定</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Right Expressionの型は,フィールドの型と同じでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Multi Numeric Typeのフィールドの値の設定は,設定後の<a href="#language-sub-stack">Subroutine Callstack</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は,フィールドの型です。
</p>
<p>
  <b>Multi Numeric Typeのフィールドの値の設定のExample</b>
</p>
<p>
  Multi Numeric Typeのフィールドの値の設定のExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
$z->{re} = 2.5;
</pre>

<h3 id="language-expression-get-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの値の取得</h3>
<p>
  Dereference によるMulti Numeric Typeのフィールドの値の取得は,次のように記述します。
</p>
<pre>
Invocant 式->{Field Name}
</pre>
<p>
  Invocant 式は,<a href="#language-type-ref-multi-numeric">複数数値のreference type</a>の値でなければなりません。Invocant 式が,<a href="#language-type-class">Class Type</a>の値であった場合は,<a href="#language-expression-get-field-class">Class Typeのフィールドの値の取得</a>になり,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値であった場合は,<a href="#language-expression-get-field-multi-numeric">Multi Numeric Typeのフィールドの値の取得</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Dereference によるMulti Numeric Typeのフィールドの値の取得は,<a href="#language-sub-stack">Subroutine Callstack</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は,フィールドの型です。
</p>
<p>
  <b>Dereference によるMulti Numeric Typeのフィールドの値の取得のExample</b>
</p>
<p>
  Dereference によるMulti Numeric Typeのフィールドの値の取得のExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
my $re = $z_ref->{re};
</pre>

<h3 id="language-expression-set-field-multi-numeric-deref">Dereference によるMulti Numeric Typeのフィールドの値の設定</h3>
<p>
  Dereference によるMulti Numeric Typeのフィールドの値の設定は,次のように記述します。
</p>
<pre>
Invocant 式->{Field Name} = Right Expression
</pre>
<p>
  Invocant 式は,<a href="#language-type-ref-multi-numeric">複数数値のreference type</a>の値でなければなりません。Invocant 式が,<a href="#language-type-class">Class Type</a>の値であった場合は,<a href="#language-expression-set-field-class">Class Typeのフィールドの値の設定</a>になり,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値であった場合は,<a href="#language-expression-set-field-multi-numeric">Multi Numeric Typeのフィールドの値の設定</a>になり,それ以外の場合は,a compile-time error occurs
</p>
<p>
  Field Nameが,存在しない場合は,a compile-time error occurs
</p>
<p>
  Right Expressionの型は,フィールドの型と同じでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Dereference によるMulti Numeric Typeのフィールドの値の設定は,設定後の<a href="#language-sub-stack">Subroutine Callstack</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は,フィールドの型です。
</p>
<p>
  <b>Dereference によるMulti Numeric Typeのフィールドの値の設定のExample</b>
</p>
<p>
  Dereference によるMulti Numeric Typeのフィールドの値の設定のExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{re} = 2.5;
</pre>

<h3 id="language-expression-get-array-element">配列の要素の値の取得</h3>
<p>
  配列の要素の値を取得するには,次のように記述します。
</p>
<p>
配列式->[インデックス式]
</p>
<p>
  配列式は,<a href="#language-type-array">array type</a>の値でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  インデックス式は,int type の値でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  配列の要素の値を取得は,指定したインデックスの要素の値を返します。これは,式です。
</p>
<p>
  実行時に,配列式の値が,Undefined Valueである場合は,実行時例外が発生します。
</p>
<p>
  実行時に,インデックスの値が,0より小さい場合,あるいは,配列の最大のインデックスを超えている場合は,実行時例外が発生します。
</p>
<p>
  <b>配列の要素の値の取得のExample</b>
</p>
<p>
  配列の要素の値の取得のExampleです。
</p>
<pre>
my $nums = new int[3];
my $num = $nums->[1];

my $points = new Point[3];
my $point = $points->[1];

my $objects : oarray = $points;
my $object = (Point)$objects->[1];
</pre>

<h3 id="language-expression-set-array-element">配列の要素の値の設定</h3>
<p>
  配列の要素の値を設定するには,次のように記述します。
</p>
<p>
配列式->[インデックス式] = Right Expression
</p>
<p>
  配列式は,<a href="#language-type-array">array type</a>の値でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  インデックス式は,int type の値でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Right Expressionの型は,配列の要素の型と<a href="#language-type-compatible">型の互換性</a>がなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  配列の要素の値を設定は,設定後の値を返します。これは,式です。
</p>
<p>
  実行時に,配列式の値が,Undefined Valueである場合は,実行時例外が発生します。
</p>
<p>
  実行時に,インデックスの値が,0より小さい場合,あるいは,配列の最大のインデックスを超えている場合は,実行時例外が発生します。
</p>
<p>
  Right Expressionが,object type であった場合は,オブジェクトのReference Countが1増やされます。
</p>
<p>
  代入前に,すでに配列の要素にオブジェクトが代入されていた場合は,そのオブジェクトのReference Countが1減らされます。
</p>
<p>
  <b>配列の要素の値の設定のExample</b>
</p>
<p>
  配列の要素の値の設定のExampleです。
</p>
<pre>
my $nums = new int[3];
$nums->[1] = 3;

my $points = new Point[3];
$points->[1] = Point->new(1, 2);

my $objects : oarray = $points;
$objects->[2] = Point->new(3, 5);;
</pre>

<h3 id="language-expression-new-object">Object Creating</h3>
<p>
  オブジェクトを生成するには,new  Keyword とthe following syntax をを使用します。
</p>
<pre>
my $object = new PACKAGE_NAME;
</pre>
<p>
  指定されたPackage は,<a href="#language-type-class">Class Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  フィールドは,すべて<a href="language-type-initial-value">Type Initial Value</a>で初期化されます。
</p>
<p>
  Object Creatingは,<a href="#language-expression">式</a>を返します。
</p>
<p>
  生成直後のオブジェクトのReference Countは,0です。代入が実行されるタイミングで,Reference Countが1増やされます。明示的な代入が行われない場合でも,一時変数が作成され,そこに代入されます。
</p>
<p>
  <b>Object CreatingのExample</b>
</p>
<pre>
my $object = new Foo;
</pre>
<p>
  生成されたオブジェクトは内部的に次の情報を持っています。
</p>
<ul class="list">
  <li>Reference Count</li>
  <li>Back references of Weaken Reference</li>
  <li>Basic Type ID</li>
  <li>Type Dimension(Always 0)</li>
</ul>

<h3 id="language-expression-new-array">Array Creating</h3>
<p>
  配列を作成するには,new  Keyword とthe following syntax をを使用します。
</p>
<pre>
my $object = new 型[要素数式];
</pre>
<p>
  型には,<a href="#language-type-numeric">numeric type</a>,<a href="#language-type-object">object type</a>,<a href="#language-type-multi-numeric">Multi Numeric Type</a>が指定できます。それ以外の型を指定した場合は,a compile-time error occurs
</p>
<p>
  要素数式は,int type the following <a href="#language-type-numeric">numeric type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  要素数式に対して,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  要素数式で指定された長さの配列が生成されます。
</p>
<p>
  配列の要素は,すべて<a href="language-type-initial-value">Type Initial Value</a>で初期化されます。
</p>
<p>
  配列において,要素は,メモリ上に連続していることが保証されます。
</p>
<p>
  Array Creatingは,<a href="#language-expression">式</a>を返します。
</p>
<p>
  配列は,<a href="#language-type-object">object type</a>です。
</p>
<p>
  <b>Array CreatingのExample</b>
</p>
<pre>
my $nums = new int[3];
my $objects = new Foo[3];
my $objects = new object[3];
my $values = new Complex_2d[3]
</pre>
<p>
  生成された配列は,内部的に次の情報を持っています。
</p>
<ul class="list">
  <li>Reference Count</li>
  <li>Basic Type ID</li>
  <li>Type Dimension(1以上の値)</li>
  <li>Array Length</li>
</ul>
<p>
  多次元配列は,上記のsyntax を使用して,作成できます。要素は,<a href="#language-type-initial-value">Type Initial Value</a>によって初期化されます。
</p>
<pre>
my $nums = new int[][3];
my $nums = new int[][][3];
</pre>
<p>
  多次元配列の次元数の最大は,255です。
</p>

<h3 id="language-expression-array-init">Array Initialization</h3>
<p>
  SPVMには,Array Creatingを簡単にするためのArray Initializationのsyntax があります。式はなくてもかまいません。
</p>
<pre>
[]
[式1, 式2, 式3]
</pre>
<p>
  Array Initializationは,式の要素数の長さを持った配列を返します。
</p>
<p>
  配列の型は,式1の型をarray typeにしたものです。要素が指定されない場合は,<a href="#language-type-any-object">Any Object Type</a>をarray typeにしたものになります。
</p>
<p>
  式2以降が,<a href="#language-type-compatible">型の互換性</a>を満たさない場合は,コンパイルエラーになります。
</p>

<h3 id="language-expression-callsub">Subroutine Call</h3>
<p>
  <a href="#language-sub-definition">Subroutine Definition</a>によって定義されたSubroutine は呼び出すことができます。呼び出しには,2種類あって,<b>関数の呼び出し</b>と<b>Method Call </b>があります。
</p>

<h4 id="language-expression-callsub-func">関数の呼び出し</h4>
<p>
  関数の呼び出しとは,<a href="#language-sub-method">メソッド</a>ではないSubroutine を呼び出す方法のことをいいます。メソッドかどうかの判断は,<a href="#language-sub-definition">Subroutine Definition</a>において,第一引数に<a href="#language-type-self">self type</a>の引数が指定されていた場合が,メソッドになります。
</p>
<p>
  関数の呼び出しはthe following 方法で行うことができます。引数は,なくても構いません。最大で255個の引数を指定できます。
</p>
<pre>
Package Name->Subroutine Name(引数1, 引数2, 引数3, ..., 引数n);
</pre>
<p>
  PerlにおいてクラスMethod Call と呼ばれているものが,SPVMでは,関数の呼び出しと呼ばれていることに注意してください。
</p>
<p>
  関数の呼び出しでは,Package Nameを省略することもできます。
</p>
<pre>
Subroutine Name(引数1, 引数2, 引数3, ..., 引数n);
</pre>
<p>
  どのPackage Subroutine が呼び出されるかは,the following 順番によって決まります。
</p>
<p>
  1. 現在のPackage で定義されているSubroutine ,または現在のPackage にインポートされたSubroutine 
</p>
<p>
  2. 標準関数 - COREPackage で定義されているSubroutine 
</p>

<p>
  関数の呼び出しは,引数を受け取ります。引数の個数が,Subroutine Definitionで定義されている引数の個数と一致しない場合は,a compile-time error occursそれぞれの引数の型が,Subroutine 定義で定義されている引数の型と<a href="#language-type-compatible">型の互換性</a>がない場合は,a compile-time error occurs
</p>
<p>
  関数の呼び出しは,Return Valueがvoid type以外の場合は,Return Valueを返します。
</p>
<p>
  関数の呼び出しは,<a href="#language-expression">式</a>です。
<p>
<p>
  <b>Subroutine 呼び出しのExample</b>
</p>
<p>
  Subroutine 呼び出しのExampleです。
</p>
<pre>
my $ret = Foo->bar(1, 2, 3);
my $ret = bar(1, 2, 3);
</pre>

<h4 id="language-expression-callsub-method">Method Call </h4>
<p>
  Method Call とは,<a href="#language-sub-method">メソッド</a>であるSubroutine を呼び出す方法のことをいいます。メソッドかどうかの判断は,<a href="#language-sub-definition">Subroutine Definition</a>において,第一引数に<a href="#language-type-self">self type</a>の引数が指定されていた場合が,メソッドになります。
</p>
<p>
  Method Call は,<a href="#language-expression-new-object">Object Creating</a>によって生成されたオブジェクトを使ってthe following syntax で行うことができます。
</p>
<pre>
オブジェクト->Subroutine Name(引数1, 引数2, 引数3, ..., 引数n);
</pre>
<p>
  Method Call は,引数を受け取ります。引数の個数が,Subroutine Definitionで定義されている引数の個数と一致しない場合は,a compile-time error occursそれぞれの引数の型が,Subroutine 定義で定義されている引数の型と<a href="#language-type-compatible">型の互換性</a>がない場合は,a compile-time error occurs
</p>
<p>
  Method Call は,Return Valueがvoid type以外の場合は,Return Valueを返します。
</p>
<p>
  Method Call は,<a href="#language-expression">式</a>です。
<p>
<p>
  <b>Method Call のExample</b>
</p>
<p>
  Method Call のExampleです。
</p>
<pre>
my $point = new Point;
$point->set_x(3);
</pre>
<p>
  <a href="#language-sub-new-callback-object">コールバックObject Creating</a>で作成されたオブジェクトは,通常のオブジェクトなのでメソッドを呼び出すことができます。
</p>
<pre>
オブジェクト->(引数1, 引数2, 引数3, ..., 引数n);
</pre>

<p>
  <b>コールバックObject Creatingで生成されたオブジェクトからメソッドを呼び出すExample</b>
</p>
<p>
  コールバックObject Creatingで生成されたオブジェクトからメソッドを呼び出すExampleです。
</p>
<pre>
my $cb_obj = sub : int ($self: self, $num1 : int, $num2 : int) {
  return $num1 + $num2;
};

my $ret = $cb_obj->(1, 2);
</pre>

<h3 id="language-operator-deref-get">Dereference による値の取得</h3>
<p>
  Dereference による値の取得とは,リファレンスから実際の値を取得するための操作のことです。C言語の関節Operator "*"を実現するために設計されました。
</p>
<pre>
$変数
</pre>
<p>
  変数の型は,reference type でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Dereference による値の取得は,<a href="#language-expression">式</a>を返します。
</p>
<pre>
  <b>Dereference による値の取得のExample</b>
</pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
my $num_deref : int = $$num_ref;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
my $z_deref : SPVM::Complex_2d = $$z_ref;
</pre>

<h3 id="language-operator-deref-set">Dereference による値の設定</h3>
<p>
  Dereference による値の設定とは,リファレンスから実際の値を設定するための操作のことです。C言語の関節Operator "*"を実現するために設計されました。
</p>
<pre>
$変数 = 式
</pre>
<p>
  変数の型は,reference type でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  式の型は,Dereference された場合の変数の型に一致していなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Dereference による値の設定は,設定された値を返します。これは<a href="#language-expression">式</a>です。
</p>
<pre>
  <b>Dereference による値の設定のExample</b>
</pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
$$num_ref = 1;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;

my $z2 : SPVM::Complex_2d;

$$z_ref = $z2;
</pre>

<h3 id="language-expression-current-package">Current Package Nameの取得</h3>
<p>
  Current Package Nameの取得を行う"__PACKAGE__"  Keyword を使用します。
</p>
<pre>
__PACKAGE__
</pre>
<p>
  Current Package Nameの取得は<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>Current Package Nameの取得のExample</b>
</p>
<pre>
package Foo::Bar {
  sub baz : void () {
    # Foo::Bar
    my $package_name == __PACKAGE__;
  }
}
</pre>
<h3 id="language-expression-current-package">Current File Nameの取得</h3>
<p>
  Current File Nameの取得を行う"__FILE__"  Keyword を使用します。
</p>
<pre>
__FILE__
</pre>
<p>
  Current File Nameの取得は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Current File Nameとは,Moduleの読み込みパスを基準とした,ファイルの相対パスのことをいいます。たとえば,ファイルの読み込みパスが"/mypath"でModule名が"Foo::Bar"であった場合は,絶対パスは"/mypath/Foo/Bar.spvm"で,相対パスは"Foo/Bar.spvm"です。相対パスである"Foo/Bar.spvm"が,Current File Nameになります。
</p>
<p>
  <b>Current File Nameの取得のExample</b>
</p>
<pre>
# Foo/Bar.spvm
package Foo::Bar {
  sub baz : void () {
    # Foo/Bar.spvm
    my $file_name == __FILE__;
  }
}
package Foo::Bar2 {
  sub baz : void () {
    # Foo/Bar.spvm
    my $file_name == __FILE__;
  }
}
</pre>
<h3 id="language-expression-current-package">Current Line Numberの取得</h3>
<p>
  Current Line Numberの取得を行う"__LINE__"  Keyword を使用します。
</p>
<pre>
__LINE__
</pre>
<p>
  Current Line Numberの取得は<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>Current Line Numberの取得のExample</b>
</p>
<pre>
package Foo::Bar {
  sub baz : void () {
    # 4
    my $line == __LINE__;
  }
}
</pre>

<h2 id="language-expression-release-object">オブジェクトの解放</h2>
<p>
  オブジェクトは,Reference Countが0になるとメモリから解放されます。
</p>
<p>
  オブジェクトが,object type の値を要素として持つ配列だった場合は,オブジェクトの解放の前に,Undefined Valueではないすべての配列の要素のReference Countが1減らされます
</p>
<p>
  オブジェクトが,Class Typeで,object type のフィールドを持つときは,オブジェクトの解放の前に,Undefined Valueではないすべてのobject type のフィールドが所有するオブジェクトのReference Countが1減らされます。フィールドに保存されているオブジェクトにWeaken Referenceが設定されていた場合は,Reference Countが1減らされる前に,Weaken Referenceが解除されます。
</p>
<p>
  オブジェクトがBack references of Weaken Referenceを持つときは,バックリファレンスとして登録されているフィールドすべてに,Undefined Valueを代入し,バックリファレンスをすべて削除します。
</p>
<p>
  上記の処理は,再帰的に行われます。
</p>

<h2 id="language-literal">Literal </h2>
<ul class="list">
  <li><a href="#language-literal-integer">Integer Literal</a></li>
  <li><a href="#language-literal-floating-point">Floating Point Literal</a></li>
  <li><a href="#language-literal-character">Chracter Literal</a></li>
  <li><a href="#language-literal-string">String Literal</a></li>
  <li><a href="#language-literal-string-variable-expansion">Variable Expansion</a></li>
</ul>
<h3 id="language-literal-integer">Integer Literal  </h2>
<p>
  <b>10進数表現</b>
</p>
<p>
  Integer Literal  の数値部は"0～9"の1つ以上の連続した文字で表現されます。
</p>
<p>
  先頭に"+"あるいは"-"の符号をつけることができます。
</p>
<p>
  Integer Literal  の型は,デフォルトでは"int type "になります。
</p>
<p>
  Integer Literal  がint type で表現できる数値の範囲を超えている場合は,a compile-time error occurs
</p>
<p>
  末尾に"L"あるいは"l"のサフィックスをつけることで"long型"のInteger Literal  を表現できます。
</p>
<p>
  long型のInteger Literal  の場合は,long型で表現できる数値の範囲を超えている場合は,a compile-time error occurs
</p>
<p>
  Separatorとして"_"を使用することができます。Separatorは意味を持ちません。
</p>
<p>
  Invalid Integer Literal  の表現はa compile-time error occurs
</p>
<p>
  Integer Literal  がbyte型の変数に代入される場合,あるいはbyte型のSubroutine Argumentsとして渡される場合で,byte型で表現できる数値の範囲を超えていない場合は,<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>によって,byte型に自動的に変換されます。範囲を超えている場合は,コンパイル時エラーとなります。
</p>
<p>
  Integer Literal  がshort型の変数に代入される場合,あるいはshort型のSubroutine Argumentsとして渡される場合で,short型で表現できる数値の範囲を超えていない場合は,<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>によって,short型に自動的に変換されます。範囲を超えている場合は,コンパイル時エラーとなります。
</p>
<p>
  Integer Literal  のExampleです。
</p>
<pre>
123
+123
-123
123L
123l
123_456_789
-123_456_789L
</pre>
<p>
  <b>16進数表現</b>
</p>
<p>
  Integer Literal  の数値部は<b>16進数</b>を使って表現することができます。
</p>
<p>
 数値部を16進数を使って表現するときは"0x"から始めます。
</p>
<p>
  その後ろに"0～9""a～f""A～F"のひとつ以上の連続した文字が続きます。
</p>
<p>
  Invalid 16進数表現は,a compile-time error occurs
</p>
<p>
  Integer Literal  を16進数で表現したExampleです。
</p>
<pre>
0x3b4f
-0x3F1A
0xDeL
0xFFFFFFFF_FFFFFFFF
</pre>

<p>
  <b>8進数表現</b>
</p>
<p>
  Integer Literal  の数値部は<b>8進数</b>を使って表現することができます。
</p>
<p>
 数値部を8進数を使って表現するときは"0"から始めます。
</p>
<p>
  その後ろに"0～7"のひとつ以上の連続した文字が続きます。
</p>
<p>
  Invalid 8進数表現は,a compile-time error occurs
</p>
<p>
  Integer Literal  を8進数で表現したExampleです。
</p>
<pre>
0755
-0644
0666L
0655_755
</pre>
<p>
  <b>2進数表現</b>
</p>
<p>
  Integer Literal  の数値部は<b>2進数</b>を使って表現することができます。
</p>
<p>
 数値部を2進数を使って表現するときは"0b"から始めます。
</p>
<p>
  その後ろに"0"か"1"のひとつ以上の連続した文字が続きます。
</p>
<p>
  Invalid 2進数表現は,a compile-time error occurs
</p>
<p>
  Integer Literal  を2進数で表現したExampleです。
</p>
<pre>
0b0101
-0b1010
0b110000L
0b10101010_10101010
</pre>


<h3 id="language-literal-floating-point">Floating Point Literal </h2>
<p>
  Floating Point Literal は"符号部""数値部""指数部""サフィックス"から構成されます。
<p>
<p>
  Floating Point Literal には"10進数Floating Point Literal "と"16進数Floating Point Literal "があります。
</p>
<p>
  "符号部"は"+"か"-"で表現されます。"符号部"の存在は,任意です。"符号部"が存在する場合は,先頭にある必要があります。
</p>
<p>
  "10進数Floating Point Literal "は,数値部が"一桁以上の10進数字"で始まる必要があります。
</p>
<p>
  "10進数字"とは"0～9"のことです。
</p>
<p>
  "10進数Floating Point Literal "は,数値部に"小数点"が含まれているか,含まれていない場合は"指数部"あるいは"サフィックス"が必要です。
</p>
<p>
  "小数点"とは"."のことです。
</p>
<p>
  "16進数Floating Point Literal "は,数値部が"0x"あるいは"0X"で始まり,その後ろに"一桁以上の16進数字"が続く必要があります。
</p>
<p>
  16進数字とは"0～9""a～f""A～F"のことです。
</p>
<p>
  "16進数Floating Point Literal "は,"数値部"に"小数点"を含むことができます。
</p>
<p>
  "数値部"はアンダーライン"_"を含むことができます。これは単なるSeparatorで,無視されます。
</p>
<p>
  "16進数Floating Point Literal "は,"指数部"が必要です。
</p>
<p>
  "指数部"は"指数表現"と"符号付10進整数"で構成されます。
</p>
<p>
  "指数表現"は"10進数Floating Point Literal "の場合は"e"あるいは"E","16進数Floating Point Literal "の場合は"p"あるいは"P"になります。
</p>
<p>
  "指数部"の意味は"10進数Floating Point Literal "の場合は,10進数による桁移動,"16進数Floating Point Literal "の場合は,2進数による桁移動になります。
</p>
<p>
  末尾に"f"あるいは"F"のサフィックスをつけると,Floating Point Literal の型は"float型"になります。
</p>
<p>
  末尾に"d"あるいは"D"のサフィックスをつけると,Floating Point Literal の型は"double型"になります。
</p>
<p>
  サフィックスが省略された場合は,Floating Point Literal の型は"double型"になります。
</p>
<p>
  Floating Point Literal が"float型"の場合はC標準の"strtof関数"を使って,文字列からfloat型への変換が行われます。変換が失敗した場合は,a compile-time error occurs
</p>
<p>
  Floating Point Literal が"double型"の場合はC標準の"strtod関数"を使って,文字列からdouble型への変換が行われます。変換が失敗した場合は,a compile-time error occurs
</p>
<p>
  無限大を表現するFloating Point Literal はありません。標準関数である"<a href="#stdfunc-INFINITY">INFINITY関数</a>""<a href="#stdfunc-INFINITYF">INFINITYF関数</a>"を使用してください。
</p>
<p>
  非値を表現するFloating Point Literal はありません。標準関数である"<a href="#stdfunc-NAN">NAN関数</a>""<a href="#stdfunc-NANF">NANF関数</a>"を使用してください。
</p>
<p>
  Floating Point Literal のExampleです
</p>
<pre>
1.32
-1.32
1.32f
1.32F
1.32e3
1.32e-3
1.32E+3
1.32E-3
0x3d3d.edp0
0x3d3d.edp3
0x3d3d.edP3
0x3d3d.edP-3f
</pre>

<h3 id="language-literal-character">Chracter Literal </h2>
<p>
  Chracter Literal は,シングルクォート"'"で囲まれます。
</p>
<p>
  Chracter Literal の内容は"ひとつのAsciiの印字可能文字"あるいは"ひとつのエスケープ文字"です。
</p>
<p>
  Chracter Literal の型は"byte型"になります。
</p>
<p>
  Invalid Chracter Literal の場合は,a compile-time error occurs
</p>
<p>
  <b>エスケープ文字</b>
</p>
<table class="toc">
  <tr>
    <th>
      エスケープ文字
    </th>
    <th>
      説明
    </th>
  </tr>
  <tr>
    <td>
      <b>\0</b>
    </td>
    <td>
      Ascii Codeの0"NUL"
    </td>
  </tr>
  <tr>
    <td>
      <b>\a</b>
    </td>
    <td>
      Ascii Codeの7"BEL"
    </td>
  </tr>
  <tr>
    <td>
      <b>\b</b>
    </td>
    <td>
      Ascii Codeの8"BS"
    </td>
  </tr>
  <tr>
    <td>
      <b>\t</b>
    </td>
    <td>
      Ascii Codeの9"HT"
    </td>
  </tr>
  <tr>
    <td>
      <b>\n</b>
    </td>
    <td>
      Ascii Codeの10"LF"
    </td>
  </tr>
  <tr>
    <td>
      <b>\f</b>
    </td>
    <td>
      Ascii Codeの12"FF"
    </td>
  </tr>
  <tr>
    <td>
      <b>\r</b>
    </td>
    <td>
      Ascii Codeの13"CR"
    </td>
  </tr>
  <tr>
    <td>
      <b>\"</b>
    </td>
    <td>
      Ascii Codeの34"""
    </td>
  </tr>
  <tr>
    <td>
      <b>\'</b>
    </td>
    <td>
      Ascii Codeの39"'"
    </td>
  </tr>
  <tr>
    <td>
      <b>\\</b>
    </td>
    <td>
      Ascii Codeの92"\"
    </td>
  </tr>
  <tr>
    <td>
      <b>\xの後ろに二桁の16進数</b>
    </td>
    <td>
      直接Ascii Codeを指定します。16進数は"0～9""a～f""A～F"で表現します。
    </td>
  </tr>
</table>

<p>
  <b>Chracter Literal のExample</b>
</p>
<p>
  Chracter Literal のExampleです。
</p>
<pre>
# Chracter Literal 
'a'
'x'

# エスケープ文字を使ったChracter Literal 
'\a'
'\b'
'\t'
'\n'
'\f'
'\r'
'\"'
'\''
'\\'
'\x0D'
'\x0A'
</pre>

<h3 id="language-literal-string">String Literal </h2>
<p>
  String Literal は,ダブルクォート"""で囲まれます。
</p>
<p>
  String Literal の内容は"0個以上のAsciiの印字可能文字あるいはエスケープ文字"です。
</p>
<p>
  String Literal の型は"string型"になります。
</p>
<p>
  Invalid String Literal の場合は,a compile-time error occurs
</p>
<p>
  <b>エスケープ文字</b>
</p>
<table class="toc">
  <tr>
    <th>
      エスケープ文字
    </th>
    <th>
      説明
    </th>
  </tr>
  <tr>
    <td>
      <b>\0</b>
    </td>
    <td>
      Ascii Codeの0"NUL"
    </td>
  </tr>
  <tr>
    <td>
      <b>\a</b>
    </td>
    <td>
      Ascii Codeの7"BEL"
    </td>
  </tr>
  <tr>
    <td>
      <b>\b</b>
    </td>
    <td>
      Ascii Codeの8"BS"
    </td>
  </tr>
  <tr>
    <td>
      <b>\t</b>
    </td>
    <td>
      Ascii Codeの9"HT"
    </td>
  </tr>
  <tr>
    <td>
      <b>\n</b>
    </td>
    <td>
      Ascii Codeの10"LF"
    </td>
  </tr>
  <tr>
    <td>
      <b>\f</b>
    </td>
    <td>
      Ascii Codeの12"FF"
    </td>
  </tr>
  <tr>
    <td>
      <b>\r</b>
    </td>
    <td>
      Ascii Codeの13"CR"
    </td>
  </tr>
  <tr>
    <td>
      <b>\"</b>
    </td>
    <td>
      Ascii Codeの34"""
    </td>
  </tr>
  <tr>
    <td>
      <b>\'</b>
    </td>
    <td>
      Ascii Codeの39"'"
    </td>
  </tr>
  <tr>
    <td>
      <b>\\</b>
    </td>
    <td>
      Ascii Codeの92"\"
    </td>
  </tr>
  <tr>
    <td>
      <b>\xの後ろに二桁の16進数</b>
    </td>
    <td>
      直接Ascii Codeを指定します。16進数は"0～9""a～f""A～F"で表現します。
    </td>
  </tr>
  <tr>
    <td>
      <b>\N{}の中の複数桁の16進数</b>
    </td>
    <td>
      Unicodeのコードポイントを16進数で指定します。UTF-8に変換されます。16進数は"0～9""a～f""A～F"で表現します。
    </td>
  </tr>
  <tr>
    <td>
      <b>\s</b>
    </td>
    <td>
      Ascii Codeの92,115の並び"\s"
    </td>
  </tr>
  <tr>
    <td>
      <b>\S</b>
    </td>
    <td>
      Ascii Codeの92,83の並び"\S"
    </td>
  </tr>
  <tr>
    <td>
      <b>\d</b>
    </td>
    <td>
      Ascii Codeの92,100の並び"\d"
    </td>
  </tr>
  <tr>
    <td>
      <b>\D</b>
    </td>
    <td>
      Ascii Codeの92,68の並び"\D"
    </td>
  </tr>
  <tr>
    <td>
      <b>\w</b>
    </td>
    <td>
      Ascii Codeの92,119の並び"\w"
    </td>
  </tr>
  <tr>
    <td>
      <b>\W</b>
    </td>
    <td>
      Ascii Codeの92,87の並び"\W"
    </td>
  </tr>
  <tr>
    <td>
      <b>\の後ろに"a～z""A～Z""0-9"""""'""\""$"以外のAscii Codeがきた場合</b>
    </td>
    <td>
      Ascii Codeの92,アスキーコードで表現される文字の並び。たとえば"\-"の場合は"\-"。
    </td>
  </tr>
</table>
<p>
  Unicodeのコードポイントを指定するエスケープ文字以外は,<a href="#language-literal-character">Chracter Literal</a>のエスケープ文字と共通です。
</p>
<p>
  <b>String Literal のExample</b>
</p>
<p>
  String Literal のExampleです。
</p>
<pre>
# String Literal 
"abc"
"あいう"

# エスケープ文字を使ったString Literal 
"abc\tdef\n"
"\x0D\x0A"
"\N{U+3042}\N{U+3044}\N{U+3046}"
</pre>

<h3 id="language-literal-string-variable-expansion">Variable Expansion</h2>
<p>
  String Literal 中のLexical Variable ,Package Variable ,Dereference ,フィールドアクセス,定数の添え字の配列アクセス,例外変数の場合は,Variable Expansionが行われます。
</p>
<pre>
"AAA $foo BBB"
"AAA $FOO BBB"
"AAA $$foo BBB"
"AAA $foo->{x} BBB"
"AAA $foo->[3] BBB"
"AAA $foo->{x}[3] BBB"
"AAA $@ BBB"
</pre>
<p>
  上記は,the following ように展開されます。
</p>
<pre>
"AAA" . $foo . "BBB"
"AAA" . $FOO . "BBB"
"AAA" . $$foo . "BBB"
"AAA" . $foo->{x} . "BBB"
"AAA" . $foo->[3] . "BBB"
"AAA" . $foo->{x}[3] . "BBB"
"AAA" . $@ . "BBB"
</pre>

<p>
  変数名の終わりを表すために"{"と"}"で変数名を囲むことができます。
</p>
<pre>
"AAA ${foo}_ccc BBB"
</pre>
<p>
  上記は,the following ように展開されます。
</p>
<pre>
"AAA " . ${foo} . "_ccc BBB"
</pre>
<p>
  "{"と"}"の囲みがない場合は,変数名としてValid 文字列までを変数として解釈します。Dereference の場合も同じです。
</p>
<p>
  変数名の後ろに"->"が続いた場合は,フィールドアクセス,あるいは,配列アクセスと解釈します。
</p>
<p>
  1. その後ろに,続く文字が"a-z""A-Z""0-9""_""{""["であった場合は,解釈を進めます。
</p>
<p>
  2. "1."の後ろに続く文字が"}""]"であった場合は,その次の文字が"->""{""["であった場合は,解釈を進め,1に戻ります。otherwise 解釈を止めます。
</p>
<p>
  末尾の$はVariable Expansionの開始としては扱われず"$"として扱われます。
</p>
<pre>
"AAA$"
</pre>

<h2 id="language-string">文字列</h2>
<p>
  SPVMの文字列のデータ表現は,byte型の配列です。特別な内部表現を持たない,単なるバイト列です。
</p>
<pre>
my $string = new byte[3];
$string->[0] = 'a';
$string->[1] = 'b';
$string->[2] = 'c';
</pre>
<p>
  byte型の配列は,<a href="#language-type-string">文字列型</a>に代入できます。文字列型は,コンパイル時には要素を変更できない型ですが,実行時はbyte型の配列になります。
</p>
<pre>
my $string_const : string = $string;
</pre>
<p>
  <a href="#language-literal-string">String Literal</a>を代入することによって,文字列を作成できます。String Literal を元にしたstring型の新しい文字列を返します。
</p>
<pre>
my $string_const = "abc";
</pre>
<p>
  byte[]はC言語の"char*",文字列型はC言語の"const char*"に該当するように設計されています。
</p>

<h2 id="language-undef">Undefined Value</h2>
<p>
  未定義は"undef"で表現されます。
</p>
<pre>
undef
</pre>

<h2 id="language-fat-comma">ファットカンマ</h2>
<p>
  ファットカンマは"=>"で表現されます。
</p>
<pre>
=>
</pre>
<p>
  ファットカンマは","のエイリアスです。","が使える場所ではいつでも代わりに,ファットカンマが使えます。
</p>
<pre>
# カンマ
["a", "b", "c", "d"]

# カンマの代わりにファットカンマを使う
["a" => "b", "c" => "d"]
</pre>
<p>
  ファットカンマの左型に置かれたPackage Variable Name,Lexical Variable Name以外のIdentifierは,<a href="#language-literal-string">String Literal</a>として扱われます。
</p>

<pre>
# カンマの代わりにファットカンマを使う
["a" => "b", "c" => "d"]

# ファットカンマの左型に置かれたIdentifierは,String Literal になる。上記と同じ意味
[a => "b", c => "d"]
</pre>

<p>
  Undefined Valueは,任意のobject type の変数に代入することができます。
</p>
<p>
  Undefined Valueはobject type の値と"==""!="Operator を使用して,比較することができます。Undefined Valueは,生成されたオブジェクトと等しくない事が保証されます。
</p>
<p>
  未定義は条件部で使われた場合は,偽になります。
</p>
<p>
  Undefined Valueは,エクステンションにおいてC言語の値として利用された場合は,0と等しくなることが保証されます。
</p>
<h2 id="language-operator">Operator </h2>
<ul class="list">
  <li><a href="#language-operator-summary">Operator Summary</a></li>
  <li><a href="#language-operator-unary">Unary Operator</a></li>
  <li><a href="#language-operator-binary">Binary Operator</a></li>
  <li><a href="#language-operator-sequential">Sequential Operator</a></li>
  <li><a href="#language-operator-arithmetic">Arithmetic Operator</a></li>
  <li><a href="#language-operator-unary-plus">Unary Plus Operator</a></li>
  <li><a href="#language-operator-unary-minus">Unary Minus Operator</a></li>
  <li><a href="#language-operator-add">Addition Operator</a></li>
  <li><a href="#language-operator-subtract">Subtraction Operator</a></li>
  <li><a href="#language-operator-multiply">Multiplication Operator</a></li>
  <li><a href="#language-operator-divide">Division Operator</a></li>
  <li><a href="#language-operator-remainder">Remainder Operator</a></li>
  <li><a href="#language-operator-inc">Increment Operator</a></li>
  <li><a href="#language-operator-dec">Decrement Operator</a></li>
  <li><a href="#language-operator-bit">Bit Operator</a></li>
  <li><a href="#language-operator-bit-and">Bit AND Operator</a></li>
  <li><a href="#language-operator-bit-or">Bit OR Operator</a></li>
  <li><a href="#language-operator-bit-not">Bit NOT Operator</a></li>
  <li><a href="#language-operator-shift">Shift Operator</a></li>
  <li><a href="#language-operator-left-shift">Left Shift Operator</a></li>
  <li><a href="#language-operator-arithmetic-right-shift">Arithmetic Right Shift Operator</a></li>
  <li><a href="#language-operator-logical-right-shift">Logical Right Shift Operator</a></li>
  <li><a href="#language-operator-comparison">比較Operator</a></li>
  <li><a href="#language-operator-comparison-numeric">数値比較Operator</a></li>
  <li><a href="#language-operator-comparison-string">文字列比較Operator</a></li>
  <li><a href="#language-operator-isa">isa Operator</a></li>
  <li><a href="#language-operator-logical">論理Operator</a></li>
  <li><a href="#language-operator-logical-and">Logical AND Operator</a></li>
  <li><a href="#language-operator-logical-or">Logical OR Operator</a></li>
  <li><a href="#language-operator-logical-not">論理NOTOperator</a></li>
  <li><a href="#language-operator-concat">文字列連結Operator</a></li>
  <li><a href="#language-operator-assign">Assignment Operator</a></li>
  <li><a href="#language-operator-assign-special">Special Assignment Operator</a></li>
  <li><a href="#language-operator-ref">Reference Operator</a></li>
  <li><a href="#language-operator-array-length">Array Length Operator</a></li>
  <li><a href="#language-operator-string-length">String Length Operator</a></li>
  <li><a href="#language-operator-scalar">Scalar Operator</a></li>
  <li><a href="#language-operator-isweak">isweakOperator</a></li>
</ul>

<h3 id="language-operator-summary">Operator Summary </h3>
<p>
  Operator は,<a href="#language-operator-unary">Unary Operator</a>,<a href="#language-operator-binary">Binary Operator</a>,<a href="#language-operator-inc">Increment Operator</a>,<a href="#language-operator-dec">Decrement Operator</a>,<a href="#language-operator-comparison">比較Operator</a>,<a href="#language-operator-logical">論理Operator</a>,<a href="#language-operator-assign">Assignment Operator</a>からなります。
</p>

<h3 id="language-operator-unary">Unary Operator  </h3>
<p>
  Unary Operator  とは,<a href="#language-expresssion">式</a>の前に置かれるOperator のことをいいます。
</p>
<pre>
UNARY_OPERATOR 式
</pre>
<p>
  Unary Operator  には,<a href="#language-operator-unary-plus">Unary Plus Operator</a>,<a href="#language-operator-unary-minus">Unary Minus Operator</a>,<a href="#language-operator-bit-not">Bit NOT Operator</a>,<a href="#language-operator-logical-not">Logical NOT Operator</a>,<a href="#language-operator-array-legnth">Array Length Operator</a>,<a href="#language-operator-string-legnth">String Length Operator</a>があります。
</p>
<p>
  Increment Operator とDecrement Operator は,Unary Operator  には含まれません。
</p>

<h3 id="language-operator-binary">Binary Operator  </h3>
<p>
  Binary Operator  とは,Left ExpressionとRight Expressionの間に置かれるOperator のことをいいます。項については,<a href="#language-expresssion">式</a>を参考にしてください。
</p>
<pre>
Left Expression Binary Operator   Right Expression
</pre>

<p>
  Binary Operator  には,<a href="#language-operator-add">Addition Operator</a>,<a href="#language-operator-subtract">Subtraction Operator</a>,<a href="#language-operator-multiply">Multiplication Operator</a>,<a href="#language-operator-divide">Division Operator</a>,<a href="#language-operator-remainder">Remainder Operator</a>,<a href="#language-operator-bit-and">Bit AND Operator</a>,<a href="#language-operator-bit-or">Bit OR Operator</a>,<a href="#language-operator-logical-and">Logical AND Operator</a>,<a href="#language-operator-logical-or">Logical OR Operator</a>,<a href="#language-operator-shift">Shift Operator</a>,<a href="#language-operator-concat">文字列連結Operator</a>があります。
</p>

<h3 id="language-operator-sequential">Sequential Operator </h3>
<p>
  Sequential Operator とは,複数の<a href="#language-expression">式</a>を並べて記述でき,最後の値を返すOperator のことです。
</p>
<pre>
(式1, 式2, 式3)
</pre>
<p>
  式は左から実行されます。最後の値が返されます。
<p>
<p>
  Sequential Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>Sequential Operator のExample</b>
</p>
<p>
  Sequential Operator のExampleです。
</p>
<pre>
# $fooには3が代入される。
my $foo = (1, 2, 3);

# $xは3,$retは5になる
my $x = 1;
my $y = 2;
my $ret = ($x += 2, $x + $y);
</pre>

<li><a href="#language-operator-sequential">Sequential Operator</a></li>

<h3 id="language-operator-arithmetic">Arithmetic Operator </h3>
<p>
  Arithmetic Operator は,算術を行うOperator のことで,<a href="#language-operator-add">Addition Operator</a>,<a href="#language-operator-subtract">Subtraction Operator</a>,<a href="#language-operator-multiply">Multiplication Operator</a>,<a href="#language-operator-divide">Division Operator</a>,<a href="#language-operator-remainder">Remainder Operator</a>,<a href="#language-operator-unary-plus">Unary Plus Operator</a>,<a href="#language-operator-unary-minus">Unary Minus Operator</a>,<a href="#language-operator-inc">Increment Operator</a>,<a href="#language-operator-dec">Decrement Operator</a>からなります。
</p>

<h3 id="language-operator-unary-plus">Unary Plus Operator </h3>
<p>
  Unary Plus Operator は"+"で表現される<a href="#language-operator-unary">Unary Operator</a>です。
</p>
<pre>
+式
</pre>
<p>
  式は<a href="#language-type-numeric">numeric type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  <a href="#language-expression">式</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Unary Plus Operator は,与えられた値をコピーして返します。
</p>
<p>
  Unary Plus Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Unary Plus Operator のReturn Valueの型は,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
</p>
<p>
  Unary Plus Operator は例外を発生させません。
</p>
<p>
  <b>Unary Plus Operator のExample</b>
</p>
<pre>
my $num = +10;
</pre>
<h3 id="language-operator-unary-minus">Unary Minus Operator </h3>
<p>
  Unary Minus Operator は"-"で表現される<a href="#language-operator-unary">Unary Operator</a>です。
</p>
<pre>
-式
</pre>
<p>
  式は<a href="#language-type-numeric">numeric type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  <a href="#language-expression">式</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Unary Minus Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型,float型,double型における演算が定義されます。
</p>
<pre>
-x
</pre>
<p>
  Unary Minus Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Unary Minus Operator のReturn Valueの型は,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
</p>
<p>
  Unary Minus Operator は例外を発生させません。
</p>
<p>
  <b>Unary Minus Operator のExample</b>
</p>
<pre>
my $num = -10;
</pre>
<h3 id="language-operator-add">Addition Operator </h3>
<p>
  Addition Operator は"+"で表現される,加算を行うための<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression + Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-numeric">numeric type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Addition Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型,float型,double型における演算が定義されます。
</p>
<pre>
x + y;
</pre>
<p>
  Addition Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Addition Operator のReturn Valueの型は,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  Addition Operator は,例外を発生させません。
</p>
<h3 id="language-operator-subtract">Subtraction Operator </h3>
<p>
  Subtraction Operator は"-"で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression - Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-numeric">numeric type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Subtraction Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型,float型,double型における演算が定義されます。
</p>
<pre>
x - y;
</pre>
<p>
  Subtraction Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Subtraction Operator のReturn Valueの型は,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  Subtraction Operator は,例外を発生させません。
</p>
<h3 id="language-operator-multiply">Multiplication Operator </h3>
<p>
  Multiplication Operator は"*"で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression * Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-numeric">numeric type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Multiplication Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型,float型,double型における演算が定義されます。
</p>
<pre>
x * y;
</pre>
<p>
  Multiplication Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Multiplication Operator のReturn Valueの型は,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  Multiplication Operator は,例外を発生させません。
</p>
<h3 id="language-operator-divide">Division Operator </h3>
<p>
  Division Operator は"/"で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression / Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-numeric">numeric type</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Division Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型,float型,double型における演算が定義されます。
</p>
<pre>
x / y;
</pre>
<p>
  Division Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Division Operator のReturn Valueの型は,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  整数型に対する演算の場合には,Division Operator は,右辺が0であった場合に,例外が発生します。
</p>
<p>
  浮動小数点型に対する演算の場合には,Division Operator は,例外を発生させません。
</p>

<h3 id="language-operator-remainder">Remainder Operator </h3>
<p>
  Remainder Operator は"%"で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression % Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-integral">整数型</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Remainder Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型における演算が定義されます。
</p>
<pre>
x % y;
</pre>
<p>
  Remainder Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Remainder Operator のReturn Valueの型は,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  Remainder Operator は,右辺が0であった場合に,例外が発生します。
</p>

<h3 id="language-operator-inc">Increment Operator </h3>
<p>
  Increment Operator は,値を1加算するOperator です。Increment Operator が前置されるか,後置されるかで,意味が変わります。
</p>
<pre>
# 前置のインクリメント
++Lexical Variable 
++Package Variable 
++Field Access
++Array Access
++Dereference 

# 後置のインクリメント
Lexical Variable ++
Package Variable ++
Field Access++
Array Access++
Dereference ++
</pre>
<p>
  Increment Operator の対象は,<a href="#language-lex-var">Lexical Variable</a>,<a href="#language-package-var">Package Variable</a>,<a href="#language-field-access">Field Access</a>,<a href="#language-array-access">Array Access</a>,<a href="#language-deref">Dereference</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Increment Operator の対象の型は,<a href="#language-type-numeric">numeric type</a>でなければなりません。otherwise コンパイルエラーが発生します。
</p>
<p>
  <b>前置のIncrement Operator </b>
</p>
<p>
  前置のIncrement Operator は,インクリメントを行った後に,インクリメントされた値を返します。
</p>
<p>
  前置のIncrement Operator は,次の式と等価です。対象に1が加算された後に,元の型で型キャストが行われ,対象に代入されます。
</p>
<pre>
(対象 = (型キャスト)(対象 + 1))
</pre>
<p>
  たとえば,byte型の値の前置のインクリメントは,次の式と等価です。
</p>

<pre>
($num = (byte)($num + 1))
</pre>
<p>
  <b>後置のIncrement Operator </b>
</p>
<p>
  後置のIncrement Operator は,インクリメントを行った後に,インクリメントする前の値を返します。
</p>
<p>
  後置のIncrement Operator は,Sequential Operator を使った,次の式と等価です。対象が一時変数に保存され,対象に1が足された後に,元の型で型キャストが行われ,対象に代入されます。その後,一時変数が返されます。
</p>
<pre>
(my 一時変数 = 対象, 対象 = (型キャスト)(対象 + 1), 一時変数)
</pre>
<p>
  たとえば,byte型の値の後置のインクリメントは,次の式と等価です。
</p>

<pre>
(my $tmp = $num, $num = (byte)($num + 1), $tmp)
</pre>

<h3 id="language-operator-dec">Decrement Operator </h3>
<p>
  Decrement Operator は,値を1減算するOperator です。Decrement Operator が前置されるか,後置されるかで,意味が変わります。
</p>
<pre>
# 前置のデクリメント
--Lexical Variable 
--Package Variable 
--Field Access
--Array Access
--Dereference 

# 後置のデクリメント
Lexical Variable --
Package Variable --
Field Access--
Array Access--
Dereference --
</pre>
<p>
  Decrement Operator の対象は,<a href="#language-lex-var">Lexical Variable</a>,<a href="#language-package-var">Package Variable</a>,<a href="#language-field-access">Field Access</a>,<a href="#language-array-access">Array Access</a>,<a href="#language-deref">Dereference</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Decrement Operator の対象の型は,<a href="#language-type-numeric">numeric type</a>でなければなりません。otherwise コンパイルエラーが発生します。
</p>
<p>
  <b>Pre Decrement Operator </b>
</p>
<p>
  Pre Decrement Operator は,デクリメントを行った後に,デクリメントされた値を返します。
</p>
<p>
  Pre Decrement Operator は,次の式と等価です。対象に1が減算された後に,元の型で型キャストが行われ,対象に代入されます。
</p>
<pre>
(対象 = (型キャスト)(対象 - 1))
</pre>
<p>
  たとえば,byte型の値の前置のデクリメントは,次の式と等価です。
</p>

<pre>
($num = (byte)($num - 1))
</pre>
<p>
  <b>Post Decrement Operator </b>
</p>
<p>
  Post Decrement Operator は,デクリメントを行った後に,デクリメントする前の値を返します。
</p>
<p>
  Post Decrement Operator は,Sequential Operator を使った,次の式と等価です。対象が一時変数に保存され,対象に1が足された後に,元の型で型キャストが行われ,対象に代入されます。その後,一時変数が返されます。
</p>
<pre>
(my 一時変数 = 対象, 対象 = (型キャスト)(対象 - 1), 一時変数)
</pre>
<p>
  たとえば,byte型の値の後置のデクリメントは,次の式と等価です。
</p>

<pre>
(my $tmp = $num, $num = (byte)($num - 1), $tmp)
</pre>

<h3 id="language-operator-bit">Bit Operator </h3>
<p>
  Bit Operator は,Bit 演算を行うOperator のことで,><a href="#language-operator-bit-and">Bit AND Operator</a>,<a href="#language-operator-bit-or">Bit OR Operator</a>,<a href="#language-operator-bit-not">Bit NOT Operator</a>からなります。
</p>

<h3 id="language-operator-bit-and">Bit AND Operator </h3>
<p>
  Bit ANDは"&"で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression & Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-integral">整数型</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Bit AND Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型における演算が定義されます。
</p>
<pre>
x & y;
</pre>
<p>
  Bit AND Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Bit AND Operator のReturn Valueの型は,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  Bit AND Operator は,例外を発生させません。
</p>

<h3 id="language-operator-bit-or">Bit OR Operator </h3>
<p>
  Bit ORは"|"で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression | Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-integral">整数型</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Bit OR Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型における演算が定義されます。
</p>
<pre>
x | y;
</pre>
<p>
  Bit OR Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Bit OR Operator のReturn Valueの型は,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  Bit OR Operator は,例外を発生させません。
</p>

<h3 id="language-operator-bit-not">Bit NOT Operator </h3>
<p>
  Bit NOT Operator は"~"で表現される<a href="#language-operator-unary">Unary Operator</a>です。
</p>
<pre>
~式
</pre>
<p>
  式は<a href="#language-type-integral">整数型</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  <a href="#language-expression">式</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,Bit NOT Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型における演算が定義されます。
</p>
<pre>
~x
</pre>
<p>
  Bit NOT Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Bit NOT Operator のReturn Valueの型は,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
</p>
<p>
  Bit NOT Operator は例外を発生させません。
</p>
<p>
  <b>Bit NOT Operator のExample</b>
</p>
<pre>
my $num = ~0xFF0A;
</pre>

<h3 id="language-operator-shift">Shift Operator </h3>
<p>
  Shift Operator は,Bit シフトを行うOperator で,<a href="#language-operator-left-shift">Left Shift Operator</a>,<a href="#language-operator-arithmetic-right-shift">Arithmetic Right Shift Operator</a>,<a href="#language-operator-logical-right-shift">Logical Right Shift Operator</a>からなります。
</p>
<h3 id="language-operator-left-shift">Left Shift Operator </h3>
<p>
  左シフトは"<<"で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression << Right Expression
</pre>
<p>
  Left Expressionは,<a href="#language-type-integral">整数型</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  最初に<a href="#language-expression">Left Expression</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  Right Expressionは,int type でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Left Shift Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型における演算が定義されます。
</p>
<pre>
x << y;
</pre>
<p>
  Left Shift Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Left Shift Operator は,例外を発生させません。
</p>

<h3 id="language-operator-arithmetic-right-shift">Arithmetic Right Shift Operator </h3>
<p>
  算術右シフトは">>"で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression >> Right Expression
</pre>
<p>
  Left Expressionは,<a href="#language-type-integral">整数型</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  最初に<a href="#language-expression">Left Expression</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  Right Expressionは,int type でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Arithmetic Right Shift Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。xに対して,<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型における演算が定義されます。
</p>
<pre>
x >> y;
</pre>
<p>
  Arithmetic Right Shift Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Arithmetic Right Shift Operator は,例外を発生させません。
</p>

<h3 id="language-operator-logical-right-shift">Logical Right Shift Operator </h3>
<p>
  論理右シフトは">>>"で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression >>> Right Expression
</pre>
<p>
  Left Expressionは,<a href="#language-type-integral">整数型</a>でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  最初に<a href="#language-expression">Left Expression</a>に対して,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  Right Expressionは,int type でなければなりません。otherwise a compile-time error occurs.
<p>
<p>
  Logical Right Shift Operator の演算結果は,C99におけるthe following 演算と完全に一致する演算を行います。xに対して,<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型における演算が定義されます。
</p>
<pre>
(符号付整数型キャスト)((符号なし整数型キャスト)x >> y);
</pre>
<p>
  Logical Right Shift Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Logical Right Shift Operator は,例外を発生させません。
</p>

<h3 id="language-operator-comparison">比較Operator </h3>
<p>
  比較Operator とは,Left ExpressionとRight Expressionの間に置かれるOperator で,<a href="#language-expression">式</a>を返すOperator のことをいいます。
</p>
<pre>
Left Expression 比較Operator  Right Expression
</pre>
<p>
  比較Operator には,<a href="#language-operator-comparison-numeric">数値比較Operator</a>,<a href="#language-operator-comparison-string">文字列比較Operator</a>,isa Operator があります。
</p>

<h3 id="language-operator-comparison-numeric">数値比較Operator </h3>
<p>
  数値比較Operator とは,数値あるいはオブジェクトのアドレスを比較するために,Left ExpressionとRight Expressionの間に置かれるOperator で,<a href="#language-expression">式</a>を返すOperator のことをいいます。
</p>
<pre>
Left Expression 数値比較Operator  Right Expression
</pre>
<p>
  数値比較Operator の一覧です。
</p>
<table>
  <tr>
    <th>Operator </th>
    <th>比較可能な型</th>
    <th>解説</th>
  </tr>
  <tr>
    <td>
      Left Expression == Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionがnumeric type,Left ExpressionとRight Expressionがobject type (Undefined Valueを含む)
    </td>
    <td>
      Left ExpressionとRight Expressionが等しい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression != Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionがnumeric type,Left ExpressionとRight Expressionがobject type (Undefined Valueを含む)
    </td>
    <td>
      Left ExpressionとRight Expressionが等しくない
    </td>
  </tr>
  <tr>
    <td>
      Left Expression > Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionがnumeric type
    </td>
    <td>
      Left ExpressionはRight Expressionより大きい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression >= Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionがnumeric type
    </td>
    <td>
      Left ExpressionはRight Expressionより大きいまたは等しい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression < Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionがnumeric type
    </td>
    <td>
      Left ExpressionはRight Expressionより小さい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression <= Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionがnumeric type
    </td>
    <td>
      Left ExpressionはRight Expressionより小さいまたは等しい
    </td>
  </tr>
</table>
<p>
  左辺と右辺の型は,比較可能な型でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  numeric typeの比較の場合は,Left ExpressionとRight Expressionに対して,<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後,数値比較Operator は,C99におけるthe following 演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた,int type ,long型,float型,double型,object type における演算が定義されます。
</p>
<pre>
# numeric typeの比較,object type の比較
(int32_t)(x == y);
(int32_t)(x != y);

# numeric typeの比較
(int32_t)(x > y);
(int32_t)(x >= y);
(int32_t)(x < y);
(int32_t)(x <= y);
</pre>
<p>
  数値比較Operator のReturn Valueの型は,int type です。
</p>
<p>
  数値比較Operator は,例外を発生させません。
</p>

<h3 id="language-operator-comparison-string">文字列比較Operator </h3>
<p>
  文字列比較Operator とは,文字列を比較するために,Left ExpressionとRight Expressionの間に置かれるOperator で,<a href="#language-expression">式</a>を返すOperator のことをいいます。
</p>
<pre>
Left Expression 文字列比較Operator  Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionは,<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
  文字列比較Operator の一覧です。
</p>
<table>
  <tr>
    <th>Operator </th>
    <th>解説</th>
  </tr>
  <tr>
    <td>
      Left Expression eq Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionが等しい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression ne Right Expression
    </td>
    <td>
      Left ExpressionとRight Expressionが等しくない
    </td>
  </tr>
  <tr>
    <td>
      Left Expression gt Right Expression
    </td>
    <td>
      Left ExpressionはRight Expressionより辞書式順序で比較して大きい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression ge Right Expression
    </td>
    <td>
      Left ExpressionはRight Expressionより辞書式順序で比較して大きいまたは等しい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression lt Right Expression
    </td>
    <td>
      Left ExpressionはRight Expressionより辞書式順序で比較して小さい
    </td>
  </tr>
  <tr>
    <td>
      Left Expression le Right Expression
    </td>
    <td>
      Left ExpressionはRight Expressionより辞書式順序で比較して小さいまたは等しい
    </td>
  </tr>
</table>
<p>
  文字列比較Operator のReturn Valueの型は,int type です。条件が満たされた場合は1を,そうでない場合は0を返します。
</p>
<h3 id="language-operator-isa">isa Operator </h3>
<p>
  数値比較Operator とは,数値あるいはオブジェクトのアドレスを比較するために,Left ExpressionとRight Expressionの間に置かれるOperator で,<a href="#language-expression">式</a>を返すOperator のことをいいます。
</p>
<p>
  isa Operator とはは,型の適合性をチェックするためのOperator で,<a href="#language-expression">式</a>を返します。
</p>
<pre>
Left Expression isa 右型
</pre>
<p>
  isa Operator は,右型に応じて,3種類の動作をします。
</p>
<p>
  1. 右型が,<a href="#language-type-numeric">numeric type</a>,<a href="#language-type-multi-numeric">Multi Numeric Type</a>,<a href="#language-type-any-object">Any Object Type</a>,<a href="#language-type-ref">reference type</a>の場合は,コンパイル時にLeft Expressionの型が右型と同一のものであるかをチェックします。同一であった場合はint type で1を,そうでない場合は0を返します。
</p>
<p>
  2. 右型が,<a href="#language-type-class">Class Type</a>であった場合は,実行時にLeft Expressionの型が,Class Typeと一致するかをチェックします。一致した場合はint type で1を,そうでない場合は0を返します。Left Expressionの型は,object type でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  3. 右型が,<a href="#language-type-callback">Callback Type</a>であった場合は,実行時にLeft Expressionの型がClass Typeであり,そのクラスがCallback Typeを満たすかどうかをチェックします。満たした場合はint type の1を,そうでない場合は0を返します。Left Expressionの型は,object type でなければなりません。otherwise a compile-time error occurs.
</p>

<h3 id="language-operator-logical">論理Operator </h3>
<p>
  論理Operator は,論理演算を行うOperator のことで,><a href="#language-operator-logical-and">Logical AND Operator</a>,<a href="#language-operator-logical-or">Logical OR Operator</a>,<a href="#language-operator-logical-not">Logical NOT Operator</a>からなります。
</p>
<p>
  論理Operator は,<a href="#language-expression">式</a>を返します。
</p>

<h3 id="language-operator-logical-and">Logical AND Operator </h3>
<p>
  Logical AND Operator とは,Logical AND演算を行うために,"&&"で表現される,<a href="#language-expresssion">式</a>をオペランドとする<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression && Right Expression
</pre>
<p>
  Logical AND Operator のReturn Valueの型は,int type です。
</p>
<p>
  Logical AND Operator は次のように動作します。
</p>
<p>
  1. Left Expressionに<a href="#language-type-convertion-bool">ブール型変換</a>を実行します。
</p>
<p>
  2. Left Expressionの値が0以外であれば,Right Expressionに対して,<a href="#language-type-convertion-bool">ブール型変換</a>を実行し,その値を返します。
</p>
<p>
  3. Left Expressionの値が0であれば,その値を返します。
</p>
<p>
  Logical AND Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Logical AND Operator は,例外を発生させません。
</p>

<h3 id="language-operator-logical-and">Logical OR Operator </h3>
<p>
  Logical OR Operator とは,Logical OR演算を行うために,"||"で表現される,<a href="#language-expresssion">式</a>をオペランドとする<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression || Right Expression
</pre>
<p>
  Logical OR Operator は次のように動作します。
</p>
<p>
  Logical OR Operator のReturn Valueの型は,int type です。
</p>
<p>
  1. Left Expressionに<a href="#language-type-convertion-bool">ブール型変換</a>を実行します。
</p>
<p>
  2. Left Expressionの値が0あれば,Right Expressionに対して,<a href="#language-type-convertion-bool">ブール型変換</a>を実行し,その値を返します。
</p>
<p>
  3. Left Expressionの値が0以外であれば,その値を返します。
</p>
<p>
  Logical OR Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  Logical OR Operator は,例外を発生させません。
</p>

<h3 id="language-operator-logical-and">論理NOTOperator </h3>
<p>
  論理NOTOperator とは,論理NOT演算を行うために,式の左に置かれるOperator で,"!"で表現される<a href="#language-expression">式</a>を返す<a href="#language-operator-binary">Unary Operator</a>です。式については,<a href="#language-expresssion">式</a>を参考にしてください。
</p>
<pre>
!式
</pre>
<p>
  論理NOTOperator のReturn Valueの型は,int type です。
</p>
<p>
  論理NOTOperator は,式に<a href="#language-type-convertion-bool">ブール型変換</a>を実行し,その値が0の場合は1を,0以外の値の場合は,0を返します。
</p>
<p>
  論理NOTOperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  論理NOTOperator は,例外を発生させません。
</p>

<h3 id="language-operator-concat">文字列連結Operator </h3>
<p>
  文字列連結Operator は"."で表現される<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
Left Expression . Right Expression
</pre>
<p>
  Left ExpressionあるいはRight Expressionが,<a href="#language-type-numeric">numeric type</a>であった場合は,<a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a>によって文字列に変換されます。
</p>
<p>
  Left ExpressionとRight Expressionはどちらも<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。otherwise コンパイルエラーになります。
</p>
<p>
  文字列連結Operator は,Left ExpressionとRight Expressionで表現される<a href="#language-string">文字列</a>を連結し,新しい文字列を返します。
</p>
<p>
  文字列連結Operator は<a href="#language-expression">式</a>を返し,型は<a href="#language-type-string">文字列型</a>です。
</p>
<p>
  Left ExpressionとRight Expressionの両方が,<a href="#language-literal-string">String Literal</a>であった場合は,コンパイル時に連結されたString Literal が生成されます。パフォーマンスのコストを意識せずに,文字列連結Operator で,String Literal を連結できます。
</p>
<p>
  実行時に,Left ExpressionあるいはRight Expressionが<a href="#language-undef">Undefined Value</a>だった場合は,例外が発生します。
</p>
<p>
  <b>文字列連結Operator のExample</b>
</p>
<pre>
my $str = "abc" . "def";
my $str = "def" . 34;
my $str = 123 . 456;
</pre>
<h3 id="language-operator-assign">Assignment Operator </h3>
<p>
  Assignment Operator は"="で表現される,代入を行うための<a href="#language-operator-binary">Binary Operator</a>です。
</p>
<pre>
LEFT_EXPRESSION = RIGHTH_EXPRESSION
</pre>
<p>
  Assignment Operator は,右辺と左辺によって,複数の意味を持ちます。各項目を参考にしてください。
</p>
<p>
  Assignment Operator においては,Right Expressionが評価された後に,Left Expressionが評価されます。これは,原則として,式は左から右へ実行されるということの例外です。
</p>

<ul>
  <li><a href="#language-expression-set-lex-var">Lexical Variable の値の設定</a></li>
</ul>

<h3 id="language-operator-assign-special">Special Assignment Operator </h3>
<p>
  Special Assignment Operator とは,<a href="#language-operator-binary">Binary Operator</a>と<a href="#language-operator-assign">Assignment Operator</a>の組み合わせで表現される特殊な代入を行う<a href="#language-operator-binary">Binary Operator</a>のことです。
</p>
<pre>
Left Expression Special Assignment Operator  Right Expression
</pre>
<p>
  Left ExpressionとRight Expressionが<a href="#language-type-compatible">型の互換性</a>を満たさない場合は,a compile-time error occurs
</p>
<p>
  <b>Special Assignment Operator の一覧</b>
</p>
<p>
  Special Assignment Operator の一覧です。
</p>
<table>
  <tr>
    <td>加算Assignment Operator </td>
    <td>+=</td>
  </tr>
  <tr>
    <td>減算Assignment Operator </td>
    <td>-=</td>
  </tr>
  <tr>
    <td>乗算Assignment Operator </td>
    <td>*=</td>
  </tr>
  <tr>
    <td>除算Assignment Operator </td>
    <td>/=</td>
  </tr>
  <tr>
    <td>剰余Assignment Operator </td>
    <td>%=</td>
  </tr>
  <tr>
    <td>Bit ANDAssignment Operator </td>
    <td>&=</td>
  </tr>
  <tr>
    <td>Bit ORAssignment Operator </td>
    <td>|=</td>
  </tr>
  <tr>
    <td>左シフトAssignment Operator </td>
    <td><<=</td>
  </tr>
  <tr>
    <td>算術右シフトAssignment Operator </td>
    <td>>>=</td>
  </tr>
  <tr>
    <td>論理右シフトAssignment Operator </td>
    <td>>>>=</td>
  </tr>
</table>
<p>
  Special Assignment Operator は,次のように展開されます。
</p>
<pre>
# 展開前
Left Expression Special Assignment Operator  Right Expression

# 展開後
Left Expression Assignment Operator  (Left Expressionの型によるキャスト)(Left Expression 指定されたOperator  Right Expression)
</pre>
<p>
  たとえば,加算Assignment Operator の場合は,次のように展開されます。
</p>
<pre>
# 展開前 xはbyte型
$x += 1;

# 展開後
$x = (byte)($x + 1)
</pre>
<p>
  <b>Special Assignment Operator のExample</b>
</p>
<p>
  Special Assignment Operator のExampleです。
</p>
<pre>
$x += 1;
$x -= 1;
$x *= 1;
$x /= 1;
$x &= 1;
$x |= 1;
$x ^= 1;
$x %= 1;
$x <<= 1;
$x >>= 1;
$x >>>= 1;
</pre>
<h3 id="language-operator-ref">Reference Operator  </h3>
<p>
  Reference Operator  は,<a href="#language-type-numeric">numeric type</a>または<a href="#language-type-multi-numeric">Multi Numeric Type</a>の変数のアドレスを取得するOperator です。C言語のアドレスOperator "&"を実現するために設計されました。
</p>
<pre>
\変数
</pre>
<p>
  変数がnumeric typeまたはMulti Numeric Typeでなかった場合は,a compile-time error occurs
</p>
<p>
  Reference Operator  は式を返します。返される型は,<a href="#language-type-ref">reference type</a>です。
</p>
<pre>
  <b>Reference Operator  のExample</b>
</pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
</pre>
<p>
  リファレンスの詳しい解説については,<a href="#language-ref">リファレンス</a>を見てください。
</p>

<h3 id="language-operator-array-length">Array Length Operator </h3>
<p>
  Array Length Operator は,<a href="#language-array">配列</a>の長さを取得するための"@"で表現される<a href="#language-operator-binary">Unary Operator</a>です。
</p>
<pre>
@Right Expression
</pre>
<p>
  Right Expressionは,array typeでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Array Length Operator は,Array Lengthをint type の値で返します。
</p>
<p>
  Array Length Operator は,<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>Array Length Operator のExample</b>
</p>
<p>
  Array Length Operator のExampleです。
</p>
<pre>
my $nums = new byte[10];
my $length = @$nums;
</pre>
<p>
  SPVMにはPerlにおけるコンテキストという考え方はなく,Array Length Operator は,常にArray Lengthを返すことに注意してください。
</p>

<h3 id="language-operator-string-length">String Length Operator </h3>
<p>
  String Length Operator は,<a href="#language-string">文字列</a>の長さを取得するための"length"で表現される<a href="#language-operator-binary">Unary Operator</a>です。
</p>
<pre>
length Right Expression
</pre>
<p>
  Right Expressionは,<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  String Length Operator は,文字列の長さをint type の値で返します。String Length Operator が返す文字列の長さは,バイト列としてみたときの長さでです。
</p>
<p>
  String Length Operator は,<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>String Length Operator のExample</b>
</p>
<p>
  String Length Operator のExampleです。
</p>
<pre>
my $nums = "abcde";
my $length = length $nums;
</pre>

<h3 id="language-operator-scalar">Scalar Operator </h3>
<p>
  Scalar Operator は,何もしないで,与えられた値そのものを返すOperator です。<a href="language-operator-array-length">Array Length Operator</a>の意味を分かりやすくするためだけに用意されています。
</p>
<pre>
scalar Right Expression
</pre>
<p>
  Right Expressionは<a href="language-operator-array-length">Array Length Operator</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Scalar Operator returns Expression.
</p>
<p>
  <b>Scalar Operator のExample</b>
</p>
<p>
  Scalar Operator のExampleです。
</p>
<pre>
my $nums = new int[3];
foo(scalar @$nums);
</pre>

<h3 id="language-operator-isweak">isweakOperator </h2>
<p>
  isweakOperator は,フィールドが,<a href="#language-weak-ref">Weaken Reference</a>かを確認するOperator です。
</p>
<pre>
isweak 変数->{Field Name};
</pre>
<p>
  オブジェクト式の型は,<a href="#language-type-class">Class Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Field Nameは,存在するField Nameでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  フィールドに保存される値の型は,<a href="#language-type-object">object type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  実行時にフィールドに保存されている値が,<a href="#language-undef">Undefined Value</a>だった場合は,偽を返します。これは,<a href="#language-expression">式</a>です。
</p>
<p>
  isweakOperator は,フィールドがWeaken Referenceの場合は,int type の1を,そうでない場合は0を返します。これは,<a href="#language-expression">式</a>です。
</p>

<h2 id="language-operator-precedence">Operator の優先順位</h2>
<p>
  Operator の優先順位は,the following 通りです。下にいくほど,優先順位が高くなります。
</p>
<table>
  <tr>
    <th>結合方向</th>
    <th>Operator </th>
  </tr>
  <tr>
    <td>
      右結合
    </td>
    <td>
      <ul>
      Assignment Operator "="<br>
      加算Assignment Operator "+="<br>
      減算Assignment Operator "-="<br>
      乗算Assignment Operator "*="<br>
      除算Assignment Operator "/="<br>
      剰余Assignment Operator "%="<br>
      Bit ANDAssignment Operator "&="<br>
      Bit ORAssignment Operator "|="<br>
      Bit 排他ORAssignment Operator "^="<br>
      左シフトAssignment Operator "<<="<br>
      算術右シフトAssignment Operator ">>="<br>
      Logical Right Shift Operator ">>>="<br>
      文字列結合Assignment Operator ".="
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Logical OR Operator "||"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Logical AND Operator  "&&"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Bit OR Operator "|"<br>
      Bit XOR Operator  "^"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Bit AND Operator "&"
    </td>
  </tr>
  <tr>
    <td>
      非結合
    </td>
    <td>
      数値等価Operator "=="<br>
      数値非等価Operator "!="<br>
      文字列等価Operator "eq"<br>
      文字列非等価Operator "ne"<br>
    </td>
  </tr>
  <tr>
    <td>
      非結合
    </td>
    <td>
      数値大なりOperator ">"<br>
      数値小なりOperator "<"<br>
      数値大なり等価Operator ">="<br>
      数値小なり等価Operator "<="<br>
      文字列大なりOperator "gt"<br>
      文字列大なり等価Operator "ge"<br>
      文字列小なりOperator "lt"<br>
      文字列小なり等価Operator "le"<br>
      isa Operator "isa"
    </td>
  </tr>
  <tr>
    <td>
      左結合 
    </td>
    <td>
      Left Shift Operator  "<<"<br>
      符号付き右Shift Operator ">>"<br>
      符号なし右Shift Operator ">>>"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Addition Operator "+"<br>
      Subtraction Operator "-"<br>
      文字列連結Operator "."
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      Multiplication Operator "*"<br>
      Division Operator "/"<br>
      Remainder Operator "%"
    </td>
  </tr>
  <tr>
    <td>
      右結合
    </td>
    <td>
      論理NOTOperator "!"<br>
      Bit NOT Operator "~"<br>
      Reference Operator  "\"<br>
      Plus Operator "+"<br>
      マイナスOperator "-"<br>
      配列長取得Operator "@"<br>
      Dereference Operator "$"<br>
      型キャスト"(TypeName)"
      Scalar Operator "scalar"<br>
      文字列長取得Operator "length"<br>
      requireOperator "require"<br>
    </td>
  </tr>
  <tr>
    <td>
      非結合
    </td>
    <td>
      Pre Increment Operator "++"<br>
      Post Increment Operator "++"<br>
      Pre Decrement Operator "--"<br>
      Post Decrement Operator "--"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      アローOperator "->"<br>
    </td>
  </tr>
</table>
<p>
  Operator の優先順位は"()"を使うことによって,最優先にすることができます。
</p>
<pre>
# a * b が先
a * b + c

# b + c が先
a * (b + c)
</pre>

<h2 id="language-statement">文</h2>
<p>
  文は,ひとつの処理のことで"<a href="#language-scope-block">Scope Block</a>"の中に複数記述することができます。<a href="#language-expression">式</a>のように値として評価されることはありません。
</p>
<p>
  <b>文の一覧</b>
</p>
<p>
  文の一覧です。
</p>
<ul class="list">
  <li><a href="#language-statement-if">if statement</a></li>
  <li><a href="#language-statement-switch">switch statement</a></li>
  <li><a href="#language-statement-case">case statement</a></li>
  <li><a href="#language-statement-while">while statement</a></li>
  <li><a href="#language-statement-for">for statement</a></li>
  <li><a href="#language-statement-default">default statement</a></li>
  <li><a href="#language-statement-block-simple">Simple Block</a></li>
  <li><a href="#language-statement-eval">eval statement</a></li>
  <li><a href="#language-statement-ifrequire">if require文</a></li>
  <li><a href="#language-statement-next">next statement</a></li>
  <li><a href="#language-statement-last">last statement</a></li>
  <li><a href="#language-statement-break">break statement</a></li>
  <li><a href="#language-statement-return">returnl statement</a></li>
  <li><a href="#language-statement-die">die statement</a></li>
  <li><a href="#language-statement-weaken">weaken statement</a></li>
  <li><a href="#language-statement-unweaken">unweaken statement</a></li>
  <li><a href="#language-statement-expression">expression statement</a></li>
  <li><a href="#language-statement-empty">empty statement</a></li>
</ul>

<h3 id="language-statement-if">if statement</h2>
<p>
  if statementは,条件分岐を行うための文です。
</p>
<pre>
if (式) {

}
</pre>
<p>
  式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され,値が0以外の場合に,ブロックが実行されます。
</p>
<p>
  条件を複数書きたい場合には"elsif statement"を続けることができます。 条件判定は上から実行され,それぞれの式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され,値が0以外の場合に対応するブロックが実行されます。
</p>
<pre>
if (式) {

}
elsif(式) {

}
</pre>
<p>
  "else文"を使って,if statementあるいは,elsif statementが条件を満たさなかった場合の処理を記述することができます。if statementとelsif statementの条件判定がすべて偽であった場合にelseのブロックの内部の文が実行されます。elsif statementは,なくてもかまいません。
</p>
<pre>
if (式) {

}
elsif(式) {

}
else {

}
</pre>
<p>
  <b>if statementのExample</b>
</p>
<p>
  if statementのExampleです。
</p>
<pre>
my $flag = 1;

if ($flag == 1) {
print "One\n";
}
elsif ($flag == 2) {
print "Tow\n";
}
else {
print "Other";
}
</pre>
<p>
  if statementは,内部的には,目には見えないSimple Blockで囲まれています。
</p>
<pre>
{
if (式) {

}
}
</pre>
<p>
  elsifは,内部的には,if statementとelse文に展開されます。
</p>
<pre>
# 展開前
if (式1) {

}
elsif (式2) {

}
else {

}

# 展開後
if (式1) {
}
else {
if (式2) {

}
else {

}
}
</pre>
<p>
  if statementの条件部で,変数宣言を行うときは,目には見えない<a href="#language-block-statement-simple">Simple Block</a>で囲まれていることと,elsifは,内部的には,if statementとelse文に展開されるということを,意識してください。
</p>
<pre>
# 展開前
my $num = 1;
if (my $num = 2) {

}
elsif (my $num = 3) {

}
else {

}

# 展開後
my $num = 1;
{
if (my $num = 2) {

}
else {
{
if (my $num = 3) {
  
}
else {
  
}
}
}
}
</pre>

<h3 id="language-statement-switch">switch statement</h3>
<p>
  switch statementは,int type の整数を条件にして,条件分岐を行うための文です。条件がint type の整数で,たくさんの分岐がある場合は,if statementよりも高速です。
</p>
<pre>
switch (条件式) {
  case 定数1: {

    break;
  }
  case 定数2: {

    break;
  }
  case 定数n: {
    break;
  }
  default: {

  }
}
</pre>
<p>
  条件式は,<a href="#language-expression">式</a>を指定できます。条件式には,<a href="#language-type-convertion-bool">ブール型変換</a>が実行されます。
</p>
<p>
  case statementで指定される定数は,byte型かint type の定数でなければなりません。byte型の定数の場合は,コンパイル時に,int type に型変換されます。enum型の値や,int type のConstant Subroutine は,int type の定数として,syntax 解析時に展開されるので,利用することができます。
</p>
<p>
  case statementに指定される定数は,重複してはいけません。重複している場合は,a compile-time error occurs
</p>
<p>
  条件式で指定された値が,case statementで指定された値にマッチした場合は,そのcase statementの位置にジャンプします。
</p>
<p>
  マッチしなかった場合でdefault statementが指定されている場合は,default statementの位置にジャンプします。default statementが指定されていなかった場合は,switchブロックは実行されません。
</p>
<p>
  switch statementには,少なくともひとつのcase statementが必要です。otherwise コンパイルエラーが発生します。
</p>
<p>
  default statementは省略可能です。
</p>
<p>
  switchブロックの直下に記述できるのはcase statementとdefault statementだけです。
</p>
<p>
  caseとdefaultのブロックは省略することができます。
</p>
<pre>
switch (条件式) {
  case 定数1:
  case 定数2:
  {
    break;
  }
  default:
}
</pre>
<p>
  break statementを使用した場合は,switchブロックから抜けることができます。
</p>

<pre>
switch (条件式) {
  case 定数1: {
    break;
  }
  case 定数2: {
    break;
  }
  case 定数n: {
    break;
  }
  default: {

  }
}
</pre>
<p>
  caseのブロックが存在する場合は,最後の文はbreak statementあるいは,returnl statementでなければなりません。otherwise コンパイルエラーが発生します。
</p>

<p>
  <b>switch statementのExample</b>
</p>
<p>
  switch statementのExampleです。
</p>
<pre>
my $code = 2;
switch ($code) {
  case 1: {
  print "1\n";
    break;
  }
  case 2: {
  print "2\n";
    break;
  }
  case 3: {
  print "3\n";
    break;
  }
  case 4:
  case 5:
  {
  print "4 or 5\n"; {
    break;
  }
  default: {
    print "Other\n";
  }
}
</pre>

<h3 id="language-statement-switch">case statement</h3>
<p>
  case statementは,switchブロックの中で使うことができる,条件を指定するための文です。case statementについての詳細は,<a href="#language-statement-switch">switch statement</a>の解説を見てください。
</p>

<h3 id="language-statement-switch">default statement</h3>
<p>
  default statementは,switchブロックの中で使うことができる,デフォルトの条件を指定するための文です。default statementについての詳細は,<a href="#language-statement-switch">switch statement</a>の解説を見てください。
</p>

<h3 id="language-statement-while">while statement</h3>
<p>
  while statementは,繰り返しを行うための文です。
</p>
<pre>
while (条件式) {

}
</pre>
<p>
  条件式に,<a href="#language-expresssion">式</a>を記述できます。条件式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され,値が0以外の場合に,ブロックが実行されます。otherwise ブロックを抜けます。
</p>
<p>
  <b>while statementのExample</b>
</p>
<p>
  while statementのExampleです。
</p>
<pre>
my $i = 0;
while ($i < 5) {

  print "$i\n";

  $i++;
}
</pre>
<p>
  whileブロックの内部では,<a href="#language-statement-last">last statement</a>を使って,whileブロックを抜けることができます。
</p>
<pre>
while (1) {
  last;
}
</pre>

<p>
  whileブロックの内部では,<a href="#language-statement-next">next statement</a>を使って,次に実行される条件式の直前に移動することができます。
</p>
<pre>
my $i = 0;
while ($i < 5) {

  if ($i == 3) {
    $i++;
    next;
  }

  print "$i\n";
  $i++;
}
</pre>

<p>
  while statementは,内部的には,目には見えない<a href="#language-block-statement-simple">Simple Block</a>で囲まれています。
</p>
<pre>
{
  while (条件式) {

  }
}
</pre>
<p>
  while statementの条件部で,変数宣言を行うときは,目には見えない<a href="#language-block-statement-simple">Simple Block</a>で囲まれていることを意識してください。
</p>
<pre>
# 展開前
my $num = 5;
while (my $num = 3) {

  $i++;
}

# 展開後
my $num = 5;
{
  while (my $num = 3) {

    $i++;
  }
}
</pre>

<h3 id="language-statement-for">for statement</h3>
<p>
  for statementは,繰り返しを行うための文です。
</p>
<pre>
for (初期化式; 条件式; インクリメント式) {

}
</pre>
<p>
  初期化式には,<a href="#language-expression">式</a>を記述できます。一般的には,ループ変数の初期化などの式を記述します。初期化式は省略することが可能です。
</p>
<p>
  条件式,<a href="#language-expresssion">式</a>を記述できます。条件式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され,値が0以外の場合に,ブロックが実行されます。otherwise ブロックを抜けます。
</p>
<p>
  インクリメント式には,<a href="#language-expression">式</a>を記述できます。一般的には,ループ変数のインクリメントの式を記述します。インクリメント式は省略することが可能です。
</p>
<p>
  for statementはthe following while statementと同じ意味を持ちます。インクリメント式は,ブロックの最後に実行されます。初期化式は,<a href="#language-block-statement-simple">Simple Block</a>に囲まれています。
</p>
<pre>
{
  初期化式;
  while (条件式) {



    インクリメント式;
  }
}
</pre>
<p>
  <b>for statementのExample</b>
</p>
<p>
  for statementのExampleです。
</p>
<pre>
for (my $i = 0; $i < 5; $i++) {

  print "$i\n";
}
</pre>
<p>
  forブロックの内部では,<a href="#language-statement-last">last statement</a>を使って,forブロックを抜けることができます。
</p>

<pre>
for (初期化式; 条件式; インクリメント式) {

}
</pre>

<p>
  forブロックの内部では,<a href="#language-statement-next">next statement</a>を使って,次に実行されるインクリメント式の直前に移動することができます。
</p>
<pre>
for (my $i = 0; $i < 5; $i++) {

  if ($i == 3) {
    next;
  }
}
</pre>

<h3 id="language-statement-return">returnl statement</h3>
<p>
  returnl statementを使うと,Subroutine から脱出します。モータル変数に代入されているオブジェクトは,自動的に解放されます。
</p>
<pre>
return;
</pre>
<p>
  Return Valueがある場合は,<a href="#language-expression">式</a>を指定することができます。
</p>
<pre>
return 式;
</pre>
<p>
  <a href="#language-sub-definition">Subroutine Definition</a>においてReturn Valueの型が"void type"である場合は,式が存在してはいけません。otherwise a compile-time error occurs.
</p>
<p>
  <a href="#language-sub-definition">Subroutine Definition</a>においてReturn Valueの型が"void type"以外の場合は,式の型と一致していなければなりません。otherwise a compile-time error occurs.
</p>

<h3 id="language-statement-die">die statement </h3>
<p>
  die statement は,例外を発生させるための文です。
</p>
<pre>
die 式;
</pre>
<p>
  式は,文字列互換型でなければなりません。
</p>
<p>
  die statement の詳しい解説については,<a href="#language-exception">Exception Handling</a>を見てください。
</p>

<h3 id="language-statement-weaken">weaken statement </h3>
<p>
  weaken statement は,フィールドに対して,<a href="#language-weak-ref">Weaken Reference</a>を設定する文です。
</p>
<pre>
weaken 変数->{Field Name};
</pre>
<p>
  オブジェクト式の型は,<a href="#language-type-class">Class Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Field Nameは,存在するField Nameでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  フィールドに保存される値の型は,<a href="#language-type-object">object type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  実行時にフィールドに保存されている値が,<a href="#language-undef">Undefined Value</a>だった場合は,weaken statement は,何もしません。
</p>
<p>
  実行時にフィールドに保存されている値が,<a href="#language-undef">Undefined Value</a>でない場合は,次のことが行われます。
</p>
<p>
  1. フィールドに保存されているオブジェクトのReference Countを1減らします。
</p>
<p>
  2. フィールドに,Weaken Referenceフラグを設定します。
</p>
<p>
  3. フィールドに保存されているオブジェクトのバックリファレンスに,フィールドを追加します。
</p>
<p>
  Weaken Referenceフラグは,フィールドに保存されているオブジェクトに設定されるのではなく,フィールド自体に設定されることに注意してください。
</p>
<p>
  フィールドに保存されているオブジェクトのReference Countが,0になってしまった場合は,Weaken Referenceは作成されず,フィールドに保存されているオブジェクトは解放されます。
</p>
<p>
  バックリファレンスとは,フィールドに保存されているオブジェクトが持つデータで,Weaken Referenceフラグが設定されたフィールドを知るために,追加されます。これは,複数存在することがあります。
</p>
<pre>
# バックリファレンスが,複数あるExample
my $foo = new Foo;
my $bar = new Bar;
my $baz = new Baz;

$foo->{bar} = $bar;
$foo->{baz} = $baz;

$bar->{foo} = $foo;
$baz->{foo} = $foo;

weaken $bar->{foo};
weaken $baz->{foo};
</pre>
<p>
  上記の例では"$bar->{foo}"と"$baz->{foo}"に,Weaken Referenceフラグが立ちます。$fooで表現されるオブジェクトは,バックリファレンス"$bar->{foo}"と"$baz->{foo}"を持ちます。
</p>
<p>
  バックリファレンスの情報が必要なのは,<a href="#language-expression-release-object">オブジェクトの解放</a>が行われるときに,バックリファレンスが指すフィールドにUndefined Valueを代入する必要があるからです。
</p>

<h3 id="language-statement-unweaken">unweaken statement</h3>
<p>
  unweaken statementは,フィールドに対して,<a href="#language-weak-ref">Weaken Reference</a>を解除する文です。
</p>
<pre>
unweaken 変数->{Field Name};
</pre>
<p>
  オブジェクト式の型は,<a href="#language-type-class">Class Type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  Field Nameは,存在するField Nameでなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  フィールドに保存される値の型は,<a href="#language-type-object">object type</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  実行時にフィールドに保存されている値が,<a href="#language-undef">Undefined Value</a>だった場合は,unweaken statementは,何もしません。
</p>
<p>
  実行時にフィールドに保存されている値が,<a href="#language-undef">Undefined Value</a>でない場合は,次のことが行われます。
</p>
<p>
  1. フィールドに保存されているオブジェクトのReference Countを1増やします。
</p>
<p>
  2. フィールドのWeaken Referenceフラグを解除します。
</p>
<p>
  3. フィールドに保存されているオブジェクトのバックリファレンスから,フィールドを削除します。
</p>

<h3 id="language-statement-next">next statement</h3>
<p>
  "next statement"は,次のループの先頭に移動するための文です。<a href="#language-block-statement-while">whileブロック</a>,<a href="#language-block-statement-for">forブロック</a>の中で使うことができます。
</p>
<pre>
next;
</pre>
<p>
  実際の動作については<a href="#language-statement-while">while statement</a>,<a href="#language-statement-for">for statement</a>の解説を見てください。
</p>

<h3 id="language-statement-last">last statement</h3>
<p>
  "last statement"は,ループを脱出するための文です。<a href="#language-block-statement-while">whileブロック</a>,<a href="#language-block-statement-for">forブロック</a>の中で使うことができます。
</p>
<p>
  実際の動作については<a href="#language-statement-while">while statement</a>,<a href="#language-statement-for">for statement</a>の解説を見てください。
</p>
<pre>
last;
</pre>

<h3 id="language-statement-break">break statement</h3>
<p>
  "break statement"は,switchブロックを脱出するための文です。<a href="#language-block-statement-switch">switchブロック</a>の中で使うことができます。
</p>
<p>
  実際の動作については<a href="#language-statement-switch">switch statement</a>の解説を見てください。
</p>
<pre>
break;
</pre>

<h3 id="language-statement-expression">expression statement</h3>
<p>
  expression statementは"<a href="#language-expression">式</a>"と";"で構成される文のことです。
</p>
<pre>
式;
</pre>

<p>
  expression statementのExampleです。
</p>
<pre>
1;
$var;
1 + 2;
foo();
my $num = 1 + 2;
</pre>

<h3 id="language-statement-empty">empty statement</h3>
<p>
  empty statementは";"だけで終わる文のことです。
</p>
<pre>
;
</pre>

<h2 id="language-type">型</h2>
<ul class="list">
  <li><a href="#language-type-summary">型の概要</a></li>
  <li><a href="#language-type-initial-value">Type Initial Value</a></li>
  <li><a href="#language-type-void">void type</a></li>
  <li><a href="#language-type-numeric">numeric type</a></li>
  <li><a href="#language-type-integral">整数型</a></li>
  <li><a href="#language-type-byte">byte型</a></li>
  <li><a href="#language-type-short">short型</a></li>
  <li><a href="#language-type-int">int type</a></li>
  <li><a href="#language-type-long">long型</a></li>
  <li><a href="#language-type-floating-point">浮動小数点型</a></li>
  <li><a href="#language-type-float">float型</a></li>
  <li><a href="#language-type-double">double型</a></li>
  <li><a href="#language-type-package">Package 型</a></li>
  <li><a href="#language-type-object">object type</a></li>
  <li><a href="#language-type-numeric-object">数値object type</a></li>
  <li><a href="#language-type-undef">未定義型</a></li>
  <li><a href="#language-type-class">Class Type</a></li>
  <li><a href="#language-type-callback">Callback Type</a></li>
  <li><a href="#language-type-any-object">Any Object Type</a></li>
  <li><a href="#language-type-self">self type</a></li>
  <li><a href="#language-type-array">array type</a></li>
  <li><a href="#language-type-array-numeric">数値array type</a></li>
  <li><a href="#language-type-array-byte">byte[]型</a></li>
  <li><a href="#language-type-array-object">オブジェクトarray type</a></li>
  <li><a href="#language-type-array-value">値array type</a></li>
  <li><a href="#language-type-any-object-array">汎用オブジェクトarray type</a></li>
  <li><a href="#language-type-string">文字列型</a></li>
  <li><a href="#language-type-string-compatible">文字列互換型</a></li>
  <li><a href="#language-type-multi-numeric">Multi Numeric Type</a></li>
  <li><a href="#language-type-ref">reference type</a></li>
  <li><a href="#language-type-ref-numeric">数値のreference type</a></li>
  <li><a href="#language-type-ref-multi-numeric">複数数値のreference type</a></li>
</ul>
<h3 id="language-type-summary">型の概要</h2>
<p>
  SPVMは,静的型言語です。すべてのデータは静的な型を持ちます。
</p>
<p>
  Lexical Variable Declaration ,Field Definition,Package Variable Definition,Subroutine Definitionの引数とReturn Valueにおいて,型が指定される必要があります。
</p>
<p>
  Lexical Variable Declaration においては,型推論を利用して,暗黙的に型を指定することもできます。
</p>
<h3 id="language-type-initial-value">Type Initial Value</h2>
<p>
  Lexical Variable Initial Value,<a href="#language-package-var-initial-value">Package Variable Initial Value</a>,Object Creatingにおけるフィールドの初期値は,Type Initial Valueによって決まります。
</p>
<p>
  Type Initial Valueの一覧です。データにおけるすべてのBit 列は0に設定されます。
</p>
</p>
<table>
  <tr>
    <th>
      <b>Type Name </b>
    </th>
    <th>
      初期値
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>object type </b>
    </td>
    <td>
      undef
    </td>
  </tr>
  <tr>
    <td>
      <b>Multi Numeric Type</b>
    </td>
    <td>
      すべてのフィールドが0
    </td>
  </tr>
</table>

<h3 id="language-type-numeric">numeric type</h2>
<p>
  numeric typeは"<a href="#language-type-integral">整数型</a>"と"<a href="#language-type-floating-point">浮動小数点型</a>"からなります。
</p>

<h3 id="language-type-integral">整数型</h2>
<p>
  SPVMの整数型はthe following 4つです。
</p>
<table>
  <tr>
    <th>
      <b>Type Name </b>
    </th>
    <th>
      説明
    </th>
    <th>
      サイズ
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      signed 8-bit integer type
    </td>
    <td>
      1 byte
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      signed 16-bit integer type
    </td>
    <td>
      2 bytes
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      signed 32-bit integer type
    </td>
    <td>
      4 bytes
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      signed 64-bit integer type
    </td>
    <td>
      8 bytes
    </td>
  </tr>
</table>
<p>
  SPVMの整数型には,符号なし整数型は存在しません。
</p>
<p>
  整数の計算規則については,<a href="#language-operator-arithmetic">Arithmetic Operator</a>を参考にしてください。
</p>
<h3 id="language-type-byte">byte型</h2>
<p>
  byte型は,符号付8bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint8_t型と同じ型です。
</p>
<h3 id="language-type-short">short型</h2>
<p>
  byte型は,符号付16bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint16_t型と同じ型です。
</p>
<h3 id="language-type-int">int type </h2>
<p>
  int type は,符号付32bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint32_t型と同じ型です。
</p>
<h3 id="language-type-long">long型</h2>
<p>
  long型は,符号付64bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint64_t型と同じ型です。
</p>

<h3 id="language-type-floating-point">浮動小数点型</h2>
<p>
  SPVMの浮動小数点型はthe following 2つです。
</p>
<table>
  <tr>
    <th>
      <b>Type Name </b>
    </th>
    <th>
      説明
    </th>
    <th>
      サイズ
    </th>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      単精度浮動小数点型 - 32bitで浮動小数点を表現します
    </td>
    <td>
      4バイト
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      倍精度浮動小数点型 - 64bitで浮動小数点を表現します
    </td>
    <td>
      8バイト
    </td>
  </tr>
</table>
<p>
  浮動小数点の計算規則については,<a href="#language-operator-arithmetic">Arithmetic Operator</a>を参考にしてください。
</p>

<h3 id="language-type-float">float型</h2>
<p>
  float型は,単精度浮動小数点(32bit)を表現する<a href="#language-type-floating-point">浮動小数点型</a>です。C99のfloat型と同じ型です。
</p>

<h3 id="language-type-double">double型</h2>
<p>
  double型は,倍精度浮動小数点(64bit)を表現する<a href="#language-type-floating-point">浮動小数点型</a>です。C99のdouble型と同じ型です。
</p>

<h3 id="language-type-package">Package 型</h3>
<p>
  Package 型とは"<a href="#language-package-definition">Package Definition</a>"によって定義される型のことをいいます。
</p>
<pre>
package Foo {

}
</pre>
<p>
  Package 型は"<a href="#language-type-class">Class Type</a>""<a href="#language-type-callback">Callback Type</a>""<a href="#language-type-multi-numeric">Multi Numeric Type</a>"からなります。
</p>
<pre>
# Class Type
package Foo {

}

# Callback Type
package Foo : callback_t {

}

# Multi Numeric Type
package Foo : mulnum_t {

}
</pre>
<p>
  <a href="#language-type-pointer">Pointer Type</a>は,Class Typeでもあるので,Pointer TypeもPackage 型になります。
</p>
<pre>
# Pointer Type
package Foo : pointer_t {

}
</pre>

<h3 id="language-type-object">object type </h3>
<p>
  object type とは"<a href="#language-type-class">Class Type</a>""<a href="#language-type-callback">Callback Type</a>""<a href="#language-type-array">array type</a>""<a href="#language-type-string">文字列型</a>""<a href="#language-type-any-object">Any Object Type</a>"を合わせたものをいいます。"Multi Numeric Type""reference type "は含みません。
</p>
<p>
  object type の値は"Any Object Type "に代入できます。
</p>
<pre>
my $object : object = new Foo;
my $object : object = new Foo[];
my $object : object = "abc";
</pre>
<p>
  object type のサイズはC99における"sizeof(void*)"の値と一致していなければなりません。
</p>

<h3 id="language-type-numeric-object">数値object type </h3>
<p>
  SPVMには,数値object type としてthe following 型があります。
</p>
<table>
  <tr>
    <th>
      <b>numeric type</b>
    </th>
    <th>
      対応する数値object type 
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      SPVM::Byte
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      SPVM::Short
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      SPVM::Int
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      SPVM::Long
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      SPVM::Float
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      SPVM::Double
    </td>
  </tr>
</table>

<h3 id="language-type-undef">未定義型</h3>
<p>
  未定義型とは,<a href="#language-undef">Undefined Value</a>が持っている型のことです。明示的に利用することはできません。
</p>
<p>
  未定義型の値は<a href="#language-undef">Undefined Value</a>のみです。
</p>
<p>
  未定義型の値は,object type に代入できます。他の型に代入した場合は,a compile-time error occurs
</p>

<h3 id="language-type-class">Class Type</h3>
<p>
  Class Typeとは"<a href="#language-package-definition">Package Definition</a>"によって定義される型で"Multi Numeric Type""Callback Type"ではない型のことをいいます。
</p>
<pre>
packag Foo {

}
</pre>
<p>
  Class TypeはnewOperator によって,オブジェクトを生成することができます。
</p>
<pre>
my $foo = new Foo;
</pre>
<p>
  Class Typeは<a href="#language-type-object">object type</a>です。
</p>
<p>
  Class Typeは<a href="#language-type-package">Package 型</a>です。
</p>
<p>
  "<a href="#language-type-pointer">Pointer Type</a>はClass Typeです。
</p>

<h3 id="language-type-pointer">Pointer Type</h3>
<p>
  Pointer Typeとは"<a href="#language-package-definition">Package Definition</a>"において"pointer_t Descriptor"が指定されたものをいいます。
</p>
<pre>
package Foo : pointer_t {

}
</pre>
<p>
  Pointer Typeは,Class Typeの一種です。
</p>
<p>
  Pointer Typeのデータには,C言語のポインタを保存することができます。
</p>
<p>
  Pointer Typeには,フィールドを定義することはできません。定義されていた場合は,a compile-time error occurs
</p>
<h3 id="language-type-callback">Callback Type</h3>
<p>
  Callback Typeとは"<a href="#language-package-definition">Package Definition</a>"において"callback_t Descriptor"が指定されたものをいいます。
</p>
<pre>
package SPVM::Comparator : callback_t {
  sub : int ($self : self, $x1 : object, $x2 : object);
}
</pre>
<p>
  Callback Typeは,C言語における関数ポインタに該当する機能を提供するために設計されました。
</p>
<p>
  Callback Typeは,Subroutine Definitionを一つだけ持ちます。Subroutine は,<a href="#language-sub-method">メソッド</a>でなければなりません。
</p>
<p>
  Callback TypeのSubroutine Nameは,無名でなければなりません。
</p>
<p>
  Callback Typeは"<a href="#language-field-definition">Field Definition</a>""<a href="#language-package-var-definition">Package Variable Definition</a>"を持つことはできません。
</p>
<p>
  Callback Typeの値を,newOperator によって実体化することはできません。
</p>
<p>
  Callback Typeは"Package 型"です。
</p>
<p>
  Callback Typeは"object type "です。
</p>
<p>
  Callback Typeには,コールバックを満たしたClass Typeのオブジェクトを代入できます。この場合,Class TypeはCallback Typeに適合するといいます。Class TypeがCallback Typeを満たすのは次の二つの場合です。
</p>
<p>
  1. Callback Typeとして定義されたSubroutine と同一の名前とシグネチャを持つClass Typeのオブジェクトは,Callback Typeに代入できます。
</p>
<pre>
# Callback Typeの定義
package SPVM::Comparator : callback_t {
  sub : int ($self : self, $x1 : object, $x2 : object);
}

# クラスの定義
package SomeComparator {
  sub new : int () {
    return new SomeComparator;
  }

  sub : int ($self : self, $x1 : object, $x2 : object) {

  }
}

# Callback Typeへの代入
my $comparator : SPVM::Comparator = SomeComparator->new;
</pre>
<p>
  2. Callback Typeとして定義されたSubroutine と同一のシグネチャを持つコールバックObject Creatingを行うと,Callback Typeに代入できます。
</p>
<pre>
# Callback Typeの定義
package SPVM::Comparator : callback_t {
  sub : int ($self : self, $x1 : object, $x2 : object);
}

# Callback Typeへの代入
my $comparator : SPVM::Comparator = sub : int ($self : self, $x1 : object, $x2 : object) {

}
</pre>

<h3 id="language-type-any-object">Any Object Type </h3>
<p>
  Any Object Type は"object"で表現します。C言語の"void*"型を表現するために設計されました。
</p>
<pre>
my $object : object;
</pre>
<p>
  Any Object Type には"object type "の値を代入できます。
</p>
<pre>
my $object : object = new Foo;
my $object : object = "abc";
my $object : object = new Foo[3];
</pre>

<h3 id="language-type-self">self type</h3>
<p>
  self typeとは,自身の属するPackage 型を表現し,引数がInvocant であることを示します。
</p>
<p>
  <a href="#language-sub-definition">Subroutine Definition</a>において第一引数の型としてのみ利用できます。
</p>

<h3 id="language-type-void">void type</h3>
<p>
  void typeとは,<a href="#language-sub-definition">Subroutine Definition</a>においてReturn Valueの型としてだけ利用できる,存在しないことを示す特別な型です。
</p>

<h3 id="language-type-basic">基本型</h3>
<p>
  次元を持たない型を基本型と呼びます。<a href="#language-type-numeric">numeric type</a>,<a href="#language-type-package">Package 型</a>,<a href="#language-type-any-object">Any Object Type</a>,<a href="#language-type-string">文字列型</a>は,基本型です。
</p>

<h3 id="language-type-array">array type</h3>
<p>
  array typeは,連続した複数のデータ領域を表現します。<a href="#language-type-basic">基本型</a>は,配列にすることができます。
</p>
<pre>
int[]
double[]
Point[]
object[]
string[]
</pre>
<p>
  配列は次元を持ち最大255次元まで表現できます。
</p>
<pre>
# 二次元
int[][]

# 三次元
int[][][]
</pre>
<p>
  array typeは,<a href="#language-type-object">object type</a>です。
</p>
<p>
  配列を作成するには,newOperator を使用します。the following 例では,要素数が3のint type の配列を作成しています。
</p>
<p>
my $nums = new int[3];
</p>
<p>
  多次元配列を作成するときも,newOperator を使用します。the following 例では,要素数が3のint[]型の配列を作成しています。
</p>
<p>
my $nums = new int[][3];
</p>
<h3 id="language-type-array-numeric">数値のarray type</h3>
<p>
  数値のarray typeとは,<a href="#language-type-numeric">numeric type</a>の値を要素に持つ<a href="#language-type-array">array type</a>のことです。
</p>
<p>
  <b>数値のarray typeの一覧</b>
</p>
<ul class="list">
  <li>
    byte[]
  </li>
  <li>
    short[]
  </li>
  <li>
    int[]
  </li>
  <li>
    long[]
  </li>
  <li>
    float[]
  </li>
  <li>
    double[]
  </li>
</ul>
<p>
  数値のarray typeによって表現されるデータは,要素が<a href="#language-type-numeric">numeric type</a>のサイズで,Array Lengthの個数で連続していなければなりません。
</p>
<p>
  数値のarray typeのすべての要素は,Array Creatingが行われたときに<a href="#language-type-initial-value">Type Initial Value</a>によって初期化されます。
</p>
<h3 id="language-type-array-byte">byte[]型</h3>
<p>
  SPVMにおいては,byte[]型は<a href="#language-type-string-compatible">文字列互換型</a>であるという点において特別な型です。
</p>
<pre>
byte[]
</pre>
<p>
  <a href="#language-type-string">文字列型</a>は,コンパイル時には文字列型として扱われますが,実行時にはbyte[]型になります。
</p>

<h3 id="language-type-array-object">オブジェクトのarray type</h3>
<p>
  オブジェクトのarray typeとは,<a href="#language-type-object">object type</a>の値を要素に持つ<a href="#language-type-array">array type</a>のことです。
</p>
<p>
  <b>オブジェクトのarray typeのExample</b>
</p>
<ul class="list">
  <li>
    Foo[]
  </li>
  <li>
    Foo[][]
  </li>
  <li>
    Comparable[]
  </li>
  <li>
    object[]
  </li>
</ul>
<p>
  オブジェクトのarray typeによって表現されるデータは,要素が<a href="#language-type-object">object type</a>のサイズで,Array Lengthの個数で連続していなければなりません。
</p>
<p>
  オブジェクトのarray typeのすべての要素は,Array Creatingが行われたときに<a href="#language-type-initial-value">Type Initial Value</a>によって初期化されます。
</p>

<h3 id="language-type-array-value">値のarray type</h3>
<p>
  値のarray typeとは,<a href="#language-type-multi-numeric">Multi Numeric Type</a>の値を要素に持つ<a href="#language-type-array">array type</a>のことです。
</p>
<p>
  <b>値のarray typeのExample</b>
</p>
<ul class="list">
  <li>
    Complex_2d[]
  </li>
  <li>
    Complex_2f[]
  </li>
</ul>
<p>
  値のarray typeによって表現されるデータは,要素が<a href="#language-type-numeric">Multi Numeric Type</a>のサイズで,Array Lengthの個数で連続していなければなりません。
</p>
<p>
  値のarray typeのすべての要素は,Array Creatingが行われたときに<a href="#language-type-initial-value">Type Initial Value</a>によって初期化されます。
</p>

<h3 id="language-type-any-object-array">汎用オブジェクトarray type</h3>
<p>
  汎用オブジェクトarray typeとは,oarrayで表現される,<a href="#language-type-object">object type</a>の値を要素として持つ任意の<a href="#language-type-array">array type</a>の値を代入できる型です。C言語のqsort関数の第一引数には,任意のarray typeをvoid*型にキャストして渡すことができますが,これに該当する機能を実現するために,汎用オブジェクトarray typeは設計されました。
</p>
<pre>
my $array : oarray = new Point[3];
my $array : oarray = new object[3];
</pre>
<p>
  object type 以外の型を持つ値が代入された場合は,a compile-time error occurs
</p>
<p>
  "oarray型"は"object[]型"と異なる型であることに注意してください。oarray型は,object type の値を要素として持つ任意のarray typeの値を代入できる型であるのに対して,"object[]型"は,"object型の値を要素に持つ配列"を表現する型で,任意のarray typeの値を代入することはできません。
</p>
<p>
  汎用オブジェクトarray typeは,<a href="#language-type-array">array type</a>です。<a href="#language-operator-array-length">Array Length Operator</a>によって長さを取得すること,<a href="#language-expression-set-array-element">配列の要素の値の設定</a>,<a href="#language-expression-get-array-element">配列の要素の値の取得</a>ができます。
</p>
<pre>
my $array : oarray = new SPVM::Int[3];

# 汎用オブジェクトarray typeの要素の長さを取得
my $legnth = @$array;

# 汎用オブジェクトarray typeの要素の値の取得
my $num = (SPVM::Int)$array->[0];

# 汎用オブジェクトarray typeの要素の値の設定
$array->[0] = SPVM::Int->new(5);
</pre>
<p>
  汎用オブジェクトarray typeの要素の値の設定においては,要素の型が,配列のType Dimensionよりも1だけ小さくなっているかの実行時チェックが入ります。チェックに失敗した場合は,例外が発生します。汎用オブジェクトarray typeは,実行時型安全性を保証します。
</p>

<h3 id="language-type-string">文字列型</h3>
<p>
  文字列型は,文字列を表現する型です。stringによって表現します。C言語の"const char*"を表現するために設計されました。
</p>
<pre>
my $str : string;
</pre>
<p>
  String Literal によって,生成された文字列オブジェクトを代入できます。
</p>
<pre>
my $str : string = "abc";
</pre>
<p>
  SPVMの文字列は,要素を変更できないバイト型の配列です。配列アクセスを行って,文字を取得することができます。
</p>
<pre>
# 文字の取得
my $ch = $str->[1];
</pre>
<p>
  要素を変更しようとした場合は,a compile-time error occurs
</p>
<pre>
# 要素の変更はコンパイルエラー
$str->[1] = 'd';
</pre>
<p>
  文字列型は,コンパイルが終わった後は,バイト型の配列とまったく同じものになります。たとえば,一つ目の表現は,二つ目の表現として扱われます。
</p>
<pre>
# isa 文字列型
if ($str isa string) {

}

# isa バイト型の配列
if ($str isa byte[]) {

}
</pre>
<p>
  SPVMの文字列は,変更不可ですが,これは,コンパイル時チェックであることに注意してください。
</p>
<p>
  文字列型は,byte[]型に,キャストすることができ,実行時に文字列を変更することができます。
</p>
<pre>
my $bytes = (byte[])$str;
$bytes->[1] = 'd';
</pre>
<p>
  文字列は,常に変更が可能であるものとして,扱ってください。
</p>

<h3 id="language-type-string-compatible">文字列互換型</h3>
<p>
  文字列互換型とは,<a href="#language-type-string">文字列型</a>と<a href="#language-type-array-byte">byte[]型</a>のことを言います。
</p>
<p>
  文字列互換型の値が生成される場合には,値のために確保されたメモリ領域の最後のひとつ後ろは"\0"になることが保証されます。(たとえば"abc"であれば"c"の後ろは"\0")SPVM言語から見た場合,この"\0"は意味を持ちませんが,ネイティブAPIを使う場合は,文字列互換型を,C言語の文字列として扱うことができます。
</p>

<h3 id="language-type-multi-numeric">Multi Numeric Type</h3>
<p>
  Multi Numeric Typeとは,連続した数値を表現できる型です。
</p>
<p>
  Package Definitionにおいて"mulnum_t"Descriptorを指定することで,Multi Numeric Typeを定義できます。
</p>
<pre>
package Point_3i : mulnum_t {
  has x : int;
  has y : int;
  has z : int;
}
</pre>
<p>
  Multi Numeric Typeの詳しい解説については,<a href="#language-value">値</a>を見てください。
</p>

<h3 id="language-type-ref">reference type </h3>
<p>
  reference type とは,変数のアドレスが格納できる型のことです。<a href="#language-type-numeric">numeric type</a>あるいは<a href="#language-type-multi-numeric">Multi Numeric Type</a>の後ろに"&"を付けることで定義できます。
</p>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $point : Point_3i;;
my $point_ref : Point_3i& = \$point;
</pre>
<p>
  reference type の値に代入できるのは,<a href="#language-operator-ref">Reference Operator</a>で取得したLexical Variable のアドレスだけです。
</p>
<p>
  reference type のLexical Variable Declaration だけが行われた場合は,a compile-time error occurs
</p>
<p>
  reference type は,<a href="#language-lex-var-declaration">Lexical Variable Declaration</a>の型として利用できます。必ずReference Operator  によって,Lexical Variable のアドレスが格納される必要があります。Lexical Variable Declaration だけの場合は,a compile-time error occurs
</p>
<p>
  reference type は,<a href="#language-sub-definition">Subroutine Definition</a>における引数の型として利用できます。
</p>
<p>
  reference type は,<a href="#language-sub-definition">Subroutine Definition</a>におけるReturn Valueの型として利用できません。
</p>
<p>
  reference type は,<a href="#language-package-definition">Package Definition</a>におけるフィールドの型として利用できません。
</p>
<p>
  reference type は,<a href="#language-package-definition">Package Definition</a>におけるPackage Variable の型として利用できません。
</p>
<p>
  Invalid 場所で,reference type が使用された場合は,a compile-time error occurs
</p>
<p>
  リファレンスの詳しい解説については,<a href="#language-ref">リファレンス</a>を見てください。
</p>

<h2 id="language-type-inference">型推論</h2>
<p>
  型推論によって,<a href="#language-lex-var-declaration">Lexical Variable Declaration</a>するときに,<a href="#language-type">型</a>の指定を省略することができます。型推論は,常にAssignment Operator の右辺の型によって,行われます。
</p>
<pre>
# int
my $num = 1;

# double
my $num = 1.0;

# Foo
my $foo = new Foo;
</pre>
<h2 id="language-type-compatible">型の互換性</h2>
<p>
  型に互換性があるというのは,<a href="#language-expression-typecast">型キャスト</a>を行わないで,値が移動ができる型のことです。
</p>
<p>
  型に互換性があるのは次の場合です。
</p>
<p>
  <b>移動元と移動先の型が同一の場合</b>
</p>
<p>
  移動元と移動先の型が同一の場合は,型の互換性があります。
</p>
<pre>
my $num1 : int;
my $num2 : int;
$num1 = $num2;
</pre>
<p>
  <b>移動元の型がbyte[]型で,移動先の型が文字列型の場合</b>
</p>
<p>
  移動元の型がbyte[]型で,移動先の型が文字列型の場合は,型の互換性があります。
</p>
<pre>
my $bytes = new byte[3];
my $str : string;
$str = $bytes;
</pre>
<p>
  <b>移動元の型がobject type で,移動先の型がAny Object Type の場合</b>
</p>
<pre>
my $foo : Foo = new Foo;
my $object : object;
$object = $foo;
</pre>
<p>
  <b>移動元の型と移動先の型が,Any Object Type あるいは,Any Object Type の配列で,移動元のType Dimension数が,移動先のType Dimension数以上の場合</b>
</p>
<pre>
my $objects_dim2_src : object[];
my $objects_dim1_dist : object;
$objects_dim1_dist = $objects_dim2_src;
</pre>
<p>
  注意点として,汎用オブジェクトの配列と基本型の配列には互換性はありません。
</p>
<pre>
# コンパイルエラー
my $objets : object[] = new int[3];
</pre>
<p>
  型に互換性がない場合は,<a href="#language-type-convertion-implicite">暗黙的な型変換</a>が試みられます。暗黙の型変換に失敗した場合は,a compile-time error occurs
</p>

<h2 id="language-type-convertion">型変換</h2>
<ul class="list">
  <li><a href="#language-type-convertion-typecast">型キャスト</a></li>
  <li><a href="#language-type-convertion-typecast">numeric typeの型変換</a></li>
  <li><a href="#language-type-convertion-implicite">暗黙的な型変換</a></li>
  <li><a href="#language-type-convertion-numeric-type-order">numeric typeの順序</a></li>
  <li><a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a></li>
  <li><a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a></li>
  <li><a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a></li>
  <li><a href="#language-type-convertion-numeric-widening">数値拡大型変換</a></li>
  <li><a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a></li>
  <li><a href="#language-type-convertion-boxing">ボクシング変換</a></li>
  <li><a href="#language-type-convertion-unboxing">アンボクシング変換</a></li>
  <li><a href="#language-type-convertion-bool">ブール型変換</a></li>
</ul>

<h3 id="language-type-convertion-typecast">型キャスト</h3>
<p>
  型キャストとは,明示的に記述して行う型変換のことを言います。
</p>
<pre>
# 型キャスト
(型)式
</pre>
<p>
  int type の値をlong型に変換するExampleはthe following ようになります。
</p>
<pre>
my $num = (long)3;
</pre>
<p>
  型キャストは,<a href="#language-expression">式</a>を返します。
</p>
<p>
  移動元の型と指定した型が同一の場合は,単に値のコピーになります。
</p>
<pre>
my $num : int = (int)4;
</pre>
<p>
  <b>型キャストにおける型変換の一覧</b>
</p>
<p>
  型キャストにおける型変換の一覧です。この表にない型キャストが行われた場合は,a compile-time error occurs
</p>
<table>
  <tr>
    <th>
      <b>指定した型</b>
    </th>
    <th>
      <b>移動元の型</b>
    </th>
    <th>
      変換の内容
    </th>
  </tr>
  <tr>
    <td>
      <b>byte[]</b>
    </td>
    <td>
      <b>string</b>
    </td>
    <td>
      アドレス値がコピーされます。
    </td>
  </tr>
  <tr>
    <td>
      <b>string</b>
    </td>
    <td>
      <b>byte[]</b>
    </td>
    <td>
      アドレス値がコピーされます。
    </td>
  </tr>
  <tr>
    <td>
      <b>numeric type</b>
    </td>
    <td>
      <b>numeric type</b>
    </td>
    <td>
      <a href="#language-type-convertion-numeric-widening">numeric typeの型変換</a>が行われます。
    </td>
  </tr>
  <tr>
    <td>
      <b>数値object type </b>
    </td>
    <td>
      <b>numeric type</b>
    </td>
    <td>
      <a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。numeric typeと数値object type が表現するnumeric typeは,同じでなければなりません。たとえば,numeric typeがintの場合は,数値object type はSPVM::Int Type でなければなりません。
    </td>
  </tr>
  <tr>
    <td>
      <b>Any Object Type </b>
    </td>
    <td>
      <b>numeric type</b>
    </td>
    <td>
      <a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。
    </td>
  </tr>
  <tr>
    <td>
      <b>numeric type</b>
    </td>
    <td>
      <b>数値object type </b>
    </td>
    <td>
      <a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。numeric typeと数値object type が表現するnumeric typeは,同じでなければなりません。たとえば,numeric typeがintの場合は,数値object type はSPVM::Int Type でなければなりません。
    </td>
  </tr>
  <tr>
    <td>
      <b>numeric type</b>
    </td>
    <td>
      <b>Any Object Type </b>
    </td>
    <td>
      <a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。
    </td>
  </tr>
  <tr>
    <td>
      <b>文字列型</b>
    </td>
    <td>
      <b>numeric type</b>
    </td>
    <td>
      数値が,C標準のsprintf関数の"%g"フォーマットを使って,文字列化されます。
    </td>
  </tr>
</table>

<h3 id="language-type-convertion-numeric">numeric typeの型変換</h3>
<p>
  numeric typeの型変換とは,<a href="#language-type-numeric">numeric type</a>から<a href="#language-type-numeric">numeric type</a>への変換のことです。
</p>
<p>
  numeric typeの型変換は,対応するC言語におけるnumeric typeによる型変換と全く同じ処理を行います。例えば,SPVMにおけるintからlongへの型変換は,C言語のint32_t型からint64_t型への型変換と同じ処理を行います。
</p>
<pre>
# SPVMの変換
my $src : int = 5;
my $dist = (long)$src;

# C言語における対応
int32_t src = 5;
int64_t dist = (int64_t)src;
</pre>
<p>
  型の対応については,<a href="#language-c99-type">C99との型の対応</a>を見てください。
</p>
<p>
  大きな型から小さな型に変換した場合や,浮動小数点から整数型に変換した場合は,Valid 情報が保持されない場合があります。SPVMでは,C99に対応する型変換をそのまま行っているので,Valid 情報が保持されない場合に,どの値に変換されるかは,C99の仕様と同じです。
</p>

<h3 id="language-type-convertion-implicite">暗黙的な型変換</h3>
<p>
  暗黙的な型変換とは,SPVMによって行われる自動的な型変換のことです。次の箇所が,暗黙的な型変換が行われる可能性のある個所です。
</p>
<ul class="list">
  <li>異なる型に代入する場合</li>
  <li>異なる型のSubroutine Argumentsに渡す場合</li>
  <li>Return Valueとは異なる型を返却する場合</li>
</ul>
<p>
  次の場合に暗黙的な型変換が行われます。
</p>
<p>
  移動元と移動先の型がどちらもnumeric typeで,移動元の型よりも移動先の型が大きい場合は,<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>が行われます。
</p>
<pre>
# 暗黙の拡大型変換
my $num : long = 123;
my $num : double = 12.5f;
</pre>
<p>
  移動元と移動先の型がどちらもnumeric typeで,移動元の型よりも移動先の型が小さい場合で,移動元の値が,Integer Literal  かつ移動先の型の値の範囲で表現できる場合は,<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>が行われます。
</p>
<pre>
# 暗黙の縮小型変換
my $num : byte = 123;
my $num : short = 134;
</pre>
<p>
  移動元の型がnumeric typeで,移動先の型がAny Object Type の場合は,対応する数値object type への<a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。the following 場合の例では,SPVM::Int Type のオブジェクトに変換されたものが,汎用オブジェクトに代入されます。
</p>
<pre>
# object型への暗黙のボクシング変換
my $num = 123;
my $object : object = $num;
</pre>
<p>
  移動元の型がnumeric typeで,移動先の型が対応する数値object type の場合は,対応する数値object type への<a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。
</p>
<pre>
# object型への暗黙のボクシング変換
my $num = 123;
my $object : SPVM::Int = $num;
</pre>
<p>
  移動元の型がAny Object Type で,移動先の型がnumeric typeの場合は,対応するnumeric typeにおける<a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。the following 場合の例では,SPVM::Int Type のオブジェクトからint type への変換が試みられます。
</p>
<pre>
# object型からの暗黙のアンボクシング変換 - 
my $object : object;
my $num : int = $object;
</pre>
<p>
  移動元の型が数値object type で,移動先の型が対応するnumeric typeの場合は,対応するnumeric typeにおける<a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。
</p>
<pre>
# 数値object type からの暗黙のアンボクシング変換
my $num_obj = SPVM::Int->new(3);
my $num : int = $num_obj;
</pre>
  移動元の型がnumeric typeで,移動先の型が,文字列型の場合は,<a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a>が行われます。the following 場合の例では,数値の"123"が文字列""123""に変換されたものが代入されます。
</p>
<pre>
# 文字列型への暗黙のボクシング変換
my $num = 123;
my $str : string = $num;
</pre>

<h3 id="language-type-convertion-numeric-type-order">numeric typeの順序</h3>
<p>
  <a href="#language-type-numeric">numeric type</a>は,型の順序を持ちます。型の順序は小さい方から"byte""short""int""long""float""double"です。
</p>
<h3 id="language-type-convertion-unary-numeric-widening">単項数値拡大型変換</h3>
<p>
  単項数値拡大型変換とは,<a href="#language-expression">式</a>がbyte型あるいはshort型であった場合に,int type へ<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>を行うことをいいます。
</p>
<p>
  単項数値拡大型変換が行われるのはthe following 場合です。
</p>
<ul class="list">
  <li>配列のインデックス</li>
  <li>配列を作成する場合の次元</li>
  <li>Unary Plus Operator のオペランド</li>
  <li>Unary Minus Operator のオペランド</li>
  <li>Shift Operator "<<"">>"">>>"の左右のオペランド</li>
</ul>
<h3 id="language-type-convertion-binary-numeric-widening">二項数値拡大型変換</h3>
<p>
  二項数値拡大型変換とは,左辺と右辺にnumeric typeをとるBinary Operator  において,Left ExpressionとRight Expressionに適用される<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>のことをいいます。
</p>
<p>
  次のルールが適用されます。
</p>
<p>
  1. 一方の式が,double型の場合は,他方の型はdouble型に変換されます。
</p>
<p>
  2. 一方の式が,float型の場合は,他方の型はfloat型に変換されます。
</p>
<p>
  3. 一方の式が,long型の場合は,他方の型はlong型に変換されます。
</p>
<p>
  4. それ以外の場合は,int type に変換されます。
</p>
<p>
  二項数値拡大型変換が行われるのはthe following 場合です。
</p>
<ul class="list">
  <li><a href="#language-operator-add">Addition Operator</a></li>
  <li><a href="#language-operator-subtract">Subtraction Operator</a></li>
  <li><a href="#language-operator-multiply">Multiplication Operator</a></li>
  <li><a href="#language-operator-divide">Division Operator</a></li>
  <li><a href="#language-operator-remainder">Remainder Operator</a></li>
  <li><a href="#language-operator-bit-and">Bit AND Operator</a></li>
  <li><a href="#language-operator-bit-or">Bit OR Operator</a></li>
  <li><a href="#language-operator-comparison-numeric">数値比較Operator</a></li>
</ul>

<h3 id="language-type-convertion-numeric-narrowing">数値縮小型変換</h3>
<p>
  数値縮小型変換とは,<a href="#language-type-numeric">numeric type</a>において大きい型から小さい型への変換が行われる場合に適用される変換の規則のことです。
</p>

<h3 id="language-type-convertion-numeric-widening">数値拡大型変換</h3>
<p>
  数値拡大型変換とは,<a href="#language-type-numeric">numeric type</a>において小さい型から大きい型への変換が行われる場合に適用される変換の規則のことです。
</p>

<h3 id="language-type-convertion-boxing">ボクシング変換</h3>
<p>
  ボクシング変換とは,numeric typeの値を,数値object type に変換する操作のことをいいます。
</p>

<h3 id="language-type-convertion-unboxing">アンボクシング変換</h3>
<p>
  アンボクシング変換とは,数値object type の値を,対応するnumeric typeの値に変換する操作のことをいいます。
</p>

<h3 id="language-type-convertion-bool">ブール型変換</h3>
<p>
  ブール型変換とは,if statementの条件部などで適用される,真偽値判定のために,適用される変換のことです。
</p>
<p>
  <b>ブール型変換が行われる場所</b>
</p>
<p>
  <b>if statementのかっこの中</b>
</p>
<pre>
if (条件部) {

}
</pre>
<p>
  <b>unless文のかっこの中</b>
</p>
<pre>
unless (条件部) {

}
</pre>
<p>
  <b>forのかっこの中の二つ目</b>
</p>
<pre>
for (初期化;条件部;次の値;) {

}
</pre>
<p>
  <b>whileのかっこの中</b>
</p>
<pre>
while (条件部) {

}
</pre>
<p>
  <b>Logical AND Operator の左右</b>
</p>
<pre>
条件部 && 条件部
</pre>
<p>
  <b>Logical OR Operator の左右</b>
</p>
<pre>
条件部 || 条件部
</pre>
<p>
  <b>Logical NOT Operator の右側</b>
</p>
<pre>
!条件部
</pre>
<p>
  ブール型変換で指定される式は,<a href="#language-type-numeric">numeric type</a>あるいは<a href="#language-type-object">object type</a>あるいは<a href="#language-type-undef">未定義型</a>でなければなりません。otherwise a compile-time error occurs.
</p>
<p>
  ブール型変換のReturn Valueは,int type の式です。
</p>
<p>
  式が<a href="#language-undef">Undefined Value</a>である場合は,0が返されます。
</p>
<p>
  式が,<a href="#language-type-numeric">numeric type</a>の場合は,<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  式がint type の場合は,その値が返されます。
</p>
<p>
  式がlong型,float型,double型,object type である場合は,C99におけるthe following 演算と完全に一致する演算を行い,結果が返されます。
</p>
<pre>
!!x
</pre>
<p>
  式がobject type の場合は,Undefined Valueの場合は0,そうでない場合は1が返されます。
</p>

<h2 id="language-auto-loaded-module">自動的に読み込まれるModule</h2>
<p>
  自動的に読み込まれるModuleです。<a href="#language-module-use">Moduleの読み込み</a>を行わないで利用することができます。
</p>
<ul class="list">
  <li>SPVM::Byte</li>
  <li>SPVM::Short</li>
  <li>SPVM::Int</li>
  <li>SPVM::Long</li>
  <li>SPVM::Float</li>
  <li>SPVM::Double</li>
</ul>

<h2 id="language-limitation">Limitation </h2>
<p>
  SPVMにおけるLimitation です。
</p>

<h3 id="language-limitation-sub-arguments-count">Subroutine Argumentsの個数のLimitation </h3>
<p>
  SPVMのSubroutine Argumentsの個数の最大は256個です。
</p>
<p>
  Multi Numeric Typeの引数を渡すときは,フィールドの個数が,引数の個数としてカウントされます。たとえばSPVM::Complex_2d型が引数で指定された場合は,2個と数えます。
</p>
<p>
  複数数値のreference type の引数を渡すときは,Multi Numeric Typeのフィールドの個数が,引数の個数としてカウントされます。たとえばSPVM::Complex_2d&型が引数で指定された場合は,2個と数えます。
</p>
<p>
  もし,最大値を超えた場合は,a compile-time error occurs
</p>

<h3 id="language-limitation-value-type-fileds-count">Multi Numeric Typeのフィールドの個数のLimitation </h3>
<p>
  Multi Numeric Typeのフィールドの個数の最大値は,256個で,少なくともひとつのフィールドが必要です。otherwise a compile-time error occurs.
</p>

