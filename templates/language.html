<h2>SPVM 1.0 Language Specification</h2>

Last modified 2020-02-06

<b>SPVM 1.0 language specification</b> is described in this document.

SPVM is in beta testing for the 1.0 release. Language specifications will be changed without warning.

<h2 id="language-c99">C99 compliant</h2><!-- 2019/2/27 almost ok -->
<ul class="list">
  <li><a href="#language-c99-spec">C99 compliant compiler and runtime</a>
  <li><a href="#language-c99-type">Type correspondence with C99</a>
</ul>

<h3 id="language-c99-spec">C99 compliant compiler and runtime</h3><!-- 2019/2/27 almost ok -->

The source code of the SPVM compiler and SPVM runtime is written in C and conforms to C99.

Note that this does not mean that users cannot call the functions of C versions other than C99 (C11, GNU extensions, etc.) or call the functions of C++ from SPVM.

This means that the SPVM compiler and runtime must be C99 compliant.

<h3 id="language-c99-type">Type correspondence with C99</h3><!-- 2019/2/27 almost ok -->

SPVM types are exactly the same as the following C99 types:

<table>
  <tr>
    <th>
      <b> SPVM type </ b>
    </ th>
    <th>
      <b> C99 type </ b>
    </ th>
    <th>
      <b> Description </ b>
    </ th>
  </ tr>
  <tr>
    <td>
      <b> byte </ b>
    </ td>
    <td>
      int8_t
    </ td>
    <td>
      SPVM <a href="#language-type-byte"> byte type </a> matches C99 int8_t type.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> short </ b>
    </ td>
    <td>
      int16_t
    </ td>
    <td>
      SPVM <a href="#language-type-short"> short type</a> matches the C99 int16_t type.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> int </ b>
    </ td>
    <td>
      int32_t
    </ td>
    <td>
      SPVM <a href="#language-type-int"> int type </a> matches the C99 int32_t type.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> long </ b>
    </ td>
    <td>
      int64_t
    </ td>
    <td>
      SPVM <a href="#language-type-long"> long type </a> matches C99 int64_t type.
    </ td>
  </ tr>

<tr>
    <td>
      <b> float </ b>
    </ td>
    <td>
      float
    </ td>
    <td>
      SPVM <a href="#language-type-float"> float type </a> matches the C99 float type.
    </ td>
  <tr>
    <td>
      <b> double </ b>
    </ td>
    <td>
      double
    </ td>
    <td>
      SPVM <a href="#language-type-double"> double type</a> matches C99 double.
    </ td>
  </ tr>
  <tr>
    <td>
      <b> Object type </ b>
    </ td>
    <td>
      void*
    </ td>
    <td>
      SPVM <a href="#language-type-object"> object type </a> matches the C99 void* type.
    </ td>
  </ tr>        
  <tr>
    <td>
      <b> Multiple numeric type </ b>
    </ td>
    <td>
      Numeric array type that matches the type and length in SPVM multiple numeric type fields
    </ td>
    <td>
      <p>
        For example, if SPVM <a href="#language-type-multi-numeric">multiple numeric type</a>
      </ p>
      <p>
        <b>package Point_2i: mulnum_t {has x: int; has y: int;}</b>
      </ p>
      <p>
        matches the type declared in C99
      </ p>
      <p>
        <b>int32_t var[2];</b>
      </p>
    </ td>
  </ tr>
</table>

<h2 id="language-lex">Lexical Analysis</h2>

This topic specifies the Lexical Analysis of the SPVM language.

<ul class="list">
  <li><a href="#language-lex-lalr">LALR(1)</a>
  <li><a href="#language-lex-charset">Character Set</a>
  <li><a href="#language-lex-component">Component</a>
  <li><a href="#language-lex-line-terminator">Line Terminater</a>
  <li><a href="#language-lex-space-character">Space Character</a>
  <li><a href="#language-lex-identifier">Identifier</a>
  <li><a href="#language-lex-separator">Separator</a>
  <li><a href="#language-lex-operator">Operator </a>
  <li><a href="#language-lex-syntax-definition">Syntax Definition</a></li>
</ul>

<h3 id="language-lex-lalr">LALR(1)</h3><!-- 2019/2/27 almost ok -->

SPVM language can be analyzed by the LALR(1). It can be parsed by the parser generator generated by yacc/bison.

<h3 id="language-lex-lalr">Character Set</h3>

SPVM programs are written in UTF-8.

<h3 id="language-lex-component">Component</h3><!-- 2019/2/27 almost ok -->

Component in SPVM is "<a href="#language-lex-space-character">Space Character</a>","<a href="#language-comment">Comment</a>", "<a href="#language-pod">POD</a>", "<a href="#language-literal">Literal</a>", "<a href="#language-lex-identifier">Identifier</a>", "<a href="#language-lex-keyword">Keyword</a>", "<a href="#language-lex-separator">Separator</a>", or "<a href="#language-lex-operator">Operator</a>".

<h3 id="language-lex-line-terminator">Line Terminator</h3><!-- 2019/7/1 check -->

Line Terminator in SPVM are ASCII Code "LF", "CR", "CRLF".

When a line terminator appears, the line number is incremented.Line Terminator in a program is converted to ASCII Code "LF".

<h3 id="language-lex-space-character">Space Character</h3><!-- 2019/2/27 almost ok -->

Space Character in SPVM is ASCII Code "SP", "HT", "FF" or "<a href="#language-lex-line-terminator">Line Terminator</a>".

Space Character has no meaning in the program execution.

<h3 id="language-lex-identifier">Identifier</h3><!-- 2019/2/27 maybe ok -->

Identifier in SPVM is "Package Name", ""Subroutine Name", "Field Name", "Package Variable Name", or "Lexical Variable Name".

<ul class="list">
  <li><a href="#language-lex-identifier-package-name">Package Name</a></li>
  <li><a href="#language-lex-identifier-sub-name">Subroutine Name</a></li>
  <li><a href="#language-lex-identifier-field-name">Field Name</a></li>
  <li><a href="#language-lex-identifier-package-var-name">Package Variable Name</a></li>
  <li><a href="#language-lex-identifier-lex-var-name">Lexical Variable Name</a></li>
</ul>

<h4 id="language-lex-identifier-package-name">Package Name</h4><!-- 2019/2/27 almost ok -->

Package Name is one or more alphabet(a-zA-Z), number(0-9), underscore(_) or "::" of ASCII Code.

It is not necessary to include "::" in the Package Name.

Package Name must start a uppercase letter in ASCII Code

"::" cannot be continued twice. Last characters cannot end with "::".

Underscore cannot be continued twice.

<pre>
# Valid Package Name
Foo
Foo::Bar
Foo::Bar::Baz3
Foo::bar
Foo_Bar::Baz_Baz

# Invalid Package Name
foo
_Foo
Foo::Bar::
Foo__Bar
</pre>

If Package Name is invalid, a compile-time error occurs.

<h4 id="language-lex-identifier-sub-name">Subroutine Name</h4><!-- 2019/2/27 almost ok -->

Subroutine Name is one or more alphabet(a-zA-Z), number(0-9), or underscore(_) of ASCII Code.

First character must not number character.

Underscore cannot be continued twice.

<pre>
# Valid Subroutine Name
FOO
FOO_BAR3
foo
foo_bar
_foo
_foo_bar_

# Invalid Subroutine Name
foo__bar
</pre>

<h4 id="language-lex-identifier-field-name">Field Name</h4><!-- 2019/2/27 almost ok -->

Field Name is one or more alphabet(a-zA-Z), number(0-9), or underscore(_) of ASCII Code.

First character must not number character.
  
Underscore cannot be continued twice.

<pre>
# Valid Field Name
FOO
FOO_BAR3
foo
foo_bar
_foo
_foo_bar_

# Invalid Field Name
3foo
foo__bar
</pre>

<h4 id="language-lex-identifier-package-var-name">Package Variable Name</h4><!-- 2019/2/27 maybe ok -->

Package Variable Name starts with "$", followed more alphabet(a-zA-Z), number(0-9), underscore(_) or "::" of ASCII Code.

Followed character must not start with number.

"::" cannot be continued twice. Last characters cannot end with "::".

Underscore cannot be continued twice.

<pre>
# Valid Package Variable Name
$FOO::BAR
$Foo::Bar3
$FOO
$FOO_BAR
$foo

# Invalid Package Variable Name
$FOO__BAR
$3FOO

<h4 id="language-lex-identifier-lex-var-name">Lexical Variable Name</h4><!-- 2019/2/27 maybe ok -->

Lexical Variable Name starts with "$", followed more alphabet characters of ASCII Code.

Followed character must not start with number.

Underscore cannot be continued twice.

<pre>
# Valid Lexical Variable Name
$foo
$foo_bar3
$_foo
$FOO

# Invalid Lexical Variable Name
$foo__bar
$3foo
</pre>

<h3 id="language-lex-keyword">Keywords</h3><!-- 2019/2/27 maybe ok -->

Keywords in SPVM are the followings.

<pre>
allow byte BEGIN case die warn print default double elsif else enum eq
eval for float gt ge has if callback_t isa int last break length
lt le long my native ne next new our object package private
public precompile pointer_t return require rw ro self switch
sub string short scalar undef unless use void mulnum_t while
weaken wo __END__ __PACKAGE__ __FILE__ __LINE__
</pre>

<h3 id="language-lex-separator">Separators</h3><!-- 2019/2/27 almost ok -->

Separators in SPVM are the followings.

<pre>
( ) { } [ ] ; , -> =>
</pre>

<h3 id="language-lex-operator">Operators</h3><!-- 2019/2/27 almost ok -->

Operators in SPVM are the followings.

<pre>
=   >   <   !   ~
==  <=  >=  !=  &&  ||  ++  --
+   -   *   /   &   |   ^   %   <<   >>   >>>
+=  -=  *=  /=  &=  |=  ^=  %=  <<=  >>=  >>>=
\   $   @   .   .=
</pre>

<h2 id="language-parsing">Parsing</h2>

<h3 id="language-parsing-syntax-definition">Parsing Definition</h3><!-- 2019/2/27 not ok -->

The following is Parsing Definition in SPVM, using the syntax in yacc/bison. 

<pre>
%token <opval> PACKAGE HAS SUB OUR ENUM MY SELF USE REQUIRE ALLOW
%token <opval> DESCRIPTOR
%token <opval> IF UNLESS ELSIF ELSE FOR WHILE LAST NEXT SWITCH CASE DEFAULT BREAK EVAL
%token <opval> NAME VAR_NAME CONSTANT EXCEPTION_VAR
%token <opval> UNDEF VOID BYTE SHORT INT LONG FLOAT DOUBLE STRING OBJECT
%token <opval> DOT3 FATCAMMA RW RO WO BEGIN NEW
%token <opval> RETURN WEAKEN DIE WARN CURRENT_PACKAGE UNWEAKEN '[' '{' '('

%type <opval> grammar
%type <opval> opt_packages packages package package_block refcnt
%type <opval> opt_declarations declarations declaration
%type <opval> enumeration enumeration_block opt_enumeration_values enumeration_values enumeration_value
%type <opval> sub cb_obj opt_args args arg invocant has use require our string_length
%type <opval> opt_descriptors descriptors sub_names opt_sub_names
%type <opval> opt_statements statements statement if_statement else_statement 
%type <opval> for_statement while_statement switch_statement case_statement default_statement
%type <opval> block eval_block begin_block switch_block if_require_statement
%type <opval> unary_op binary_op num_comparison_op str_comparison_op isa logical_op
%type <opval> call_sub opt_vaarg
%type <opval> array_access field_access weaken_field unweaken_field isweak_field convert array_length
%type <opval> deref ref assign inc dec allow
%type <opval> new array_init
%type <opval> my_var var
%type <opval> expression opt_expressions expressions opt_expression case_statements
%type <opval> field_name sub_name
%type <opval> type basic_type array_type array_type_with_length ref_type  type_or_void

%right <opval> ASSIGN SPECIAL_ASSIGN
%left <opval> LOGICAL_OR
%left <opval> LOGICAL_AND
%left <opval> BIT_OR BIT_XOR
%left <opval> '&'
%nonassoc <opval> NUMEQ NUMNE STREQ STRNE
%nonassoc <opval> NUMGT NUMGE NUMLT NUMLE STRGT STRGE STRLT STRLE ISA
%left <opval> SHIFT
%left <opval> '+' '-' '.'
%left <opval> MULTIPLY DIVIDE REMAINDER
%right <opval> LOGICAL_NOT BIT_NOT '@' REF DEREF PLUS MINUS CONVERT SCALAR LENGTH ISWEAK REFCNT
%nonassoc <opval> INC DEC
%left <opval> ARROW

%%

grammar
: opt_packages

opt_packages
:	/* Empty */
|	packages

packages
: packages package
| package

package
: PACKAGE basic_type package_block
| PACKAGE basic_type ':' opt_descriptors package_block
| PACKAGE basic_type ';'
| PACKAGE basic_type ':' opt_descriptors ';'

package_block
: '{' opt_declarations '}'

opt_declarations
:	/* Empty */
|	declarations

declarations
: declarations declaration
| declaration

declaration
: has
| sub
| enumeration
| our ';'
| use
| allow
| begin_block

begin_block
: BEGIN block

use
: USE basic_type ';'
| USE basic_type '(' opt_sub_names ')' ';'

require
: REQUIRE basic_type

allow
: ALLOW basic_type ';'

enumeration
: opt_descriptors ENUM enumeration_block

enumeration_block 
: '{' opt_enumeration_values '}'

opt_enumeration_values
:	/* Empty */
|	enumeration_values

enumeration_values
: enumeration_values ',' enumeration_value 
| enumeration_values ','
| enumeration_value

enumeration_value
: sub_name
| sub_name ASSIGN CONSTANT

our
: OUR PACKAGE_VAR_NAME ':' opt_descriptors type

has
: HAS field_name ':' opt_descriptors type ';'

sub
: opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' block
| opt_descriptors SUB sub_name ':' type_or_void '(' opt_args opt_vaarg')' ';'

cb_obj
: opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block
| '[' args ']' opt_descriptors SUB ':' type_or_void '(' opt_args opt_vaarg')' block

opt_args
:	/* Empty */
|	args
| invocant
| invocant ',' args

args
: args ',' arg
| args ','
| arg

arg
: var ':' type

opt_vaarg
: /* Empty */
| DOT3

invocant
: var ':' SELF

opt_descriptors
:	/* Empty */
|	descriptors

descriptors
: descriptors DESCRIPTOR
| DESCRIPTOR

opt_statements
:	/* Empty */
|	statements

statements
: statements statement 
| statement

statement
: if_statement
| for_statement
| while_statement
| block
| switch_statement
| case_statement
| default_statement
| eval_block
| if_require_statement
| expression ';'
| LAST ';'
| NEXT ';'
| RETURN ';'
| RETURN expression ';'
| DIE ';'
| DIE expression ';'
| WARN ';'
| WARN expression ';'
| PRINT expression ';'
| weaken_field ';'
| unweaken_field ';'
| ';'

for_statement
: FOR '(' opt_expression ';' expression ';' opt_expression ')' block

while_statement
: WHILE '(' expression ')' block

switch_statement
: SWITCH '(' expression ')' switch_block

switch_block
: '{' case_statements '}'
| '{' case_statements default_statement '}'

case_statements
: case_statements case_statement
| case_statement

case_statement
: CASE expression ':' block
| CASE expression ':'

default_statement
: DEFAULT ':' block
| DEFAULT ':'

if_require_statement
: IF '(' require ')' block
| IF '(' require ')' block ELSE block

if_statement
: IF '(' expression ')' block else_statement
| UNLESS '(' expression ')' block else_statement

else_statement
: /* NULL */
| ELSE block
| ELSIF '(' expression ')' block else_statement

block 
: '{' opt_statements '}'

eval_block
: EVAL block ';'

opt_expressions
:	/* Empty */
|	expressions

opt_expression
: /* Empty */
| expression

expression
: var
| EXCEPTION_VAR
| package_var_access
| CONSTANT
| UNDEF
| call_sub
| field_access
| array_access
| convert
| new
| array_init
| array_length
| string_length
| refcnt
| my_var
| binary_op
| unary_op
| ref
| deref
| assign
| inc
| dec
| '(' expressions ')'
| CURRENT_PACKAGE
| isweak_field
| num_comparison_op
| str_comparison_op
| isa
| logical_op

refcnt
: REFCNT var
expressions
: expressions ',' expression
| expressions ','
| expression

unary_op
: '+' expression %prec PLUS
| '-' expression %prec MINUS
| BIT_NOT expression

inc
: INC expression
| expression INC

dec
: DEC expression
| expression DEC

binary_op
: expression '+' expression
| expression '-' expression
| expression MULTIPLY expression
| expression DIVIDE expression
| expression REMAINDER expression
| expression BIT_XOR expression
| expression '&' expression
| expression BIT_OR expression
| expression SHIFT expression
| expression '.' expression

num_comparison_op
: expression NUMEQ expression
| expression NUMNE expression
| expression NUMGT expression
| expression NUMGE expression
| expression NUMLT expression
| expression NUMLE expression

str_comparison_op
: expression STREQ expression
| expression STRNE expression
| expression STRGT expression
| expression STRGE expression
| expression STRLT expression
| expression STRLE expression

isa
: expression ISA type

logical_op
: expression LOGICAL_OR expression
| expression LOGICAL_AND expression
| LOGICAL_NOT expression

assign
: expression ASSIGN expression
| expression SPECIAL_ASSIGN expression

new
: NEW basic_type
| NEW array_type_with_length
| cb_obj

array_init
: '[' opt_expressions ']'

convert
: '(' type ')' expression %prec CONVERT

array_access
: expression ARROW '[' expression ']'
| array_access '[' expression ']'
| field_access '[' expression ']'

call_sub
: NAME '(' opt_expressions  ')'
| basic_type ARROW sub_name '(' opt_expressions  ')'
| basic_type ARROW sub_name
| expression ARROW sub_name '(' opt_expressions ')'
| expression ARROW sub_name
| expression ARROW '(' opt_expressions ')'

field_access
: expression ARROW '{' field_name '}'
| field_access '{' field_name '}'
| array_access '{' field_name '}'

weaken_field
: WEAKEN var ARROW '{' field_name '}'

unweaken_field
: UNWEAKEN var ARROW '{' field_name '}'

isweak_field
: ISWEAK var ARROW '{' field_name '}'

array_length
: '@' expression
| '@' '{' expression '}'
| SCALAR '@' expression
| SCALAR '@' '{' expression '}'

string_length
: LENGTH expression

deref
: DEREF var

ref
: REF var

my_var
: MY var ':' type
| MY var

var
: VAR_NAME

package_var_access
: PACKAGE_VAR_NAME

type
: basic_type
| array_type
| ref_type

basic_type
: NAME
| BYTE
| SHORT
| INT
| LONG
| FLOAT
| DOUBLE
| OBJECT
| STRING

ref_type
: basic_type '&'
array_type
: basic_type '[' ']'
| array_type '[' ']'

array_type_with_length
: basic_type '[' expression ']'
| array_type '[' expression ']'

type_or_void
: type
| VOID

field_name
: NAME

sub_name
: NAME

opt_sub_names
:	/* Empty */
|	sub_names

sub_names
: sub_names ',' sub_name
| sub_names ','
| sub_name
%%
</pre>

The following is a correspondence table between tokens in yacc/bison and keywords and operators in SPVM.

<table>
  <tr>
    <th>Tokens in yacc/bison</th><th>Keywords and Operators in SPVM</th>
  </tr>
  <tr>
    <td>PACKAGE</td><td>package</td>
  </tr>
  <tr>
    <td>SUB</td><td>sub</td>
  </tr>
  <tr>
    <td>OUR</td><td>our</td>
  </tr>
  <tr>
    <td>ENUM</td><td>enum</td>
  </tr>
  <tr>
    <td>MY</td><td>my</td>
  </tr>
  <tr>
    <td>SELF</td><td>self</td>
  </tr>
  <tr>
    <td>USE</td><td>use</td>
  </tr>
  <tr>
    <td>REQUIRE</td><td>require</td>
  </tr>
  <tr>
    <td>ALLOW</td><td>allow</td>
  </tr>
  <tr>
    <td>DESCRIPTOR</td><td>descriptor</td>
  </tr>
  <tr>
    <td>IF</td><td>if</td>
  </tr>
  <tr>
    <td>UNLESS</td><td>unless</td>
  </tr>
  <tr>
    <td>ELSIF</td><td>elsif</td>
  </tr>
  <tr>
    <td>ELSE</td><td>else</td>
  </tr>
  <tr>
    <td>FOR</td><td>for</td>
  </tr>
  <tr>
    <td>WHILE</td><td>while</td>
  </tr>
  <tr>
    <td>LAST</td><td>last</td>
  </tr>
  <tr>
    <td>BREAK</td><td>break</td>
  </tr>
  <tr>
    <td>NEXT</td><td>next</td>
  </tr>
  <tr>
    <td>SWITCH</td><td>switch</td>
  </tr>
  <tr>
    <td>CASE</td><td>case</td>
  </tr>
  <tr>
    <td>DEFAULT</td><td>default</td>
  </tr>
  <tr>
    <td>EVAL</td><td>eval</td>
  </tr>
  <tr>
    <td>NAME</td><td>name</td>
  </tr>
  <tr>
    <td>VAR</td><td>var</td>
  </tr>
  <tr>
    <td>CONSTANT</td><td>Literal </td>
  </tr>
  <tr>
    <td>PACKAGE_VAR_NAME</td><td>Package Variable Name</td>
  </tr>
  <tr>
    <td>EXCEPTION_VAR</td><td>$@</td>
  </tr>
  <tr>
    <td>UNDEF</td><td>undef</td>
  </tr>
  <tr>
    <td>VOID</td><td>void</td>
  </tr>
  <tr>
    <td>BYTE</td><td>byte</td>
  </tr>
  <tr>
    <td>SHORT</td><td>short</td>
  </tr>
  <tr>
    <td>INT</td><td>int</td>
  </tr>
  <tr>
    <td>LONG</td><td>long</td>
  </tr>
  <tr>
    <td>FLOAT</td><td>float</td>
  </tr>
  <tr>
    <td>DOUBLE</td><td>double</td>
  </tr>
  <tr>
    <td>STRING</td><td>string</td>
  </tr>
  <tr>
    <td>OBJECT</td><td>object</td>
  </tr>
  <tr>
    <td>DOT3</td><td>...</td>
  </tr>
  <tr>
    <td>FATCAMMA</td><td>=></td>
  </tr>
  <tr>
    <td>RW</td><td>rw</td>
  </tr>
  <tr>
    <td>RO</td><td>ro</td>
  </tr>
  <tr>
    <td>WO</td><td>wo</td>
  </tr>
  <tr>
    <td>BEGIN</td><td>BEGIN</td>
  </tr>
  <tr>
    <td>NEW</td><td>new</td>
  </tr>
  <tr>
    <td>RETURN</td><td>return</td>
  </tr>
  <tr>
    <td>WEAKEN</td><td>weaken</td>
  </tr>
  <tr>
    <td>DIE</td><td>die</td>
  </tr>
  <tr>
    <td>WARN</td><td>warn</td>
  </tr>
  <tr>
    <td>PRINT</td><td>print</td>
  </tr>
  <tr>
    <td>CURRENT_PACKAGE</td><td>__PACKAGE__</td>
  </tr>
  <tr>
    <td>UNWEAKEN</td><td>unweaken</td>
  </tr>
  <tr>
    <td>ASSIGN</td><td>=</td>
  </tr>
  <tr>
    <td>SPECIAL_ASSIGN</td><td>+=  -=  *=  /=  &=  |=  ^=  %=  &lt;&lt;=  &gt;&gt;=  &gt;&gt;&gt;= .=</td>
  </tr>
  <tr>
    <td>LOGICAL_OR</td><td>||</td>
  </tr>
  <tr>
    <td>LOGICAL_AND</td><td>&&</td>
  </tr>
  <tr>
    <td>BIT_OR</td><td>|</td>
  </tr>
  <tr>
    <td>BIT_XOR</td><td>&</td>
  </tr>
  <tr>
    <td>NUMEQ</td><td>==</td>
  </tr>
  <tr>
    <td>NUMNE</td><td>!=</td>
  </tr>
  <tr>
    <td>STREQ</td><td>eq</td>
  </tr>
  <tr>
    <td>STRNE</td><td>ne</td>
  </tr>
  <tr>
    <td>NUMGT</td><td>&gt;</td>
  </tr>
  <tr>
    <td>NUMGE</td><td>&gt;=</td>
  </tr>
  <tr>
    <td>NUMLT</td><td>&lt;</td>
  </tr>
  <tr>
    <td>NUMLE</td><td>&lt;=</td>
  </tr>
  <tr>
    <td>STRGT</td><td>gt</td>
  </tr>
  <tr>
    <td>STRGE</td><td>ge</td>
  </tr>
  <tr>
    <td>STRLT</td><td>lt</td>
  </tr>
  <tr>
    <td>STRLE</td><td>le</td>
  </tr>
  <tr>
    <td>ISA</td><td>isa</td>
  </tr>
  <tr>
    <td>SHIFT</td><td>&lt;&lt;  &gt;&gt;  &gt;&gt;&gt;</td>
  </tr>
  <tr>
    <td>MULTIPLY</td><td>*</td>
  </tr>
  <tr>
    <td>DIVIDE</td><td>/</td>
  </tr>
  <tr>
    <td>REMAINDER</td><td>%</td>
  </tr>
  <tr>
    <td>LOGICAL_NOT</td><td>!</td>
  </tr>
  <tr>
    <td>BIT_NOT</td><td>~</td>
  </tr>
  <tr>
    <td>REF</td><td>\</td>
  </tr>
  <tr>
    <td>DEREF</td><td>$</td>
  </tr>
  <tr>
    <td>PLUS</td><td>+</td>
  </tr>
  <tr>
    <td>MINUS</td><td>-</td>
  </tr>
  <tr>
    <td>CONVERT</td><td>(TypeName)</td>
  </tr>
  <tr>
    <td>SCALAR</td><td>scalar</td>
  </tr>
  <tr>
    <td>LENGTH</td><td>length</td>
  </tr>
  <tr>
    <td>ISWEAK</td><td>isweak</td>
  </tr>
  <tr>
    <td>REFCNT</td><td>refcnt</td>
  </tr>
  <tr>
    <td>INC</td><td>++</td>
  </tr>
  <tr>
    <td>DEC</td><td>--</td>
  </tr>
  <tr>
    <td>ARROW</td><td>-></td>
  </tr>
</table>

<h2 id="language-comment">Comment</h2>

Comment begins with "#" and ends with <a href="#language-lex-line-terminator">Line Terminator</a>.

<pre>
# Comment
</pre>

Comment has no meaning in the program execution.

<h2 id="language-pod">POD</h2>

POD(Plain Old Document) is a syntax to write documents easily.

You can use POD as Multi-Line comments.

POD starts from the line beginning with "=", followed by any character string of one or more characters, and ending with <a href="#language-lex-line-terminator">Line Terminator</a>.

POD ends from the line beginning with "=cut", and ending with <a href="#language-lex-line-terminator">Line Terminator</a>.

<b>POD Example:</b>

<pre>
=pod

Multi-Line
Comment

=cut
</pre>

<pre>
=head1

Multi-Line
Comment

=cut
</pre>

POD has no meaning in the program execution.

<h2 id="language-package">パッケージ</h2>
<ul class="list">
  <li><a href="#language-package-definition">パッケージの定義</a></li>
  <li><a href="#language-package-destructor">デストラクタ</a></li>
</ul>

<h3 id="language-package-definition">パッケージの定義</h3>
<p>
  パッケージを定義するには以下の構文を使用します。
</p>
<pre>
package PackageName {

}
</pre>

<p>
  Package Nameは"uppercase letter"で始まる必要があります。Package Nameには"::"を使用することができます。
</p>
<p>
Foo
Foo::Bar
Foo::Bar::Baz
</p>
<p>
  "Package Name"の後に":"をつなげてその後ろに"デスクリプタ"を指定することができます。
</p>
<pre>
package Package Name : デスクリプタ {

}
</pre>
<p>
  パッケージの定義のExampleです。
</p>
<pre>
# Package Nameのみ
package Point {

}
</pre>

<pre>
# Package Nameとデスクリプタ
package Point : public {

}
</pre>

<p id="language-package-descriptor">
  <b>パッケージデスクリプタ</b>
</p>
<p>
  パッケージで指定できるデスクリプタの一覧です。
</p>
<table>
  <tr>
    <th>
      デスクリプタ名
    </th>
    <th>
      役割
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      このパッケージに対するnewKeyword が他のパッケージから利用できます。
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      このパッケージに対するnewKeyword が他のパッケージから利用できません。デフォルトの設定です。
    </td>
  </tr>
  <tr>
    <td>
      <b>callback_t</b>
    </td>
    <td>
      このパッケージは"インターフェイス型"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>mulnum_t</b>
    </td>
    <td>
      このパッケージは"<a href="#language-type-multi-numeric">複数数値型</a>"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>pointer_t</b>
    </td>
    <td>
      このパッケージは"ポインタ型"になります。"ポインタ型"は"クラス型"の一種です。
    </td>
  </tr>
</table>
<p>
  "public"と"private"の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
</p>
<p>
  "callback_t""mulnum_t""pointer_t"のひとつより多くが同時に指定されている場合は、コンパイル時エラーが発生します。
</p>

<p>
  <b>パッケージ内部で定義できるもの</b>
</p>
<p>
  パッケージ内部では<b>"use"</b><b>"パッケージ変数"</b><b>"フィールド"</b><b>"列挙"</b><b>"サブルーチン"</b>が定義できます。
</p>
<pre>
package Foo {
# use
use Point;

# パッケージ変数
our $VAR int;

# フィールド
has var : int;

# 列挙
enum {
CONST_VAL
}

# サブルーチン
sub foo : int ($num : int) {

}
}
</pre>

<h3 id="language-package-destructor">デストラクタ</h3>
<p>
  パッケージが<a href="#language-type-class">クラス型</a>である場合は、デストラクタを定義することができます。
</p>
<p>
  デストラクタとは、オブジェクトが解放されるときに実行される特別な<a href="#language-sub">サブルーチン</a>のことです。
</p>
<p>
  デストラクタの名前は"DESTROY"でなければなりません。
</p>
<p>
  デストラクタの戻り値の型は、<a href="#language-type-void">void型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  デストラクタの引数は、ひとつで、<a href="#language-type-self">self型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<pre>
sub DESTROY : void ($self : self) {

}
</pre>
<p>
  デストラクタの中で<a href="#language-exception-occur">例外の発生</a>が起こった場合は、プログラムは終了せず、例外メッセージが、標準エラーに出力されます。
</p>
<p>
  <b>デストラクタのExample</b>
</p>
<p>
  デストラクタのExampleです。
</p>
<pre>
package Foo {
sub new : Foo {
return new Foo;
}

sub DESTROY : void ($self : self) {
print "DESTROY";
}
}
</pre>

<h2 id="language-module">モジュール</h2>
<ul class="list">
  <li href="#language-module-summary">モジュールの概要</li>
  <li href="#language-module-file-name">モジュールのファイル名</li>
  <li href="#language-module-use">モジュールの読み込み</li>
  <li href="#language-module-if-require">選択的なモジュールの読み込み</li>
</ul>

<h3 id="language-module-summary">モジュールの概要</h3>
<p>
  モジュールとは、SPVMのソースコードとして読み込むことができるひとつのファイルのことをいいます。
</p>
<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}
</pre>
<p>
  モジュールには、複数のパッケージを含むことができます。
</p>
<pre>
# lib/path/Foo/Bar.spvm
package Foo::Bar {

}

package Foo::Bar::Baz {

}
</pre>

<h3 id="language-module-file-name">モジュールのファイル名</h3>
<p>
  モジュールは、モジュールの読み込みパスに、以下のファイル名で配置される必要があります。
</p>
<p>
  "::"を"/"に変更。末尾に".spvm"をつける。
</p>
<pre>
Foo.spvm
Foo/Bar.spvm
Foo/Bar/Baz.spvm
</pre>

<h3 id="language-module-use">モジュールの読み込み</h3>
<p>
  モジュールを読み込むには、useKeyword を使用します。
</p>
<pre>
use Foo;
use Foo::Bar;
</pre>
<p>
  モジュールはコンパイル時に読み込まれます。
</p>
<p>
  モジュールが存在しなかった場合は、コンパイルエラーになります。
</p>
<p>
  useKeyword は、パッケージの定義の直下で定義する必要があります。
</p>
<pre>
package Foo {
use Foo;
}
</pre>

<h3 id="language-module-if-require">選択的なモジュールの読み込み</h3>
<p>
  SPVMでは、モジュールが、検索パスに存在する場合だけ読み込み、そうでない場合は、ブロックの内部が存在しないことにできるif require文があります。これはC言語の"#ifdef"の一部の機能を実現するために設計されました。
</p>
<pre>
if (require Foo) {

}
</pre>
<p>
  if require文はelse文を続けることができます。elsif文は、指定できないので注意してください。
</p>
<pre>
if (require Foo) {

}
else {

}
</pre>

<p>
  一つの例を見てみましょう。以下の例で、Fooが存在しない場合は、コンパイルエラーにはならず、ifブロックがないことになります。そのため"$foo = new Foo;"は、存在しないことになっているので、コンパイルエラーになりません。elseブロックは存在するので、警告がされます。
</p>
<pre>
my $foo : object;
if (require Foo) {
$foo = new Foo;
}
else {
warn "Warning: Can't load Foo";
}
</pre>

<h2 id="language-allow-access">アクセス許可</h2>
<p>
  デフォルトでは、プライベートなサブルーチン、フィールド、パッケージ変数には、パッケージの外部からは、アクセスすることができません。また、プライベートなパッケージは、パッケージの外部から、オブジェクトの生成を行うことができません。
</p>
<p>
  外部のパッケージに対してアクセス許可を設定すると、外部のパッケージは、プライベートなサブルーチン、フィールド、パッケージ変数にアクセスすることができ、またオブジェクトの生成を行うことができます。
</p>
<pre>
allow Package Name;
</pre>
<p>
  allowKeyword は、パッケージの定義の直下で定義する必要があります。
</p>
<pre>
package Foo {
allow Bar;
}
</pre>
<p>
  この例では、Fooにおいてprivateが指定されているサブルーチン、フィールド、パッケージ変数に、Barからアクセスすることができます。また、BarからFooのオブジェクトの生成を行うことができます。
</p>

<h2 id="language-package-var">パッケージ変数</h2>
<ul class="list">
  <li><a href="#language-package-var-definition">パッケージ変数の定義</a></li>
  <li><a href="#language-package-var-initial-value">パッケージ変数の初期値</a></li>
  <li><a href="#language-package-var-access">パッケージ変数へのアクセス</a></li>
</ul>
<h3 id="language-package-var-definition">パッケージ変数の定義</h3>
<p>
  パッケージ変数とは、パッケージに属する、プログラムの開始から終了まで維持されるグローバル変数のことです。
</p>
<p>
  "our"Keyword を使用してパッケージ変数を定義することができます。
</p>
<pre>
our Package Variable Name : Type Name ;
</pre>
<p>
  パッケージ変数の定義は"<a href="#language-package-definition">パッケージ定義</a>"の直下で行う必要があります。
</p>
<p>
  パッケージ変数の定義には"<a href="#language-type">Type Name </a>"が必要です。Type Name には"数値型"と"オブジェクト型"を指定できます。
</p>
<p>
  Package Variable Nameは、<a href="#language-lex-identifier-package-var-name">Package Variable Name</a>で定義されている名前の規則に従い、かつ"::"が含まれていてはいけません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  パッケージ変数定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
</p>
<pre>
our Package Variable Name : デスクリプタ Type Name ;
</pre>
<p>
  <b>パッケージ変数デスクリプタ</b>
</p>
<p>
  パッケージ変数で指定できるデスクリプタの一覧です。
</p>
<table>
  <tr>
    <th>
      デスクリプタ名
    </th>
    <th>
      役割
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      このパッケージ変数は、外部のパッケージからアクセスできます。
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      このパッケージ変数は、外部のパッケージからアクセスできません。デフォルトの設定です。
    </td>
  </tr>
  <tr>
    <td>
      <b>ro</b>
    </td>
    <td>
      このパッケージ変数は、読み込み用のパッケージ変数アクセッサを持ちます。パッケージ変数アクセッサ名は、Package Variable Nameから"$"を除いたものです。Package Variable Nameが"$FOO"の場合は、パッケージ変数アクセッサ名は"FOO"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>wo</b>
    </td>
    <td>
      このパッケージ変数は、書き込み用のパッケージ変数アクセッサを持ちます。パッケージ変数アクセッサ名は、"SET_Package Variable Nameから$を除いたもの"になります。Package Variable Nameが"$FOO"の場合は、パッケージ変数アクセッサ名は"SET_FOO"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>rw</b>
    </td>
    <td>
      このパッケージ変数は、読み込み用のパッケージ変数アクセッサと書き込み用のパッケージ変数アクセッサを持ちます。読み込み用のパッケージ変数アクセッサ名は"ro"で説明したものと同じです。書き込み用のパッケージ変数アクセッサ名は"wo"で説明したものと同じです。
    </td>
  </tr>
</table>
<p>
  "public"と"private"の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
</p>
<p>
  "ro""wo""rw"のひとつより多くが同時に指定されている場合は、コンパイル時エラーが発生します。
</p>
<p>
  パッケージ変数アクセッサとは、パッケージ変数にアクセスするためのクラスメソッドのことです。
</p>
<p>
  書き込み用のパッケージ変数アクセッサの戻り値は"void型"です。
</p>
<p>
  SPVMのソースコードの中からパッケージ変数アクセッサが呼び出された場合は、パッケージ変数アクセッサはインライン展開されます。それ以外の場合は、インライン展開されません。
</p>
<p>
  <b>パッケージ変数定義のExample</b>
</p>
<p>
  パッケージ変数定義のExampleです。
</p>
<pre>
package Foo {
our $NUM1 : byte;
our $NUM2 : short;
our $NUM3 : int;
our $NUM4 : long;
our $NUM5 : float;
our $NUM6 : double;

our $NUM_PUBLIC : public int;
our $NUM_RO : ro int;
our $NUM_WO : wo int;
our $NUM_RW : rw int;
}
</pre>
<h3 id="language-package-var-initial-value">パッケージ変数の初期値</h3>
<p>
  パッケージ変数は、コンパイルが終了して、実行時に入る前に、<a href="#language-type-initial-value">型の初期値</a>で初期化されます。
</p>
<p>
  この初期値は、<a href="#language-begin-block">BEGINブロック</a>を使うことで、変更することができます。
</p>
<pre>
package Foo {
our $VAR : int;

BEGIN {
$VAR = 3;
}
}
</pre>
<h3 id="language-package-var-access">パッケージ変数へのアクセス</h3>
<p>
  パッケージ変数へのアクセスとは、パッケージ変数にアクセスして、値を取得したり、設定したりする操作のことです。
</p>
<p>
  パッケージ変数の値の取得については、<a href="#language-expression-get-package-var">パッケージ変数の値の取得</a>を見てください。
</p>
<p>
  パッケージ変数の値の設定については、<a href="#language-expression-set-package-var">パッケージ変数の値の設定</a>を見てください。
</p>

<h2 id="language-field">フィールド</h2>
<ul class="list">
  <li><a href="#language-field-definition">フィールドの定義</a></li>
  <li><a href="#language-field-access">フィールドへのアクセス</a></li>
</ul>
<h3 id="language-field-definition">フィールドの定義</h3>
<p>
  フィールドとは"new"を使ってオブジェクト生成した場合に、オブジェクトからアクセスできるデータ領域のことです。
</p>
<p>
  "has"Keyword を使用してフィールドを定義することができます。
</p>
<pre>
has Field Name : Type Name ;
</pre>
<p>
  フィールド定義は"<a href="#language-package-definition">パッケージ定義</a>"の直下で行う必要があります。
</p>
<p>
  フィールド定義には"<a href="#language-type">Type Name </a>"が必要です。Type Name には"数値型"と"オブジェクト型"を指定できます。
</p>
<p>
  Field Nameは、1文字以上の"a～z""A～Z""0～9""_"で構成する必要があります。先頭は、数字から始めることはできません。連続した"_"を使用することはできません。
</p>
<p>
  Field Nameには、<a href="#language-lex-keyword">Keyword </a>と同じ名前を使用することができます。
</p>
<p>
  フィールド定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
</p>
<pre>
has Field Name : デスクリプタ Type Name ;
</pre>
<p>
  <b>フィールドデスクリプタ</b>
</p>
<p>
  フィールドで指定できるデスクリプタの一覧です。
</p>
<table>
  <tr>
    <th>
      デスクリプタ名
    </th>
    <th>
      役割
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      このフィールドは、外部のパッケージからアクセスできます。
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      このフィールドは、外部のパッケージからアクセスできません。デフォルトの設定です。
    </td>
  </tr>
  <tr>
    <td>
      <b>ro</b>
    </td>
    <td>
      このフィールドは、読み込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は、Field Nameと同じです。Field Nameが"foo"の場合は、フィールドアクセッサ名は"foo"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>wo</b>
    </td>
    <td>
      このフィールドは、書き込み用のフィールドアクセッサを持ちます。フィールドアクセッサ名は、"set_Field Name"になります。Field Nameが"foo"の場合は、フィールドアクセッサ名は"set_foo"になります。
    </td>
  </tr>
  <tr>
    <td>
      <b>rw</b>
    </td>
    <td>
      このフィールドは、読み込み用のフィールドアクセッサと書き込み用のフィールドアクセッサを持ちます。読み込み用のフィールドアクセッサ名は"ro"で説明したものと同じです。書き込み用のフィールドアクセッサ名は"wo"で説明したものと同じです。
    </td>
  </tr>
</table>
<p>
  "public"と"private"の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
</p>
<p>
  "ro""wo""rw"のひとつより多くが同時に指定されている場合は、コンパイル時エラーが発生します。
</p>
<p>
  フィールドアクセッサとは、フィールドにアクセスするためのメソッドのことです。
</p>
<p>
  書き込み用のフィールドアクセッサの戻り値は"void型"です。
</p>
<p>
  SPVMのソースコードの中からフィールドアクセッサが呼び出された場合は、フィールドアクセッサはインライン展開されます。それ以外の場合は、インライン展開されません。
</p>
<p>
  <b>フィールド定義のExample</b>
</p>
<p>
  フィールド定義のExampleです。
</p>
<pre>
package Foo {
has num1 : byte;
has num2 : short;
has num3 : int;
has num4 : long;
has num5 : float;
has num6 : double;

has num_public : public int;
has num_ro : ro int;
has num_wo : wo int;
has num_rw : rw int;
}
</pre>
<h3 id="language-field-access">フィールドへのアクセス</h3>
<p>
  フィールドへのアクセスとは、フィールドにアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
</p>
<pre>
インボカント->{Field Name}
</pre>
<p>
  フィールドへのアクセスは、一種類の構文で、三つの異なる意味を持ちます。
</p>
<p>
  <b>1. クラス型のフィールドへのアクセス</b>
</p>
<p>
  <a href="#language-type-class">クラス型</a>を元に<a href="#language-expression-new-object">オブジェクトの生成</a>が行われた場合は、オブジェクトからフィールドにアクセスすることができます。
</p>
<pre>
my $point = new Point;
$point->{x} = 1;
</pre>

<p>
  クラス型のフィールドの取得については、<a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a>を見てください。
</p>
<p>
  クラス型のフィールドの設定については、<a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a>を見てください。
</p>
<p>
  <b>2. 複数数値型のフィールドへのアクセス</b>
</p>
<p>
  2. <a href="#language-type-multi-numeric">複数数値型</a>におけるフィールドは、複数数値型の変数の宣言をすれば、その変数からフィールドにアクセスできます。これは、レキシカル変数領域におけるアクセスです。
</p>
<pre>
my $z : SPVM::Complex_2d;
$z->{re} = 1;
$z->{im} = 3;
</pre>
<p>
  複数数値型のフィールドの取得については、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a>を見てください。
</p>
<p>
  複数数値型のフィールドの設定については、<a href="#language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</a>を見てください。
</p>
<p>
  <b>3. デリファレンスによる複数数値型のフィールドのアクセス</b>
</p>
<p>
  複数数値型の変数に対するリファレンス型から、デリファレンスを行って直接に複数数値型のフィールドにアクセスできます。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{re} = 1;
$z_ref->{im} = 3;
</pre>
<p>
  デリファレンスによる複数数値型のフィールドの取得については、<a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの取得</a>を見てください。
</p>
<p>
  デリファレンスによる複数数値型のフィールドの設定については、<a href="#language-expression-set-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの設定</a>を見てください。
</p>

<h2 id="language-sub">サブルーチン</h2>
<ul class="list">
  <li><a href="#language-sub-definition">サブルーチンの定義</a></li>
  <li><a href="#language-sub-constant">定数サブルーチン</a></li>
  <li><a href="#language-sub-new-callback-object">コールバックオブジェクトの生成</a></li>
  <li><a href="#language-sub-capture">キャプチャ</a></li>
  <li><a href="#language-sub-method">メソッド</a></li>
  <li><a href="#language-sub-signature">シグネチャ</a></li>
  <li><a href="#language-sub-invocant">インボカント</a></li>
  <li><a href="#language-sub-stack">サブルーチンのコールスタック</a></li>
</ul>
<h3 id="language-sub-definition">サブルーチンの定義</h3>
<p>
  "sub"Keyword を使用してサブルーチンを定義することができます。
</p>
<pre>
sub Subroutine Name : 戻り値のType Name  (引数名1 : 引数のType Name 1, 引数名2 : 引数のType Name 2, 以下続く) {

}
</pre>
<p>
  サブルーチンの定義は"<a href="#language-package-definition">パッケージ定義</a>"の直下で行う必要があります。
</p>
<p>
  Subroutine Nameは、1文字以上の"a～z""A～Z""0～9""_"で構成する必要があります。先頭は、数字から始めることはできません。連続した"_"を使用することはできません。
</p>
<p>
  Subroutine Nameには、<a href="#language-lex-keyword">Keyword </a>と同じ名前を使用することができます。
</p>
<p>
  戻りのType Name には、"void型""数値型""オブジェクト型"を指定することができます。
</p>
<p>
  サブルーチンの定義には"戻り値のType Name "と"0個以上の引数の定義"が必要です。"引数の定義"は"引数名"と"引数のType Name "からなります。
</p>
<p>
  引数名は、変数名でなければなりません。
</p>
<p>
  引数のType Name には、"数値型""オブジェクト型""リファレンス型"を指定することができます。
</p>

<p>
  サブルーチンのブロックの中には、0個以上のステートメントを記述できます。
</p>

<p>
  サブルーチンの定義には、デスクリプタを合わせて指定することができます。複数のデスクリプタを空白を使って並べることができます。
</p>
<pre>
デスクリプタ名 sub Subroutine Name : 戻り値のType Name  (引数の変数名1 : 引数のType Name 1, 引数の変数名2 : 引数のType Name 2, 以下続く) {

}
</pre>
<p>
  <b>サブルーチンデスクリプタ</b>
</p>
<p>
  サブルーチンで指定できるデスクリプタの一覧です。
</p>
<table>
  <tr>
    <th>
      デスクリプタ名
    </th>
    <th>
      役割
    </th>
  </tr>
  <tr>
    <td>
      <b>native</b>
    </td>
    <td>
      このサブルーチンは、ネイティブサブルーチンです。
    </td>
  </tr>
  <tr>
    <td>
      <b>precompile</b>
    </td>
    <td>
      このサブルーチンはプリコンパイルされます。
    </td>
  </tr>
</table>
<p>
  "native"と"precompile"の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
</p>

<p>
  引数のType Name の後ろに"..."を続けると、可変長引数となります。最後の引数のみ可変長引数にすることができます。
</p>
<pre>
# 可変長引数の定義
sub Subroutine Name : 戻り値のType Name  (引数名1 : 引数のType Name 1, 引数名2 : 引数のType Name 2...) {

}
</pre>
<p>
  <b>可変長引数のExample</b>
</p>
<p>
  可変長引数のExampleです。
</p>
<pre>
# 可変長引数を持つサブルーチンの定義
sub sprintf : string ($format : string, $values : object[]...) {

}

# 可変長引数を持つサブルーチンの呼び出し
foo("aaa %d %f", SPVM::Int->new(1), SPVM::Double->new(2.0));
</pre>
<p>
  可変長引数を持つサブルーチンに配列を渡すと、配列のまま呼び出す事ができます。
</p>
<pre>
foo("aaa %d %f", [(object)SPVM::Int->new(1), SPVM::Double->new(2.0)]);
</pre>
<p>
  もし、配列型の値を、可変長引数の個々の要素として扱いたい場合は、配列型ではない型にキャストしてください。
</p>
<pre>
foo("aaa %d %f", (object)[(object)SPVM::Int->new(1), SPVM::Double->new(2.0)]);
</pre>

<p>
  定義されたサブルーチンは、呼び出すことができます。サブルーチンの呼び出しについては、<a href="language-expression-callsub">サブルーチンの呼び出し</a>を見てください。
</p>

<h3 id="language-sub-constant">定数サブルーチン</h3>
<p>
  数値型の戻り値を持つサブルーチンで、戻り値が定数であるサブルーチンを定数サブルーチンといいます。
</p>
<pre>
sub foo : int () { return 5; }
sub foo : long () { return 5L; }
sub foo : float () { return 5.0f; }
sub foo : double () { return 5.0; }
</pre>
<p>
  定数サブルーチンは、インライン展開されます。
</p>
<p>
  SPVMは定数畳み込み最適化を行わないので、定数が演算されている場合は、定数サブルーチンにならず、インライン展開されないことに注意してください。
</p>
<pre>
# 定数サブルーチンではなくインライン展開されない
sub foo : int () { return 5 + 3; }
</pre>

<h3 id="language-sub-new-callback-object">コールバックオブジェクトの生成</h3>
<p>
  コールバックオブジェクトの生成とは、コールバックの用途で、特別な構文を使って、コールバック型に適合するオブジェクトを生成する文法のことです。
</p>
<pre>
sub : Type Name  ($self : self, 引数1, 引数2, ..., 引数n) {

}
</pre>
<p>
  コールバックオブジェクトの生成を行うと、内部的に、パッケージの定義がおこなわれ、そのパッケージを元にしたオブジェクトが生成され、<a href="#language-expression">式</a>として返されます。以下のように変数に代入することが可能です。
</p>
<pre>
my $cb_obj = sub : Type Name  ($self : self, 引数1, 引数2, ..., 引数n) {

};
</pre>
<p>
  コールバックオブジェクトの生成で定義されるサブルーチンは、<a href="#language-sub-method">メソッド</a>でなければなりません。また名前を持たないサブルーチンでなければなりません。
</p>
<p>
  <b>コールバックオブジェクトの生成のExample</b>
</p>
<pre>
my $comparator = sub : int ($self : self, $x1 : object, $x2 : object) {

}
</pre>
<p>
  コールバックオブジェクトの生成によって生成されたオブジェクトは、通常のオブジェクトなので、メソッドを呼び出すことができます。コールバックオブジェクトの生成の呼び出しについては、<a href="language-expression-callsub">サブルーチンの呼び出し</a>を見てください。
<p>

<h3 id="language-sub-capture">キャプチャ</h3>
<p>
  コールバックオブジェクトの生成においては、キャプチャという構文を使って、コールバックオブジェクトの生成によって定義されたサブルーチンの外側で定義された変数を、コールバックオブジェクトの生成によって定義されたサブルーチンの内側で使うことができます。
</p>
<pre>
# キャプチャ
[変数名1 : 型1, 変数名2 : 型2] sub Subroutine Name : int ($self : self, $x1 : object, $x2 : object) {

};
</pre>

キャプチャのExample。

<pre>
my $foo = 1;
my $bar = 5L;

my $comparator = [$foo : int, $bar : long] sub : int ($self : self, $x1 : object, $x2 : object) {

print "$foo\n";
print "$bar\n";
}
</pre>
<p>
  キャプチャで使用する変数名は、<a href="#language-lex-identifier-field-name">Field Name</a>の先頭に"$"を付けたものでなければなりません。
</p>
<p>
  キャプチャは、実際には、クラスのフィールドとして定義されます。キャプチャは、フィールドの定義と値の設定のシンタックスシュガーです。
</p>
<p>
  スコープ内で、キャプチャ変数と同名の<a href="#language-lex-var">レキシカル変数</a>が存在する場合は、レキシカル変数にアクセスします。
</p>
<p>
  キャプチャ変数と同名の<a href="#language-package-var">パッケージ変数</a>が存在する場合は、キャプチャ変数にアクセスします。
</p>
<p>
  コールバックオブジェクトの生成とキャプチャをシンタックスシュガーを使わないで記述すると次のようになります。
</p>
<pre>
package ComapartorImpl {
has foo : int;
has bar : long;

sub : int ($self : self, $x1 : object, $x2 : object) {

print $self->{foo} . "\n";
print $self->{bar} . "\n";
}
}
<pre>

</pre>
my $foo = 1;
my $bar = 5L;

my $comparator = new ComparatorImpl;

$comparator->{foo} = $foo;
$comparator->{bar} = $bar;
</pre>

キャプチャは、このような長い記述を、短く書くための文法です。

<h3 id="language-sub-method">メソッド</h3>
<p>
  メソッドとは、第一引数に<a href="#language-type-self">self型</a>を持つサブルーチンのことです。
</p>
<pre>
sub Subroutine Name : Type Name  ($self : self, 引数1 : 型1, 引数2 : 型2, ..., 引数n : 型n) {

}
</pre>
<p>
  メソッドは、<a href="#language-expression-new-object">オブジェクトの生成</a>によって生成されたオブジェクトから呼び出すことができます。メソッドの呼び出しについては、<a href="language-expression-callsub">サブルーチンの呼び出し</a>を見てください。
</p>

<h3 id="language-sub-invocant">インボカント</h3>
<p>
  インボカントとは、self型が指定された第一引数のことをいいます。
</p>
<pre>
sub Subroutine Name : Type Name  ($self : self, 引数1 : 型1, 引数2 : 型2, ..., 引数n : 型n) {

}
</pre>
<p>
  上記の例では$selfは、インボカントと呼ばれます。
</p>

<h3 id="language-sub-signature">シグネチャ</h3>
<p>
  シグネチャとは、サブルーチンの戻り値と引数を次の規則で並べたものをいいます。引数は、存在しなくても構いません。間に空白を含むことはできません。
</p>
<p>
  1. 戻り値のType Name 
</p>
<p>
  2. (
</p>
<p>
  3. 引数1,引数2, 引数3, 引数n
</p>
<p>
  4. )
</p>
<p>
  シグネチャのExampleです。
</p>
<pre>
# サブルーチン定義
sub foo : int ($num1 : double, $num2 : long[])

# シグネチャ
int(double,long[])

# サブルーチン定義
sub foo : void ()

# シグネチャ
void()
</pre>
<p>
  シグネチャは、SPVMを記述しているときには、意識する必要はありません。ネイティブからSPVMのサブルーチンを呼び出すときに使用します。
</p>

<h3 id="language-sub-stack">サブルーチンのコールスタック</h3>
<p>
  サブルーチンのコールスタックとは、<a href="#language-expression-callsub">サブルーチンの呼び出し</a>が行われるときに、確保されるメモリ領域のことを指します。
</p>
<p>
  サブルーチンのコールスタックには、以下の情報が保存されます。
</p>
<p>
  1. <a href="#language-lex-var">レキシカル変数</a>のためのメモリ領域
</p>
<p>
  2. モータル変数の場所
</p>

<h2 id="language-enum">列挙</h2>
<ul class="list">
  <li>
    <a href="#language-enum-definition">列挙の定義</a>
  </li>
  <li>
    <a href="#language-enum-call">列挙の呼び出し</a>
  </li>
</ul>
<h3 id="language-enum-definition">列挙の定義</h3>
<p>
  列挙はint型の定数を定義したい場合に利用します。連続したint型の定数を簡単に定義できます。"enum"Keyword を使って定義します。
</p>
<pre>
enum {
FLAG1,
FLAG2,
FLAG3
}
</pre>
<p>
  列挙の定義は"<a href="#language-package-definition">パッケージ定義</a>"の直下で行う必要があります。
</p>
<pre>
package Foo {
enum {
FLAG1,
FLAG2,
FLAG3
}
}
</pre>

<p>
  最初の値は"0"から始まります。値は"1"づつインクリメントされます。この例の場合は"FLAG1"は"0"、"FALG2"は"1"、"FLAG3は"2"になります。
</p>
<p>
  列挙の末尾の要素の後ろには","をつけることができます。
</p>
<pre>
enum {
FLAG1,
FLAG2,
FLAG3,
}
</pre>
<p>
  列挙はint型を戻り値とする"定数サブルーチン"のエイリアスです。次のサブルーチンの定義と等価です。
</p>
<pre>
sub FLAG1 : int () { return 0; }
sub FLAG2 : int () { return 1; }
sub FLAG3 : int () { return 2; }
</pre>
<p>
  enumの要素には、int型の値を設定することができます。
</p>
<pre>
enum {
FLAG1,
FLAG2 = 4,
FLAG3,
}
</pre>
<p>
  上記の場合は"FLAG1"は"0"、"FALG2"は"4"、"FLAG3"は"5"になります。
</p>
<p>
  enumの定義がInvalid 場合は、コンパイル時エラーが発生します。
</p>

<p>
  <b>列挙デスクリプタ</b>
</p>
<p>
  列挙には、デスクリプタを指定することができます。
</p>
<pre>
private enum {
FLAG1,
FLAG2 = 4,
FLAG3,
}
</pre>
<p>
  列挙で指定できるデスクリプタの一覧です。
</p>
<table>
  <tr>
    <th>
      デスクリプタ名
    </th>
    <th>
      役割
    </th>
  </tr>
  <tr>
    <td>
      <b>public</b>
    </td>
    <td>
      この列挙は、外部のパッケージからアクセスできます。デフォルトの設定です。
    </td>
  </tr>
  <tr>
    <td>
      <b>private</b>
    </td>
    <td>
      この列挙は、外部のパッケージからアクセスできません。
    </td>
  </tr>
</table>
<p>
  "public"と"private"の両方のデスクリプタが指定された場合は、コンパイル時エラーが発生します。
</p>

<h3 id="language-enum-call">列挙の呼び出し</h3>
<p>
  列挙は、定数サブルーチンのエイリアスなので、サブルーチン呼び出しとまったく同じ方法で呼び出すことができます。
</p>
<pre>
my $flag1 = Foo->FLAG1;
my $flag2 = Foo->FLAG2;
my $flag3 = Foo->FLAG3;
</pre>
<p>
  switch文のcase文において利用することもできます。
</p>
<pre>
switch ($num) {
case Foo->FLAG1: {

break;
}
case Foo->FLAG2: {

break:
}
case Foo->FLAG3: {

break:
}
default: {

}
}
</pre>
<h2 id="language-begin-block">BEGINブロック</h2>
<p>
  BEGINブロックとは、コンパイル時が終了し、実行時に入る前に、実行されるブロックのことです。
</p>
<p>
  BEGINKeyword を使用してBEGINブロックを定義することができます。
</p>
<pre>
BEGIN {

}
</pre>
<p>
  BEGINブロックは、パッケージの定義の直下にある必要があります。
</p>
<pre>
package Foo {
BEGIN {

}
}
</pre>
<p>
  BEGINブロックの中には、0個以上の<a href="#language-statement">文</a>を書くことができます。
</p>
<pre>
BEGIN {
my $foo = 1 + 1;
my $bar;
}
</pre>
<p>
  return文を書くことはできません。BEGINブロックは、引数がなく、戻り値がvoidのサブルーチンとして定義されます。
</p>
<p>
  BEGINブロックは、いくつでも定義できます。
</p>
<p>
  BEGINブロックの実行順序は、保証されません。他のパッケージにBEGINブロックが定義されている場合は、そのBEGINブロックが先に実行されることを想定しないでください。
</p>
<p>
  BEGINブロックの一般的な用途は、<a href="#language-package-var">パッケージ変数</a>を初期化することです。
</p>
<pre>
package Foo {
our $NUM : int;
our $POINT : Point;
BEGIN {
$NUM = 3;
$POINT = Point->new;
}
}
</pre>

<h2 id="language-lex-var">レキシカル変数</h2>
<ul class="list">
  <li><a href="#language-lex-var-declaration">レキシカル変数の宣言</a></li>
  <li><a href="#language-lex-var-initial-value">レキシカル変数の初期値</a></li>
  <li><a href="#language-lex-var-access">レキシカル変数へのアクセス</a></li>
</ul>
<h3 id="language-lex-var-declaration">レキシカル変数の宣言</h3>
<p>
  レキシカル変数とは、<a href="#language-scope-block">スコープブロック</a>の中で利用できる、<a href="#language-scope">スコープ</a>を持つ変数のことです。C言語のローカル変数に該当します。
</p>
<pre>
{
my $num : int;
}
</pre>
<p>
  レキシカル変数は"my"Keyword によって宣言します。":"の後ろに"<a href="#language-type">型</a>"を指定する必要があります。
</p>
<pre>
my $num : int;
</pre>
<p>
  レキシカル変数は、<a href="#language-lex-var-initial-value">レキシカル変数の初期値</a>によって初期化されます。
</p>
<pre>
# 0で初期化される
my $num : int;

# 0で初期化される
my $num : double;

# undefで初期化される
my $point : Point;

# reは0, imは0で初期化される
my $z : SPVM::Complex_2d;
</pre>
<p>
  レキシカル変数の宣言と同時に初期化を行うことができます。
</p>
<pre>
# 1で初期化される
my $num : int = 1;

# 2.5で初期化される
my $num : double = 2.5;

# Pointオブジェクトで初期化される
my $point : Point = new Point;
</pre>
<p>
  <a href="#language-type-inference">型推論</a>を使うと、宣言するときに、型の指定を省略することができます。
</p>
<pre>
# int
my $num = 1;

# double
my $num = 1.0;
</pre>
<p>
  レキシカル変数の宣言は、レキシカル変数の値を返します。これは、<a href="#language-expression">式</a>として利用できます。
</p>
<pre>
my $ppp = my $bar = 4;

if (my $bar = 1) {

}

while (my $bar = 1) {

}
</pre>

<p>
  レキシカル変数の宣言は、レキシカル変数が<a href="#language-type-object">オブジェクト型</a>であった場合に、レキシカル変数を、モータル変数として、実行時に登録します。モータル変数として登録されたレキシカル変数に代入されているオブジェクトは、<a href="#language-scope">スコープ</a>の末尾で、リファレンスカウントが自動的に1減らされます。
</p>

<h3 id="language-lex-var-initial-value">レキシカル変数の初期値</h3>
<p>
  レキシカル変数は、<a href="#language-type-initial-value">型の初期値</a>で初期化されます。
</p>

<h3 id="language-lex-var-access">レキシカル変数へのアクセス</h3>
<p>
  レキシカル変数へのアクセスとは、レキシカル変数にアクセスして、値を取得したり、設定したりする操作のことです。
</p>
<p>
  <b>レキシカル変数の値の取得</b>については、<a href="#language-expression-get-lex-var">レキシカル変数の値の取得</a>を見てください。
</p>
<p>
  <b>レキシカル変数の値の設定</b>については、<a href="#language-expression-set-lex-var">レキシカル変数の値の設定</a>を見てください。
</p>
<p>
  レキシカル変数と同名の<a href="#language-package-var">パッケージ変数</a>が存在した場合は、レキシカル変数にアクセスします。
</p>

<h2 id="language-block">ブロック</h2>
<p>
  "{"と"}"で囲まれた部分のことをブロックと呼びます。
</p>
<pre>
# ブロック
{

}
</pre>
<p>
  ブロックの中には、スコープを作る<a href="#language-scope-block">スコープブロック</a>があります。
</p>

<h2 id="language-scope">スコープ</h2>
<ul class="list">
  <li><a href="#language-scope-role">スコープの役割</a>
  <li><a href="#language-scope-block">スコープブロック</a>
</ul>

<h3 id="language-scope-role">スコープの役割</h3>
<p>
  スコープとは<a href="#language-scope-block">スコープブロック</a>に囲まれた範囲のことをいいます。
</p>
<pre>
# スコープブロック
{

}
</pre>
<p>
  スコープの中で宣言されたレキシカル変数は、実行時に、宣言されている位置で、モータルなレキシカル変数として登録されます。
</p>
<pre>
{
# レキシカル変数をモータルとして登録
my $num = new Foo;
}
</pre>
<p>
  モータルなレキシカル変数に代入されたオブジェクトが、未定義値ではない場合は、リファレンスカウントが1増やされます。
</p>
<p>
  スコープの終わりに到達すると、モータルなレキシカル変数に代入されているオブジェクトは、未定義値でない場合、リファレンスカウントが1減らされ、0になった場合は、解放されます。
</p>
<h3 id="language-scope-block">スコープブロック</h3>
<p>
  スコープブロックとは、スコープを作るブロックのことです。スコープブロックには、0個以上の<a href="#language-statement">文</a>を記述することができます。
</p>
<pre>
# スコープブロック
{
my $num = 1;
$num++;
}
</pre>
<p>
  <b>スコープブロックの一覧</b>
<p>
<ul class="list">
  <li><a href="#language-block-statement-simple">単純なブロック</a></li>
  <li><a href="#language-block-statement-sub">サブルーチンブロック</a></li>
  <li><a href="#language-block-statement-eval">evalブロック</a></li>
  <li><a href="#language-block-statement-if">ifブロック</a></li>
  <li><a href="#language-block-statement-elsif">elsifブロック</a></li>
  <li><a href="#language-block-statement-else">elseブロック</a></li>
  <li><a href="#language-block-statement-for">forブロック</a></li>
  <li><a href="#language-block-statement-while">whileブロック</a></li>
  <li><a href="#language-block-statement-switch">switchブロック</a></li>
</ul>

<h4 id="language-block-statement-simple">単純なブロック</h4>
<pre>
# 単純なブロック
{

}
</pre>

<h4 id="language-block-statement-sub">サブルーチンブロック</h4>
<pre>
# サブルーチンのブロック
sub foo : int () {

}
</pre>

<h4 id="language-block-statement-eval">evalブロック</h4>
<pre>
# evalブロック
eval {

}
</pre>

<h4 id="language-block-statement-if">ifブロック</h4>
<pre>
# ifブロック
if (式) {

}
</pre>

<h4 id="language-block-statement-elsif">elsifブロック</h4>
<pre>
#elsifブロック
elsif (式) {

}
</pre>

<h4 id="language-block-statement-else">elseブロック</h4>
<pre>
# elseブロック
else {

}
</pre>

<h4 id="language-block-statement-for">forブロック</h4>
<pre>
# for ブロック
for (my $i = 0; $i < 3; $i++) {

}
</pre>

<h4 id="language-block-statement-while">whileブロック</h4>
<pre>
# whileブロック
while (式) {

}
</pre>

<h4 id="language-block-statement-switch">switchブロック</h4>
<pre>
switch (式) {

}
</pre>
<h2 id="language-warn">警告</h2>
<h3 id="language-exception-summary">警告を発生させる</h3>
<p>
  警告を発生させるにはwarn文を使用します。
</p>
<pre>
warn 式;
</pre>
<p>
  式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
  末尾が改行文字"\n"であった場合は、標準エラー出力に式で指定されている文字列が出力されます。
</p>
<p>
  末尾が改行文字でない場合は、末尾にファイル名と行番号が追加され、標準エラー出力されます。
</p>
<p>
  式で指定された文字列の長さが0あるいは、未定義値であった場合は、指定されたメッセージが"Warning: something's wrong"であるとしてふるまいます。
</p>
<p>
  標準エラー出力のバッファがフラッシュされます。
</p>

<h2 id="language-print">print文</h2>
<p>
  標準出力に文字列を出力するにはprint文を使用します。
</p>
<pre>
print 式;
</pre>
<p>
  式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
  式が未定義値であった場合は、何もしません。
</p>

<h2 id="language-exception">例外処理</h2>
<ul class="list">
  <li><a href="#language-exception-summary">例外処理の概要</a></li>
  <li><a href="#language-exception-occur">例外の発生</a></li>
  <li><a href="#language-exception-catch">例外変数のキャッチ</a></li>
  <li><a href="#language-exception-var">例外変数</a></li>
</ul>

<h3 id="language-exception-summary">例外処理の概要</h3>
<p>
  SPVMは例外処理の仕組みを持っています。例外処理は、例外の発生と例外のキャッチからなります。
</p>

<h3 id="language-exception-occur">例外の発生</h3>
<p>
  例外の発生を行うには、die文を使用します。
</p>
<pre>
die 式;
</pre>
<p>
  式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
  die文が実行されると、スタックトレースと式で指定された文字列を表示して、プログラムは終了します。スタックトレースは、Package Name、Subroutine Name、ファイル名、行番号を含みます。ファイル名は、モジュールをロードしたパスからの相対ファイル名です。
</p>
<pre>
Error
from TestCase::Minimal->sum2 at TestCase/Minimal.spvm line 1640
from TestCase->main at TestCase.spvm line 1198
</pre>

<h3 id="language-exception-occur">例外のキャッチ</h3>
<p>
  例外のキャッチとは、例外がスローされた場合に、プログラムが終了するのを止め、エラーメッセージを取得できる機能のことです。
</p>
<p>
  例外のキャッチは、evalブロック文を使って行います。evalブロック文は、末尾にセミコロンが必要なので気をつけてください。
</p>
<pre>
eval {
# 例外を投げる可能性のある処理
};
</pre>
<p>
  evalブロックで例外をキャッチした場合は、プログラムの終了は止められ、<a href="#language-exception-var">例外変数</a>に<a href="#language-exception-occur">例外の発生</a>で指定したメッセージが代入されます。
</p>

<h3 id="language-exception-var">例外変数</h3>
<p>
  例外変数は"$@"で表現されるグローバル変数のことです。
</p>
<pre>
$@
</pre>
<p>
  例外変数は、本当の意味では、グローバル変数ではありません。例外変数は、実は、スレッド変数です。SPVMはシングルスレッド設計なので、例外変数は、グローバル変数として振舞うように見えます。ネイティブにおいてスレッドを利用する場合に、違いがあります。
</p>
<p>
  例外変数の値の取得については、<a href="#language-expression-get-exception-var">例外変数の値の取得</a>を見てください。
</p>
<p>
  例外変数の値の設定については、<a href="#language-expression-set-exception-var">例外変数の値の設定</a>を見てください。
</p>

<h2 id="language-weak-ref">ウィークリファレンス</h2>
<p>
  ウィークリファレンスとは、リファレンスカウントを増やさない参照のことです。ウィークリファレンスを使用すると、循環参照の問題を解決することができます。
</p>
<p>
  SPVMは、リファレンスカウント型のGCを持ちます。リファレンスカウント型のGCにおいては、リファレンスカウントが0になった場合に、オブジェクトは自動的に開放されますが、循環参照が発生した場合は、リファレンスカウントが0にならず、オブジェクトが自動的に解放されません。
</p>
<p>
  オブジェクトのフィールドが、循環参照している場合のExampleです。
</p>
<pre>
{
my $foo = new Foo;
my $bar = new Bar;

$foo->{bar} = $bar;
$bar->{foo} = $foo;
}
</pre>
<p>
  この場合は、スコープが終了しても、両方のオブジェクトは解放されません。なぜなら、循環参照が発生しており、リファレンスカウントが0にならないためです。
</p>
<p>
  ウィークリファレンスは、リファレンスカウントGCを持つプログラミング言語において、循環参照が発生した場合に、オブジェクトの破棄を正しく行うための機能です。
</p>
<p>
  このような場合は、ひとつのフィールドを、<a href="#language-statement-weaken">weaken文</a>を使って、ウィークリファレンスに設定することで、正しく解放することができます。
</p>
<pre>
{
my $foo = new Foo;
my $bar = new Bar;

$foo->{bar} = $bar;
$bar->{foo} = $foo;

weaken $foo->{bar};
}
</pre>
<p>
  weaken文が実行される前の、$fooのリファレンスカウントは2、$barのリファレンスカウントは2です。
</p>
<p>
  もしweaken文がない場合は、スコープが終了したとしても、$fooのリファレンスカウントも、$barのリファレンスカウントも0にならず、解放されません。
</p>
<p>
  weaken文が実行されるとは、$fooのリファレンスカウントは2、$barのリファレンスカウントは1になります。
</p>
<p>
  スコープが終了すると、$barのリファレンスカウントが1減らされ0になるので、正しく解放されます。
</p>
<p>
  3つの循環参照の場合でも、ひとつのフィールドにウィークリファレンスを設定すれば、正しく解放できます。
</p>
<pre>
{
my $foo = new Foo;
my $bar = new Bar;
my $baz = new Baz;

$foo->{bar} = $bar;
$bar->{baz} = $baz;
$baz->{foo} = $foo;

weaken $foo->{bar};
}
</pre>
<p>
  ウィークリファレンス関連の文法として、ウィークリファレンスを解除できる<a href="#language-statement-weaken">weaken文</a>と、フィールドがウィークリファレンスかどうかを確認できる<a href="#language-operator-isweak">isweakOperator </a>があります。
</p>

<h2 id="language-callback">コールバック</h2>
<p>
  SPVMにおけるコールバック型とは、実装を持たない名前のないメソッドが一つだけ定義されたパッケージ型のことをいいます。<a href="#language-package-definition">パッケージの定義</a>においてcallback_tデスクリプタを指定すると、コールバック型になります。
</p>
<p>
  コールバック型の目的は、異なるオブジェクトが、同じメソッド定義を持つときに、どちらも代入できる型を提供することにあります。C言語の関数ポインタに該当する機能をSPVMにおいて実現するものと考えてください。
</p>
<pre>
package Foo1 {
sub new : Foo1 () {
new Foo1;
}
sub : int ($self : self, $num : int) {
return 1 + $num;
}
}

package Foo2 {
sub new : Foo2 () {
new Foo2;
}
sub : int ($self : self, $num : int) {
return 2 + $num;
}
}

package FooCallback : callback_t {
sub : int ($self : self, $num : int);
}
</pre>

<p>
  Foo1とFoo2は同じメソッド定義"sub : int ($self : self, $num : int)"を持ちます。ここで、選択的にFoo1またはFoo2のメソッドを呼び出したいとします。
</p>
<p>
  この場合に、同じメソッド定義を持つコールバック型FooCallbackを定義すると、この型にどちらのオブジェクトも代入できます。そして、このオブジェクトから、メソッドを呼び出すことができます。
</p>
<pre>
my $foo1 = Foo1->new;
my $foo2 = Foo2->new;

my $foo : FooCallback;

my $flag = 1;
if ($flag) {
$foo = $foo1;
}
else {
$foo = $foo2;
}

my $ret = $foo->(5);
</pre>
<p>
  $flagが1の場合は、Foo1の無名メソッドが、そうでない場合はFoo2の無名メソッドが呼び出されます。
</p>
<p>
  コールバック型の詳細については、<a href="#language-type-callback">コールバック型</a>を見てください。
</p>

<h3 id="language-exception-summary">例外処理の概要</h3>

<h2 id="language-array">配列</h2>
<ul class="list">
  <li><a href="#language-array-summary">配列の概要</a></li>
  <li><a href="#language-array-new">配列の生成</a></li>
  <li><a href="#language-array-access">配列へのアクセス</a></li>
</ul>
<h3 id="language-array-summary">配列の概要</h3>
<p>
  配列とは、複数の値の連続領域を表現するためのデータ構造です。
</p>
<p>
  配列には次の種類があります。
</p>
<ul class="list">
  <li>
    数値型の配列
  </li>
  <li>
    オブジェクト型の配列
  </li>
  <li>
    複数数値型の配列
  </li>
</ul>
<p>
  数値型の配列とは、<a href="#language-type-numeric">数値型</a>の値が連続に並んだ配列のことです。
</p>
<p>
  オブジェクト型の配列とは、<a href="#language-type-object">オブジェクト型</a>の値が連続に並んだ配列のことです。
</p>
<p>
  複数数値型の配列とは、<a href="#language-type-multi-numeric">複数数値型</a>の値が連続に並んだ配列のことです。
</p>

<h3 id="language-array-summary">配列の生成</h3>
<p>
  配列を生成については、<a href="#language-expression-new-array">配列の生成</a>を見てください。
</p>

<h3 id="language-array-access">配列へのアクセス</h3>
<p>
  配列へのアクセスとは、配列にアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
</p>
<pre>
配列->[添え字]
</pre>

<p>
  配列の取得については、<a href="#language-expression-get-array-element">配列の要素の値の取得</a>を見てください。
</p>
<p>
  配列の設定については、<a href="#language-expression-set-set-array-element">配列の要素の値の設定</a>を見てください。
</p>

<h2 id="language-value">値</h2>
<ul class="list">
  <li><a href="#language-value-definition">複数数値型の定義</a></li>
  <li><a href="#language-value-usage">複数数値型の使用</a></li>
  <li><a href="#language-value-access">複数数値型のフィールドへのアクセス</a></li>
</ul>

<h3 id="language-value-definition">複数数値型の定義</h2>
<p>
  SPVMには、他の言語ではあまり見ることのない値というものがあります。
</p>
<p>
  値は、連続した数値を表現します。たとえば、連続した32bit符号付整数が3つであるとか、連続した倍精度浮動小数点が2つなどです。3次元の点、複素数、四元数などを表現することが想定されています。
</p>
<p>
  値を使用するには、最初に、複数数値型を定義します。複数数値型は、<a href="#language-package-definition">パッケージの定義</a>において、mulnum_tデスクリプタを指定することで定義できます。
</p>
<pre>
# 連続した32bit符号付整数が3つ
package Point_3i : mulnum_t {
has x : int;
has y : int;
has z : int;
}

連続した倍精度浮動小数点が2つ
package Complex_2d : mulnum_t {
re : double;
im : double;
}
</pre>
<p>
  すべてのフィールドは同じ<a href="#language-type-numeric">数値型</a>でなければなりません。
</p>
<p>
  複数数値型の末尾は"_""フィールドの個数""複数数値型のサフィックス"でなければなりません。
</p>
<p>
  <b>複数数値型のサフィクスの一覧</b>
</p>
<table>
  <tr>
    <th>
      <b>数値型</b>
    </th>
    <th>
      サフィックス
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      b
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      s
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      i
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      l
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      f
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      d
    </td>
  </tr>
</table>
<p>
  サフィックスは、実際に定義されている数値型と対応している必要があります。
</p>
<p>
  数値型の定義において、フィールドの個数の最大は16です。
</p>
<p>
  Invalid 複数数値型の定義の場合は、コンパイル時エラーが発生します。
</p>
<p>
  複数数値型は、<a href="#language-lex-var-declaration">レキシカル変数の宣言</a>の型として利用することができます。
</p>
<p>
  複数数値型は、<a href="#language-sub-definition">サブルーチンの定義</a>における引数の型として利用することができます。
</p>
<p>
  複数数値型は、<a href="#language-sub-definition">サブルーチンの定義</a>における戻り値の型として利用することができます。
</p>
<p>
  複数数値型は<a href="#language-type-array">配列型</a>の<a href="#language-type-basic">基本型</a>として利用することができます。
</p>
<pre>
my $points = new Point_3i[5];
</pre>
<p>
  複数数値型は、フィールドの型として利用することはできません。
</p>
<p>
  複数数値型は、パッケージ変数の型として利用することはできません。
</p>
<p>
  複数数値型の値に対しては、リファレンスを生成することができます。
</p>
<pre>
my $point : Point_3i;
my $point_ref = \$point;
</pre>
<p>
  複数数値型の値に、未定義値を代入することはできません。代入しようとした場合は、コンパイル時エラーが発生します。
</p>

<h2 id="language-value-array">値の配列</h2>
<ul class="list">
  <li><a href="language-array-summary">値の配列の概要</a></li>
  <li><a href="language-array-access">値の配列へのアクセス</a></li>
</ul>

<h3 id="language-array-summary">値の配列の概要</h3>
<p>
  複数数値型の値は、<a href="#language-array">配列</a>にすることができます。
</p>
<pre>
my $points = new Point_3i[5];

my $zs = new Complex_2d[5];
</pre>
<p>
  値の配列は、複数数値型の値が、連続したデータ構造をとります。配列の要素は、オブジェクトではなく、数値がメモリ上に一直線に並んで、配置されます。
</p>
<p>
  たとえば、Point_3i型の5の長さの配列であれば、Point_3i型は、int型の数値が3つ並んだ型で、長さが5なので、"5 * 3 = 15"個のint型の数値が、メモリ上に一直線に並んだデータになります。
</p>
<p>
  値の配列の型は、<a href="#language-type-array">配列型</a>です。
</p>
<p>
  値の配列の要素の型は、<a href="#language-type-multi-numeric">複数数値型</a>です。
</p>

<h3 id="language-array-access">値の配列へのアクセス</h3>
<p>
  値の配列へのアクセスとは、値の配列にアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
</p>
<pre>
配列->[添え字]
</pre>
<p>
  値の配列へのアクセスは、配列のアクセスと同じ構文で行うことができます。
</p>
<p>
  配列の取得については、<a href="#language-expression-get-array-element">配列の要素の値の取得</a>を見てください。
</p>
<p>
  配列の設定については、<a href="#language-expression-set-set-array-element">配列の要素の値の設定</a>を見てください。
</p>

<h3 id="language-value-usage">複数数値型の使用</h2>
<p>
  複数数値型を使用するにはuse文を使って、モジュールをロードします。
</p>
<pre>
use Point_3i;
use Complex_2d;
</pre>
<p>
  次に、レキシカル変数の宣言を行います。レキシカル変数の宣言を行うと、連続した領域が、<a href="#language-sub-stack">サブルーチンのコールスタック</a>上に確保されます。フィールドのすべての値は、<a href="language-type-initial-value">型の初期値</a>で初期化されます。
</p>
<pre>
my $point : Point_3i;
my $z : Complex_2d;
</pre>
<p>
  複数数値型の値は、オブジェクトではないので、<a href="#language-expression-new-object">オブジェクトの生成</a>の構文では生成できないことに注意してください。
</p>

<h3 id="language-value-access">複数数値型のフィールドへのアクセス</h2>
<p>
  複数数値型のフィールドへのアクセスとは、複数数値型のフィールドにアクセスして、値を取得したり、設定したりする操作のことです。また、以下の記述そのものを指します。
</p>
<pre>
インボカント->{Field Name}
</pre>
<p>
  複数数値型のフィールドの取得については、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a>を見てください。
</p>
<p>
  複数数値型のフィールドの設定については、<a href="#language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</a>を見てください。
</p>
<p>
  <b>複数数値型のフィールドの値の取得・設定のExample</b>
</p>
<p>
  複数数値型のフィールドの値の取得・設定のExampleです。
</p>
<pre>
$ival2->{x} = 1;
my $y = $ival2->{y};

$dval4->{t} = 2.5;
my $z = $dval4->{z};
</pre>

<h2 id="language-ref">リファレンス</h2>
<ul>
  <li><a href="language-ref-summary">リファレンスの概要</a></li>
  <li><a href="language-ref-deref">デリファレンス</a></li>
</ul>

<h3 id="language-ref">リファレンスの概要</h3>
<p>
  リファレンスとは、レキシカル変数のアドレスのことをいいます。リファレンスは、C言語のポインタに該当する機能を実現するために、設計されました。
</p>
<p>
  レキシカル変数のアドレスは、<a href="#language-operator-ref">リファレンスOperator </a>を使用して取得できます。<a href="#language-type-ref">リファレンス型</a>は、<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-multi-numeric">複数数値型</a>の後ろに"&"を続けたものになります。
</p>
<pre>
# 数値型の変数のリファレンス
my $num : int;
my $num_ref : int& = \$num;

# 複数数値型の変数のリファレンス
my $point : Point_3d;
my $point_ref : Point_3d& = \$point;
</pre>
<p>
  $num_refの値は、レキシカル変数"$num"のアドレスになります。$point_refの値は、レキシカル変数"$point"のアドレスになります。
</p>
<p>
  リファレンスOperator の対象は、<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-multi-numeric">複数数値型</a>の値が格納された変数だけです。オブジェクト型の変数や定数に対して、使うことはできません。
</p>
<p>
  <a href="#language-type-ref">リファレンス型</a>の値は、サブルーチンの引数として利用することができます。
</p>
<pre>
# サブルーチンの定義
sub sum : void ($out_ref : int&, $in1 : int, $in2 : int) {
$$out_ref = $in1 + $in2;
}

# サブルーチンの利用
my $num1 = 1;
my $num2 = 2;
my $out : int;
my $out_ref = \$out;
sum($out_ref, $num1, $num2);
</pre>

<h3 id="language-ref-deref">デリファレンス</h3>
<p>
  デリファレンスとは、アドレスの場所にあるレキシカル変数の値を取得・設定する操作をいいます。
</p>
<p>
  デリファレンスすることで、アドレスを通して値を取得したり、変更することができます。
</p>
<pre>
# 数値型の値を取得
my $num2 = $$num_ref;

# 数値型の値を変更
$$num_ref = 3;

# 複数数値型の値を取得
my $point2 = $$point_ref;

# 複数数値型の値を設定
$$point_ref = $point2;
</pre>

<p>
  リファレンス型の対象が複数数値型であった場合に、複数数値型のフィールドの設定と取得は、アローOperator で行うことができます。
</p>
<pre>
# リファレンス型の対象が複数数値型であった場合に、複数数値型のフィールドを取得
my $x = $point_ref->{x};

# リファレンス型の対象が複数数値型であった場合に、複数数値型のフィールドを設定
$point_ref->{x} = 1;
</pre>

<h3 id="language-type-ref-numeric">数値のリファレンス型</h3>
<p>
  数値のリファレンス型とは、<a href="#language-type-numeric">数値型</a>の変数に対する<a href="#language-type-ref">リファレンス型</a>のことをいいます。
</p>
<h3 id="language-type-ref-multi-numeric">複数数値のリファレンス型</h3>
<p>
  複数数値のリファレンス型とは、<a href="#language-type-multi-numeric">複数数値型</a>の変数に対する<a href="#language-type-ref">リファレンス型</a>のことをいいます。
</p>

</p>

<h2 id="language-expression">式</h2>
<ul class="list">
  <li class="language-expression-summary">式とは</li>
  <li class="language-expression-current-package">現在のPackage Nameの取得</li>
  <li class="language-expression-current-file">現在のファイル名の取得</li>
  <li class="language-expression-current-line">現在の行番号の取得</li>
</ul>

<h3 id="language-expression">式とは</h3>
<p>
  式とは、値の評価が可能な<a href="#language-expresssion">式</a>のことです。
</p>
<p>
  <b>式の一覧</b>
</p>
<ul class="list">
  <li><a href="#language-expression-get-lex-var">レキシカル変数の値の取得</a></li>
  <li><a href="#language-expression-set-lex-var">レキシカル変数の値の設定</a></li>
  <li><a href="#language-expression-get-package-var">パッケージ変数の値の設定</a></li>
  <li><a href="#language-expression-set-package-var">パッケージ変数の値の取得</a></li>
  <li><a href="#language-expression-get-exception-var">例外変数の値の設定</a></li>
  <li><a href="#language-expression-set-exception-var">例外変数の値の取得</a></li>
  <li><a href="#language-literal">Literal </a></li>
  <li><a href="#language-undef">未定義値</a></li>
  <li><a href="#language-expression-callsub">サブルーチンの呼び出し</a></li>
  <li><a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a></li>
  <li><a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a></li>
  <li><a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a></li>
  <li><a href="#language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</a></li>
  <li><a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの取得</a></li>
  <li><a href="#language-expression-set-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの設定</a></li>
  <li><a href="#language-expression-get-array-element">配列の要素の値の取得</a></li>
  <li><a href="#language-expression-set-array-element">配列の要素の値の設定</a></li>
  <li><a href="#language-expression-typecast">型キャスト</a></li>
  <li><a href="#language-expression-new-object">オブジェクトの生成</a></li>
  <li><a href="#language-expression-new-array">配列の生成</a></li>
  <li><a href="#language-expression-release-object">オブジェクトの解放</a></li>
  <li><a href="#language-expression-array-init">配列の初期化</a></li>
  <li><a href="#language-operator-array-length">配列長Operator </a></li>
  <li><a href="#language-operator-string-length">文字列長Operator </a></li>
  <li><a href="#language-operator-arithmetic">算術Operator </a></li>
  <li><a href="#language-operator-bit">ビットOperator </a></li>
  <li><a href="#language-operator-shift">シフトOperator </a></li>
  <li><a href="#language-operator-concat">文字列連結Operator </a></li>
  <li><a href="#language-operator-ref">リファレンスOperator </a></li>
  <li><a href="#language-operator-deref">リファレンスOperator </a></li>
  <li><a href="#language-operator-assign">代入Operator </a></li>
  <li><a href="#language-operator-array-length">配列長Operator </a></li>
  <li><a href="#language-operator-string-length">文字列長Operator </a></li>
  <li><a href="#language-operator-scalar">スカラOperator </a></li>
  <li><a href="#language-expression-current-package">現在のPackage Nameの取得</a></li>
  <li><a href="#language-expression-current-file">現在のファイル名の取得</a></li>
  <li><a href="#language-expression-current-line">現在の行番号の取得</a></li>
  <li>(式)</li>
</ul>

<h3 id="language-expression-get-lex-var">レキシカル変数の値の取得</h3>
<p>
  レキシカル変数の値の取得をするには、レキシカル変数自体を記述します。
</p>
<pre>
$var
</pre>
<p>
  レキシカル変数の値の取得は、<a href="#language-expression">式</a>です。
</p>

<h3 id="language-expression-set-lex-var">レキシカル変数の値の設定</h3>
<p>
  レキシカル変数の値の設定を行うには、<a href="#language-operator-assign">代入Operator </a>を使用します。
</p>
<pre>
$var = 右式
</pre>
<p>
  代入が<a href="#language-type-compatible">型の互換性</a>を満たさない場合は、コンパイル時エラーが発生します。
</p>
<p>
  レキシカル変数の値の設定は、設定後の値を返します。
</p>
<p>
  レキシカル変数の値の設定は、<a href="#language-expression">式</a>です。
</p>
<p>
  右式が、オブジェクト型であった場合は、オブジェクトのリファレンスカウントが1増やされます。
</p>
<p>
  代入前に、すでに$varにオブジェクトが代入されていた場合は、そのオブジェクトのリファレンスカウントが1減らされます。
</p>

<h3 id="language-expression-get-package-var">パッケージ変数の値の取得</h3>
<p>
  パッケージ変数の値を取得するには以下の構文を使用します。
</p>
<pre>
$クラス名::Package Variable Name
</pre>
<p>
  自分自身のパッケージに属するパッケージ変数の場合は"クラス名::"を省略できます。
</p>
<pre>
$Package Variable Name
</pre>
<p>
 パッケージ変数の値の取得は、<a href="#language-expression">式</a>を返します。
</p>
<p>
  定義されていないパッケージ変数の値を取得しようとした場合は、コンパイル時エラーが発生します。
</p>
<p>
  パッケージの外側からプライベートなパッケージ変数にアクセスしようとした場合は、コンパイル時エラーが発生します。
</p>
<p>
  <b>パッケージ変数の値の取得のExample</b>
</p>
<pre>
package Foo {
our $VAR : int;

sub bar : int () {
my $var1 = $Foo::VAR;
my $var2 = $VAR;
}
}
</pre>

<h3 id="language-expression-set-package-var">パッケージ変数の値の設定</h3>
<p>
  パッケージ変数の値を設定するには以下の構文を使用します。
</p>
<pre>
$クラス名::Package Variable Name = 右式
</pre>
  自分自身のパッケージに属するパッケージ変数の場合は"クラス名::"を省略できます。
</p>
<pre>
$Package Variable Name = 右式
</pre>
<p>
  パッケージ変数設定は、<a href="#language-expression">式</a>を返します。返される結果は、代入後のパッケージ変数の値です。
</p>
<p>
  定義されていないパッケージ変数の値を設定しようとした場合は、コンパイル時エラーが設定します。
</p>
<p>
  パッケージの外側からプライベートなパッケージ変数にアクセスしようとした場合は、コンパイル時エラーが発生します。
</p>
<p>
  <b>パッケージ変数の値の設定のExample</b>
</p>
<pre>
package Foo {
our $VAR : int;

sub bar : int () {
$Foo::VAR = 1;
$VAR = 3;
}
}
</pre>

<h3 id="language-expression-get-exception-var">例外変数の値の取得</h3>
<p>
  例外変数の値を取得するには以下の構文を使用します。
</p>
<pre>
$@
</pre>
<p>
 例外変数の値の取得は、<a href="#language-expression">式</a>を返します。
</p>
<p>
 例外変数の値の取得は、<a href="#language-type-string">文字列型</a>の値を返します。
</p>
<p>
  <b>例外変数の値の取得のExample</b>
</p>
<p>
  例外変数の値の取得のExampleです。
</p>
<pre>
eval {
foo();
};

if (my $message = $@) {

}
</pre>

<h3 id="language-expression-set-exception-var">例外変数の値の設定</h3>
<p>
  例外変数の値を設定するには以下の構文を使用します。
</p>
<pre>
$@ = 右式
</pre>
<p>
  右式は<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
 例外変数の値の設定は、<a href="#language-expression">式</a>を返します。
</p>
<p>
 例外変数の値の設定は、設定後の例外変数の値を返します。これは、<a href="#language-type-string">文字列型</a>です。
</p>
<p>
  <b>例外変数の値の設定のExample</b>
</p>
<p>
  例外変数の値の設定のExampleです。
</p>
<pre>
$@ = "Error";
</pre>

<h3 id="language-expression-get-field-class">クラス型のフィールドの値の取得</h3>
<p>
  クラス型のフィールドの値の取得は、次のように記述します。
</p>
<pre>
インボカント式->{Field Name}
</pre>
<p>
  インボカント式は、<a href="#language-type-class">クラス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-multi-numeric">複数数値型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a>になり、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの取得</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
</p>
<p>
  Field Nameが、存在しない場合は、コンパイル時エラーが発生します。
</p>
<p>
  クラス型のフィールドの値の取得は、オブジェクトに保存されているフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は、フィールドの型です。
</p>
<p>
  <b>クラス型のフィールドの値の取得のExample</b>
</p>
<p>
  クラス型のフィールドの値の取得のExampleです。
</p>
<pre>
my $point = Point->new;
my $x = $point->{x};
</pre>

<h3 id="language-expression-set-field-class">クラス型のフィールドの値の設定</h3>
<p>
  クラス型のフィールドの値の設定は、次のように記述します。
</p>
<pre>
インボカント式->{Field Name} = 右式
</pre>
<p>
  インボカント式は、<a href="#language-type-class">クラス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-multi-numeric">複数数値型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の設定</a>になり、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの設定</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
</p>
<p>
  Field Nameが、存在しない場合は、コンパイル時エラーが発生します。
</p>
<p>
  右式の型は、フィールドの型と同じでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  クラス型のフィールドの値の設定は、設定後のオブジェクトに保存されているフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は、フィールドの型です。
</p>
<p>
  右式が、オブジェクト型であった場合は、オブジェクトのリファレンスカウントが1増やされます。
</p>
<p>
  代入前に、すでにフィールドにオブジェクトが代入されていた場合は、そのオブジェクトのリファレンスカウントが1減らされます。
</p>
<p>
  <b>クラス型のフィールドの値の設定のExample</b>
</p>
<p>
  クラス型のフィールドの値の設定のExampleです。
</p>
<pre>
my $point = Point->new;
$point->{x} = 1;
</pre>

<h3 id="language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</h3>
<p>
  複数数値型のフィールドの値の取得は、次のように記述します。
</p>
<pre>
インボカント式->{Field Name}
</pre>
<p>
  インボカント式は、<a href="#language-type-class">複数数値型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a>になり、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの取得</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
</p>
<p>
  Field Nameが、存在しない場合は、コンパイル時エラーが発生します。
</p>
<p>
  複数数値型のフィールドの値の取得は、<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は、フィールドの型です。
</p>
<p>
  <b>複数数値型のフィールドの値の取得のExample</b>
</p>
<p>
  複数数値型のフィールドの値の取得のExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $re = $z->{re};
</pre>

<h3 id="language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</h3>
<p>
  複数数値型のフィールドの値の設定は、次のように記述します。
</p>
<pre>
インボカント式->{Field Name} = 右式
</pre>
<p>
  インボカント式は、<a href="#language-type-class">複数数値型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a>になり、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値であった場合は、<a href="#language-expression-set-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの設定</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
</p>
<p>
  Field Nameが、存在しない場合は、コンパイル時エラーが発生します。
</p>
<p>
  右式の型は、フィールドの型と同じでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  複数数値型のフィールドの値の設定は、設定後の<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は、フィールドの型です。
</p>
<p>
  <b>複数数値型のフィールドの値の設定のExample</b>
</p>
<p>
  複数数値型のフィールドの値の設定のExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
$z->{re} = 2.5;
</pre>

<h3 id="language-expression-get-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの値の取得</h3>
<p>
  デリファレンスによる複数数値型のフィールドの値の取得は、次のように記述します。
</p>
<pre>
インボカント式->{Field Name}
</pre>
<p>
  インボカント式は、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-get-field-class">クラス型のフィールドの値の取得</a>になり、<a href="#language-type-multi-numeric">複数数値型</a>の値であった場合は、<a href="#language-expression-get-field-multi-numeric">複数数値型のフィールドの値の取得</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
</p>
<p>
  Field Nameが、存在しない場合は、コンパイル時エラーが発生します。
</p>
<p>
  デリファレンスによる複数数値型のフィールドの値の取得は、<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は、フィールドの型です。
</p>
<p>
  <b>デリファレンスによる複数数値型のフィールドの値の取得のExample</b>
</p>
<p>
  デリファレンスによる複数数値型のフィールドの値の取得のExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
my $re = $z_ref->{re};
</pre>

<h3 id="language-expression-set-field-multi-numeric-deref">デリファレンスによる複数数値型のフィールドの値の設定</h3>
<p>
  デリファレンスによる複数数値型のフィールドの値の設定は、次のように記述します。
</p>
<pre>
インボカント式->{Field Name} = 右式
</pre>
<p>
  インボカント式は、<a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a>の値でなければなりません。インボカント式が、<a href="#language-type-class">クラス型</a>の値であった場合は、<a href="#language-expression-set-field-class">クラス型のフィールドの値の設定</a>になり、<a href="#language-type-multi-numeric">複数数値型</a>の値であった場合は、<a href="#language-expression-set-field-multi-numeric">複数数値型のフィールドの値の設定</a>になり、それ以外の場合は、コンパイル時エラーが発生します。
</p>
<p>
  Field Nameが、存在しない場合は、コンパイル時エラーが発生します。
</p>
<p>
  右式の型は、フィールドの型と同じでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  デリファレンスによる複数数値型のフィールドの値の設定は、設定後の<a href="#language-sub-stack">サブルーチンのコールスタック</a>に保存されている該当するフィールドの値を返します。これは<a href="#language-expression">式</a>です。
</p>
<p>
  返される値の型は、フィールドの型です。
</p>
<p>
  <b>デリファレンスによる複数数値型のフィールドの値の設定のExample</b>
</p>
<p>
  デリファレンスによる複数数値型のフィールドの値の設定のExampleです。
</p>
<pre>
my $z : SPVM::Complex_2d;
my $z_ref = \$z;
$z_ref->{re} = 2.5;
</pre>

<h3 id="language-expression-get-array-element">配列の要素の値の取得</h3>
<p>
  配列の要素の値を取得するには、次のように記述します。
</p>
<p>
配列式->[インデックス式]
</p>
<p>
  配列式は、<a href="#language-type-array">配列型</a>の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  インデックス式は、int型の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  配列の要素の値を取得は、指定したインデックスの要素の値を返します。これは、式です。
</p>
<p>
  実行時に、配列式の値が、未定義値である場合は、実行時例外が発生します。
</p>
<p>
  実行時に、インデックスの値が、0より小さい場合、あるいは、配列の最大のインデックスを超えている場合は、実行時例外が発生します。
</p>
<p>
  <b>配列の要素の値の取得のExample</b>
</p>
<p>
  配列の要素の値の取得のExampleです。
</p>
<pre>
my $nums = new int[3];
my $num = $nums->[1];

my $points = new Point[3];
my $point = $points->[1];

my $objects : oarray = $points;
my $object = (Point)$objects->[1];
</pre>

<h3 id="language-expression-set-array-element">配列の要素の値の設定</h3>
<p>
  配列の要素の値を設定するには、次のように記述します。
</p>
<p>
配列式->[インデックス式] = 右式
</p>
<p>
  配列式は、<a href="#language-type-array">配列型</a>の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  インデックス式は、int型の値でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  右式の型は、配列の要素の型と<a href="#language-type-compatible">型の互換性</a>がなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  配列の要素の値を設定は、設定後の値を返します。これは、式です。
</p>
<p>
  実行時に、配列式の値が、未定義値である場合は、実行時例外が発生します。
</p>
<p>
  実行時に、インデックスの値が、0より小さい場合、あるいは、配列の最大のインデックスを超えている場合は、実行時例外が発生します。
</p>
<p>
  右式が、オブジェクト型であった場合は、オブジェクトのリファレンスカウントが1増やされます。
</p>
<p>
  代入前に、すでに配列の要素にオブジェクトが代入されていた場合は、そのオブジェクトのリファレンスカウントが1減らされます。
</p>
<p>
  <b>配列の要素の値の設定のExample</b>
</p>
<p>
  配列の要素の値の設定のExampleです。
</p>
<pre>
my $nums = new int[3];
$nums->[1] = 3;

my $points = new Point[3];
$points->[1] = Point->new(1, 2);

my $objects : oarray = $points;
$objects->[2] = Point->new(3, 5);;
</pre>

<h3 id="language-expression-new-object">オブジェクトの生成</h3>
<p>
  オブジェクトを生成するには、newKeyword と以下の構文をを使用します。
</p>
<pre>
my $object = new Package Name;
</pre>
<p>
  指定されたパッケージは、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  フィールドは、すべて<a href="language-type-initial-value">型の初期値</a>で初期化されます。
</p>
<p>
  オブジェクトの生成は、<a href="#language-expression">式</a>を返します。
</p>
<p>
  生成直後のオブジェクトのリファレンスカウントは、0です。代入が実行されるタイミングで、リファレンスカウントが1増やされます。明示的な代入が行われない場合でも、一時変数が作成され、そこに代入されます。
</p>
<p>
  <b>オブジェクトの生成のExample</b>
</p>
<pre>
my $object = new Foo;
</pre>
<p>
  生成されたオブジェクトは内部的に次の情報を持っています。
</p>
<ul class="list">
  <li>リファレンスカウント</li>
  <li>ウィークリファレンスのバックリファレンス</li>
  <li>基本型のID</li>
  <li>型の次元(常に0)</li>
</ul>

<h3 id="language-expression-new-array">配列の生成</h3>
<p>
  配列を作成するには、newKeyword と以下の構文をを使用します。
</p>
<pre>
my $object = new 型[要素数式];
</pre>
<p>
  型には、<a href="#language-type-numeric">数値型</a>、<a href="#language-type-object">オブジェクト型</a>、<a href="#language-type-multi-numeric">複数数値型</a>が指定できます。それ以外の型を指定した場合は、コンパイル時エラーが発生します。
</p>
<p>
  要素数式は、int型以下の<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  要素数式に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  要素数式で指定された長さの配列が生成されます。
</p>
<p>
  配列の要素は、すべて<a href="language-type-initial-value">型の初期値</a>で初期化されます。
</p>
<p>
  配列において、要素は、メモリ上に連続していることが保証されます。
</p>
<p>
  配列の生成は、<a href="#language-expression">式</a>を返します。
</p>
<p>
  配列は、<a href="#language-type-object">オブジェクト型</a>です。
</p>
<p>
  <b>配列の生成のExample</b>
</p>
<pre>
my $nums = new int[3];
my $objects = new Foo[3];
my $objects = new object[3];
my $values = new Complex_2d[3]
</pre>
<p>
  生成された配列は、内部的に次の情報を持っています。
</p>
<ul class="list">
  <li>リファレンスカウント</li>
  <li>基本型のID</li>
  <li>型の次元(1以上の値)</li>
  <li>配列の長さ</li>
</ul>
<p>
  多次元配列は、上記の構文を使用して、作成できます。要素は、<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
</p>
<pre>
my $nums = new int[][3];
my $nums = new int[][][3];
</pre>
<p>
  多次元配列の次元数の最大は、255です。
</p>

<h3 id="language-expression-array-init">配列の初期化</h3>
<p>
  SPVMには、配列の生成を簡単にするための配列の初期化の構文があります。式はなくてもかまいません。
</p>
<pre>
[]
[式1, 式2, 式3]
</pre>
<p>
  配列の初期化は、式の要素数の長さを持った配列を返します。
</p>
<p>
  配列の型は、式1の型を配列型にしたものです。要素が指定されない場合は、<a href="#language-type-any-object">汎用オブジェクト型</a>を配列型にしたものになります。
</p>
<p>
  式2以降が、<a href="#language-type-compatible">型の互換性</a>を満たさない場合は、コンパイルエラーになります。
</p>

<h3 id="language-expression-callsub">サブルーチンの呼び出し</h3>
<p>
  <a href="#language-sub-definition">サブルーチンの定義</a>によって定義されたサブルーチンは呼び出すことができます。呼び出しには、2種類あって、<b>関数の呼び出し</b>と<b>メソッドの呼び出し</b>があります。
</p>

<h4 id="language-expression-callsub-func">関数の呼び出し</h4>
<p>
  関数の呼び出しとは、<a href="#language-sub-method">メソッド</a>ではないサブルーチンを呼び出す方法のことをいいます。メソッドかどうかの判断は、<a href="#language-sub-definition">サブルーチンの定義</a>において、第一引数に<a href="#language-type-self">self型</a>の引数が指定されていた場合が、メソッドになります。
</p>
<p>
  関数の呼び出しは以下の方法で行うことができます。引数は、なくても構いません。最大で255個の引数を指定できます。
</p>
<pre>
Package Name->Subroutine Name(引数1, 引数2, 引数3, ..., 引数n);
</pre>
<p>
  Perlにおいてクラスメソッドの呼び出しと呼ばれているものが、SPVMでは、関数の呼び出しと呼ばれていることに注意してください。
</p>
<p>
  関数の呼び出しでは、Package Nameを省略することもできます。
</p>
<pre>
Subroutine Name(引数1, 引数2, 引数3, ..., 引数n);
</pre>
<p>
  どのパッケージのサブルーチンが呼び出されるかは、以下の順番によって決まります。
</p>
<p>
  1. 現在のパッケージで定義されているサブルーチン、または現在のパッケージにインポートされたサブルーチン
</p>
<p>
  2. 標準関数 - COREパッケージで定義されているサブルーチン
</p>

<p>
  関数の呼び出しは、引数を受け取ります。引数の個数が、サブルーチンの定義で定義されている引数の個数と一致しない場合は、コンパイル時エラーが発生します。それぞれの引数の型が、サブルーチン定義で定義されている引数の型と<a href="#language-type-compatible">型の互換性</a>がない場合は、コンパイル時エラーが発生します。
</p>
<p>
  関数の呼び出しは、戻り値がvoid型以外の場合は、戻り値を返します。
</p>
<p>
  関数の呼び出しは、<a href="#language-expression">式</a>です。
<p>
<p>
  <b>サブルーチン呼び出しのExample</b>
</p>
<p>
  サブルーチン呼び出しのExampleです。
</p>
<pre>
my $ret = Foo->bar(1, 2, 3);
my $ret = bar(1, 2, 3);
</pre>

<h4 id="language-expression-callsub-method">メソッドの呼び出し</h4>
<p>
  メソッドの呼び出しとは、<a href="#language-sub-method">メソッド</a>であるサブルーチンを呼び出す方法のことをいいます。メソッドかどうかの判断は、<a href="#language-sub-definition">サブルーチンの定義</a>において、第一引数に<a href="#language-type-self">self型</a>の引数が指定されていた場合が、メソッドになります。
</p>
<p>
  メソッドの呼び出しは、<a href="#language-expression-new-object">オブジェクトの生成</a>によって生成されたオブジェクトを使って以下の構文で行うことができます。
</p>
<pre>
オブジェクト->Subroutine Name(引数1, 引数2, 引数3, ..., 引数n);
</pre>
<p>
  メソッドの呼び出しは、引数を受け取ります。引数の個数が、サブルーチンの定義で定義されている引数の個数と一致しない場合は、コンパイル時エラーが発生します。それぞれの引数の型が、サブルーチン定義で定義されている引数の型と<a href="#language-type-compatible">型の互換性</a>がない場合は、コンパイル時エラーが発生します。
</p>
<p>
  メソッドの呼び出しは、戻り値がvoid型以外の場合は、戻り値を返します。
</p>
<p>
  メソッドの呼び出しは、<a href="#language-expression">式</a>です。
<p>
<p>
  <b>メソッドの呼び出しのExample</b>
</p>
<p>
  メソッドの呼び出しのExampleです。
</p>
<pre>
my $point = new Point;
$point->set_x(3);
</pre>
<p>
  <a href="#language-sub-new-callback-object">コールバックオブジェクトの生成</a>で作成されたオブジェクトは、通常のオブジェクトなのでメソッドを呼び出すことができます。
</p>
<pre>
オブジェクト->(引数1, 引数2, 引数3, ..., 引数n);
</pre>

<p>
  <b>コールバックオブジェクトの生成で生成されたオブジェクトからメソッドを呼び出すExample</b>
</p>
<p>
  コールバックオブジェクトの生成で生成されたオブジェクトからメソッドを呼び出すExampleです。
</p>
<pre>
my $cb_obj = sub : int ($self: self, $num1 : int, $num2 : int) {
return $num1 + $num2;
};

my $ret = $cb_obj->(1, 2);
</pre>

<h3 id="language-operator-deref-get">デリファレンスによる値の取得</h3>
<p>
  デリファレンスによる値の取得とは、リファレンスから実際の値を取得するための操作のことです。C言語の関節Operator "*"を実現するために設計されました。
</p>
<pre>
$変数
</pre>
<p>
  変数の型は、リファレンス型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  デリファレンスによる値の取得は、<a href="#language-expression">式</a>を返します。
</p>
<pre>
  <b>デリファレンスによる値の取得のExample</b>
</pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
my $num_deref : int = $$num_ref;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
my $z_deref : SPVM::Complex_2d = $$z_ref;
</pre>

<h3 id="language-operator-deref-set">デリファレンスによる値の設定</h3>
<p>
  デリファレンスによる値の設定とは、リファレンスから実際の値を設定するための操作のことです。C言語の関節Operator "*"を実現するために設計されました。
</p>
<pre>
$変数 = 式
</pre>
<p>
  変数の型は、リファレンス型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  式の型は、デリファレンスされた場合の変数の型に一致していなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  デリファレンスによる値の設定は、設定された値を返します。これは<a href="#language-expression">式</a>です。
</p>
<pre>
  <b>デリファレンスによる値の設定のExample</b>
</pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;
$$num_ref = 1;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;

my $z2 : SPVM::Complex_2d;

$$z_ref = $z2;
</pre>

<h3 id="language-expression-current-package">現在のPackage Nameの取得</h3>
<p>
  現在のPackage Nameの取得を行う"__PACKAGE__"Keyword を使用します。
</p>
<pre>
__PACKAGE__
</pre>
<p>
  現在のPackage Nameの取得は<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>現在のPackage Nameの取得のExample</b>
</p>
<pre>
package Foo::Bar {
sub baz : void () {
# Foo::Bar
my $package_name == __PACKAGE__;
}
}
</pre>
<h3 id="language-expression-current-package">現在のファイル名の取得</h3>
<p>
  現在のファイル名の取得を行う"__FILE__"Keyword を使用します。
</p>
<pre>
__FILE__
</pre>
<p>
  現在のファイル名の取得は<a href="#language-expression">式</a>を返します。
</p>
<p>
  現在のファイル名とは、モジュールの読み込みパスを基準とした、ファイルの相対パスのことをいいます。たとえば、ファイルの読み込みパスが"/mypath"でモジュール名が"Foo::Bar"であった場合は、絶対パスは"/mypath/Foo/Bar.spvm"で、相対パスは"Foo/Bar.spvm"です。相対パスである"Foo/Bar.spvm"が、現在のファイル名になります。
</p>
<p>
  <b>現在のファイル名の取得のExample</b>
</p>
<pre>
# Foo/Bar.spvm
package Foo::Bar {
sub baz : void () {
# Foo/Bar.spvm
my $file_name == __FILE__;
}
}
package Foo::Bar2 {
sub baz : void () {
# Foo/Bar.spvm
my $file_name == __FILE__;
}
}
</pre>
<h3 id="language-expression-current-package">現在の行番号の取得</h3>
<p>
  現在の行番号の取得を行う"__LINE__"Keyword を使用します。
</p>
<pre>
__LINE__
</pre>
<p>
  現在の行番号の取得は<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>現在の行番号の取得のExample</b>
</p>
<pre>
package Foo::Bar {
sub baz : void () {
# 4
my $line == __LINE__;
}
}
</pre>

<h2 id="language-expression-release-object">オブジェクトの解放</h2>
<p>
  オブジェクトは、リファレンスカウントが0になるとメモリから解放されます。
</p>
<p>
  オブジェクトが、オブジェクト型の値を要素として持つ配列だった場合は、オブジェクトの解放の前に、未定義値ではないすべての配列の要素のリファレンスカウントが1減らされます
</p>
<p>
  オブジェクトが、クラス型で、オブジェクト型のフィールドを持つときは、オブジェクトの解放の前に、未定義値ではないすべてのオブジェクト型のフィールドが所有するオブジェクトのリファレンスカウントが1減らされます。フィールドに保存されているオブジェクトにウィークリファレンスが設定されていた場合は、リファレンスカウントが1減らされる前に、ウィークリファレンスが解除されます。
</p>
<p>
  オブジェクトがウィークリファレンスのバックリファレンスを持つときは、バックリファレンスとして登録されているフィールドすべてに、未定義値を代入し、バックリファレンスをすべて削除します。
</p>
<p>
  上記の処理は、再帰的に行われます。
</p>

<h2 id="language-literal">Literal </h2>
<ul class="list">
  <li><a href="#language-literal-integer">Integer Literal  </a></li>
  <li><a href="#language-literal-floating-point">浮動小数点Literal </a></li>
  <li><a href="#language-literal-character">文字Literal </a></li>
  <li><a href="#language-literal-string">文字列Literal </a></li>
  <li><a href="#language-literal-string-variable-expansion">変数展開</a></li>
</ul>
<h3 id="language-literal-integer">Integer Literal  </h2>
<p>
  <b>10進数表現</b>
</p>
<p>
  Integer Literal  の数値部は"0～9"の1つ以上の連続した文字で表現されます。
</p>
<p>
  先頭に"+"あるいは"-"の符号をつけることができます。
</p>
<p>
  Integer Literal  の型は、デフォルトでは"int型"になります。
</p>
<p>
  Integer Literal  がint型で表現できる数値の範囲を超えている場合は、コンパイル時エラーが発生します。
</p>
<p>
  末尾に"L"あるいは"l"のサフィックスをつけることで"long型"のInteger Literal  を表現できます。
</p>
<p>
  long型のInteger Literal  の場合は、long型で表現できる数値の範囲を超えている場合は、コンパイル時エラーが発生します。
</p>
<p>
  Separatorとして"_"を使用することができます。Separatorは意味を持ちません。
</p>
<p>
  Invalid Integer Literal  の表現はコンパイル時エラーが発生します。
</p>
<p>
  Integer Literal  がbyte型の変数に代入される場合、あるいはbyte型のサブルーチンの引数として渡される場合で、byte型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>によって、byte型に自動的に変換されます。範囲を超えている場合は、コンパイル時エラーとなります。
</p>
<p>
  Integer Literal  がshort型の変数に代入される場合、あるいはshort型のサブルーチンの引数として渡される場合で、short型で表現できる数値の範囲を超えていない場合は、<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>によって、short型に自動的に変換されます。範囲を超えている場合は、コンパイル時エラーとなります。
</p>
<p>
  Integer Literal  のExampleです。
</p>
<pre>
123
+123
-123
123L
123l
123_456_789
-123_456_789L
</pre>
<p>
  <b>16進数表現</b>
</p>
<p>
  Integer Literal  の数値部は<b>16進数</b>を使って表現することができます。
</p>
<p>
 数値部を16進数を使って表現するときは"0x"から始めます。
</p>
<p>
  その後ろに"0～9""a～f""A～F"のひとつ以上の連続した文字が続きます。
</p>
<p>
  Invalid 16進数表現は、コンパイル時エラーが発生します。
</p>
<p>
  Integer Literal  を16進数で表現したExampleです。
</p>
<pre>
0x3b4f
-0x3F1A
0xDeL
0xFFFFFFFF_FFFFFFFF
</pre>

<p>
  <b>8進数表現</b>
</p>
<p>
  Integer Literal  の数値部は<b>8進数</b>を使って表現することができます。
</p>
<p>
 数値部を8進数を使って表現するときは"0"から始めます。
</p>
<p>
  その後ろに"0～7"のひとつ以上の連続した文字が続きます。
</p>
<p>
  Invalid 8進数表現は、コンパイル時エラーが発生します。
</p>
<p>
  Integer Literal  を8進数で表現したExampleです。
</p>
<pre>
0755
-0644
0666L
0655_755
</pre>
<p>
  <b>2進数表現</b>
</p>
<p>
  Integer Literal  の数値部は<b>2進数</b>を使って表現することができます。
</p>
<p>
 数値部を2進数を使って表現するときは"0b"から始めます。
</p>
<p>
  その後ろに"0"か"1"のひとつ以上の連続した文字が続きます。
</p>
<p>
  Invalid 2進数表現は、コンパイル時エラーが発生します。
</p>
<p>
  Integer Literal  を2進数で表現したExampleです。
</p>
<pre>
0b0101
-0b1010
0b110000L
0b10101010_10101010
</pre>


<h3 id="language-literal-floating-point">浮動小数点Literal </h2>
<p>
  浮動小数点Literal は"符号部""数値部""指数部""サフィックス"から構成されます。
<p>
<p>
  浮動小数点Literal には"10進数浮動小数点Literal "と"16進数浮動小数点Literal "があります。
</p>
<p>
  "符号部"は"+"か"-"で表現されます。"符号部"の存在は、任意です。"符号部"が存在する場合は、先頭にある必要があります。
</p>
<p>
  "10進数浮動小数点Literal "は、数値部が"一桁以上の10進数字"で始まる必要があります。
</p>
<p>
  "10進数字"とは"0～9"のことです。
</p>
<p>
  "10進数浮動小数点Literal "は、数値部に"小数点"が含まれているか、含まれていない場合は"指数部"あるいは"サフィックス"が必要です。
</p>
<p>
  "小数点"とは"."のことです。
</p>
<p>
  "16進数浮動小数点Literal "は、数値部が"0x"あるいは"0X"で始まり、その後ろに"一桁以上の16進数字"が続く必要があります。
</p>
<p>
  16進数字とは"0～9""a～f""A～F"のことです。
</p>
<p>
  "16進数浮動小数点Literal "は、"数値部"に"小数点"を含むことができます。
</p>
<p>
  "数値部"はアンダーライン"_"を含むことができます。これは単なるSeparatorで、無視されます。
</p>
<p>
  "16進数浮動小数点Literal "は、"指数部"が必要です。
</p>
<p>
  "指数部"は"指数表現"と"符号付10進整数"で構成されます。
</p>
<p>
  "指数表現"は"10進数浮動小数点Literal "の場合は"e"あるいは"E"、"16進数浮動小数点Literal "の場合は"p"あるいは"P"になります。
</p>
<p>
  "指数部"の意味は"10進数浮動小数点Literal "の場合は、10進数による桁移動、"16進数浮動小数点Literal "の場合は、2進数による桁移動になります。
</p>
<p>
  末尾に"f"あるいは"F"のサフィックスをつけると、浮動小数点Literal の型は"float型"になります。
</p>
<p>
  末尾に"d"あるいは"D"のサフィックスをつけると、浮動小数点Literal の型は"double型"になります。
</p>
<p>
  サフィックスが省略された場合は、浮動小数点Literal の型は"double型"になります。
</p>
<p>
  浮動小数点Literal が"float型"の場合はC標準の"strtof関数"を使って、文字列からfloat型への変換が行われます。変換が失敗した場合は、コンパイル時エラーが発生します。
</p>
<p>
  浮動小数点Literal が"double型"の場合はC標準の"strtod関数"を使って、文字列からdouble型への変換が行われます。変換が失敗した場合は、コンパイル時エラーが発生します。
</p>
<p>
  無限大を表現する浮動小数点Literal はありません。標準関数である"<a href="#stdfunc-INFINITY">INFINITY関数</a>""<a href="#stdfunc-INFINITYF">INFINITYF関数</a>"を使用してください。
</p>
<p>
  非値を表現する浮動小数点Literal はありません。標準関数である"<a href="#stdfunc-NAN">NAN関数</a>""<a href="#stdfunc-NANF">NANF関数</a>"を使用してください。
</p>
<p>
  浮動小数点Literal のExampleです
</p>
<pre>
1.32
-1.32
1.32f
1.32F
1.32e3
1.32e-3
1.32E+3
1.32E-3
0x3d3d.edp0
0x3d3d.edp3
0x3d3d.edP3
0x3d3d.edP-3f
</pre>

<h3 id="language-literal-character">文字Literal </h2>
<p>
  文字Literal は、シングルクォート"'"で囲まれます。
</p>
<p>
  文字Literal の内容は"ひとつのAsciiの印字可能文字"あるいは"ひとつのエスケープ文字"です。
</p>
<p>
  文字Literal の型は"byte型"になります。
</p>
<p>
  Invalid 文字Literal の場合は、コンパイル時エラーが発生します。
</p>
<p>
  <b>エスケープ文字</b>
</p>
<table class="toc">
  <tr>
    <th>
      エスケープ文字
    </th>
    <th>
      説明
    </th>
  </tr>
  <tr>
    <td>
      <b>\0</b>
    </td>
    <td>
      Asciiコードの0"NUL"
    </td>
  </tr>
  <tr>
    <td>
      <b>\a</b>
    </td>
    <td>
      Asciiコードの7"BEL"
    </td>
  </tr>
  <tr>
    <td>
      <b>\b</b>
    </td>
    <td>
      Asciiコードの8"BS"
    </td>
  </tr>
  <tr>
    <td>
      <b>\t</b>
    </td>
    <td>
      Asciiコードの9"HT"
    </td>
  </tr>
  <tr>
    <td>
      <b>\n</b>
    </td>
    <td>
      Asciiコードの10"LF"
    </td>
  </tr>
  <tr>
    <td>
      <b>\f</b>
    </td>
    <td>
      Asciiコードの12"FF"
    </td>
  </tr>
  <tr>
    <td>
      <b>\r</b>
    </td>
    <td>
      Asciiコードの13"CR"
    </td>
  </tr>
  <tr>
    <td>
      <b>\"</b>
    </td>
    <td>
      Asciiコードの34"""
    </td>
  </tr>
  <tr>
    <td>
      <b>\'</b>
    </td>
    <td>
      Asciiコードの39"'"
    </td>
  </tr>
  <tr>
    <td>
      <b>\\</b>
    </td>
    <td>
      Asciiコードの92"\"
    </td>
  </tr>
  <tr>
    <td>
      <b>\xの後ろに二桁の16進数</b>
    </td>
    <td>
      直接Asciiコードを指定します。16進数は"0～9""a～f""A～F"で表現します。
    </td>
  </tr>
</table>

<p>
  <b>文字Literal のExample</b>
</p>
<p>
  文字Literal のExampleです。
</p>
<pre>
# 文字Literal 
'a'
'x'

# エスケープ文字を使った文字Literal 
'\a'
'\b'
'\t'
'\n'
'\f'
'\r'
'\"'
'\''
'\\'
'\x0D'
'\x0A'
</pre>

<h3 id="language-literal-string">文字列Literal </h2>
<p>
  文字列Literal は、ダブルクォート"""で囲まれます。
</p>
<p>
  文字列Literal の内容は"0個以上のAsciiの印字可能文字あるいはエスケープ文字"です。
</p>
<p>
  文字列Literal の型は"string型"になります。
</p>
<p>
  Invalid 文字列Literal の場合は、コンパイル時エラーが発生します。
</p>
<p>
  <b>エスケープ文字</b>
</p>
<table class="toc">
  <tr>
    <th>
      エスケープ文字
    </th>
    <th>
      説明
    </th>
  </tr>
  <tr>
    <td>
      <b>\0</b>
    </td>
    <td>
      Asciiコードの0"NUL"
    </td>
  </tr>
  <tr>
    <td>
      <b>\a</b>
    </td>
    <td>
      Asciiコードの7"BEL"
    </td>
  </tr>
  <tr>
    <td>
      <b>\b</b>
    </td>
    <td>
      Asciiコードの8"BS"
    </td>
  </tr>
  <tr>
    <td>
      <b>\t</b>
    </td>
    <td>
      Asciiコードの9"HT"
    </td>
  </tr>
  <tr>
    <td>
      <b>\n</b>
    </td>
    <td>
      Asciiコードの10"LF"
    </td>
  </tr>
  <tr>
    <td>
      <b>\f</b>
    </td>
    <td>
      Asciiコードの12"FF"
    </td>
  </tr>
  <tr>
    <td>
      <b>\r</b>
    </td>
    <td>
      Asciiコードの13"CR"
    </td>
  </tr>
  <tr>
    <td>
      <b>\"</b>
    </td>
    <td>
      Asciiコードの34"""
    </td>
  </tr>
  <tr>
    <td>
      <b>\'</b>
    </td>
    <td>
      Asciiコードの39"'"
    </td>
  </tr>
  <tr>
    <td>
      <b>\\</b>
    </td>
    <td>
      Asciiコードの92"\"
    </td>
  </tr>
  <tr>
    <td>
      <b>\xの後ろに二桁の16進数</b>
    </td>
    <td>
      直接Asciiコードを指定します。16進数は"0～9""a～f""A～F"で表現します。
    </td>
  </tr>
  <tr>
    <td>
      <b>\N{}の中の複数桁の16進数</b>
    </td>
    <td>
      Unicodeのコードポイントを16進数で指定します。UTF-8に変換されます。16進数は"0～9""a～f""A～F"で表現します。
    </td>
  </tr>
  <tr>
    <td>
      <b>\s</b>
    </td>
    <td>
      Asciiコードの92、115の並び"\s"
    </td>
  </tr>
  <tr>
    <td>
      <b>\S</b>
    </td>
    <td>
      Asciiコードの92、83の並び"\S"
    </td>
  </tr>
  <tr>
    <td>
      <b>\d</b>
    </td>
    <td>
      Asciiコードの92、100の並び"\d"
    </td>
  </tr>
  <tr>
    <td>
      <b>\D</b>
    </td>
    <td>
      Asciiコードの92、68の並び"\D"
    </td>
  </tr>
  <tr>
    <td>
      <b>\w</b>
    </td>
    <td>
      Asciiコードの92、119の並び"\w"
    </td>
  </tr>
  <tr>
    <td>
      <b>\W</b>
    </td>
    <td>
      Asciiコードの92、87の並び"\W"
    </td>
  </tr>
  <tr>
    <td>
      <b>\の後ろに"a～z""A～Z""0-9"""""'""\""$"以外のAsciiコードがきた場合</b>
    </td>
    <td>
      Asciiコードの92、アスキーコードで表現される文字の並び。たとえば"\-"の場合は"\-"。
    </td>
  </tr>
</table>
<p>
  Unicodeのコードポイントを指定するエスケープ文字以外は、<a href="#language-literal-character">文字Literal </a>のエスケープ文字と共通です。
</p>
<p>
  <b>文字列Literal のExample</b>
</p>
<p>
  文字列Literal のExampleです。
</p>
<pre>
# 文字列Literal 
"abc"
"あいう"

# エスケープ文字を使った文字列Literal 
"abc\tdef\n"
"\x0D\x0A"
"\N{U+3042}\N{U+3044}\N{U+3046}"
</pre>

<h3 id="language-literal-string-variable-expansion">変数展開</h2>
<p>
  文字列Literal 中のレキシカル変数、パッケージ変数、デリファレンス、フィールドアクセス、定数の添え字の配列アクセス、例外変数の場合は、変数展開が行われます。
</p>
<pre>
"AAA $foo BBB"
"AAA $FOO BBB"
"AAA $$foo BBB"
"AAA $foo->{x} BBB"
"AAA $foo->[3] BBB"
"AAA $foo->{x}[3] BBB"
"AAA $@ BBB"
</pre>
<p>
  上記は、以下のように展開されます。
</p>
<pre>
"AAA" . $foo . "BBB"
"AAA" . $FOO . "BBB"
"AAA" . $$foo . "BBB"
"AAA" . $foo->{x} . "BBB"
"AAA" . $foo->[3] . "BBB"
"AAA" . $foo->{x}[3] . "BBB"
"AAA" . $@ . "BBB"
</pre>

<p>
  変数名の終わりを表すために"{"と"}"で変数名を囲むことができます。
</p>
<pre>
"AAA ${foo}_ccc BBB"
</pre>
<p>
  上記は、以下のように展開されます。
</p>
<pre>
"AAA " . ${foo} . "_ccc BBB"
</pre>
<p>
  "{"と"}"の囲みがない場合は、変数名としてValid 文字列までを変数として解釈します。デリファレンスの場合も同じです。
</p>
<p>
  変数名の後ろに"->"が続いた場合は、フィールドアクセス、あるいは、配列アクセスと解釈します。
</p>
<p>
  1. その後ろに、続く文字が"a-z""A-Z""0-9""_""{""["であった場合は、解釈を進めます。
</p>
<p>
  2. "1."の後ろに続く文字が"}""]"であった場合は、その次の文字が"->""{""["であった場合は、解釈を進め、1に戻ります。そうでない場合は、解釈を止めます。
</p>
<p>
  末尾の$は変数展開の開始としては扱われず"$"として扱われます。
</p>
<pre>
"AAA$"
</pre>

<h2 id="language-string">文字列</h2>
<p>
  SPVMの文字列のデータ表現は、byte型の配列です。特別な内部表現を持たない、単なるバイト列です。
</p>
<pre>
my $string = new byte[3];
$string->[0] = 'a';
$string->[1] = 'b';
$string->[2] = 'c';
</pre>
<p>
  byte型の配列は、<a href="#language-type-string">文字列型</a>に代入できます。文字列型は、コンパイル時には要素を変更できない型ですが、実行時はbyte型の配列になります。
</p>
<pre>
my $string_const : string = $string;
</pre>
<p>
  <a href="#language-literal-string">文字列Literal </a>を代入することによって、文字列を作成できます。文字列Literal を元にしたstring型の新しい文字列を返します。
</p>
<pre>
my $string_const = "abc";
</pre>
<p>
  byte[]はC言語の"char*"、文字列型はC言語の"const char*"に該当するように設計されています。
</p>

<h2 id="language-undef">未定義値</h2>
<p>
  未定義は"undef"で表現されます。
</p>
<pre>
undef
</pre>

<h2 id="language-fat-comma">ファットカンマ</h2>
<p>
  ファットカンマは"=>"で表現されます。
</p>
<pre>
=>
</pre>
<p>
  ファットカンマは","のエイリアスです。","が使える場所ではいつでも代わりに、ファットカンマが使えます。
</p>
<pre>
# カンマ
["a", "b", "c", "d"]

# カンマの代わりにファットカンマを使う
["a" => "b", "c" => "d"]
</pre>
<p>
  ファットカンマの左型に置かれたPackage Variable Name、Lexical Variable Name以外のIdentifierは、<a href="#language-literal-string">文字列Literal </a>として扱われます。
</p>

<pre>
# カンマの代わりにファットカンマを使う
["a" => "b", "c" => "d"]

# ファットカンマの左型に置かれたIdentifierは、文字列Literal になる。上記と同じ意味
[a => "b", c => "d"]
</pre>

<p>
  未定義値は、任意のオブジェクト型の変数に代入することができます。
</p>
<p>
  未定義値はオブジェクト型の値と"==""!="Operator を使用して、比較することができます。未定義値は、生成されたオブジェクトと等しくない事が保証されます。
</p>
<p>
  未定義は条件部で使われた場合は、偽になります。
</p>
<p>
  未定義値は、エクステンションにおいてC言語の値として利用された場合は、0と等しくなることが保証されます。
</p>
<h2 id="language-operator">Operator </h2>
<ul class="list">
  <li><a href="#language-operator-summary">Operator の概要</a></li>
  <li><a href="#language-operator-unary">単項Operator </a></li>
  <li><a href="#language-operator-binary">二項Operator </a></li>
  <li><a href="#language-operator-sequential">順次Operator </a></li>
  <li><a href="#language-operator-arithmetic">算術Operator </a></li>
  <li><a href="#language-operator-unary-plus">単項プラスOperator </a></li>
  <li><a href="#language-operator-unary-minus">単項マイナスOperator </a></li>
  <li><a href="#language-operator-add">加算Operator </a></li>
  <li><a href="#language-operator-subtract">減算Operator </a></li>
  <li><a href="#language-operator-multiply">乗算Operator </a></li>
  <li><a href="#language-operator-divide">除算Operator </a></li>
  <li><a href="#language-operator-remainder">剰余Operator </a></li>
  <li><a href="#language-operator-inc">インクリメントOperator </a></li>
  <li><a href="#language-operator-dec">デクリメントOperator </a></li>
  <li><a href="#language-operator-bit">ビットOperator </a></li>
  <li><a href="#language-operator-bit-and">ビットANDOperator </a></li>
  <li><a href="#language-operator-bit-or">ビットOROperator </a></li>
  <li><a href="#language-operator-bit-not">ビット否定Operator </a></li>
  <li><a href="#language-operator-shift">シフトOperator </a></li>
  <li><a href="#language-operator-left-shift">左シフトOperator </a></li>
  <li><a href="#language-operator-arithmetic-right-shift">算術右シフトOperator </a></li>
  <li><a href="#language-operator-logical-right-shift">論理右シフトOperator </a></li>
  <li><a href="#language-operator-comparison">比較Operator </a></li>
  <li><a href="#language-operator-comparison-numeric">数値比較Operator </a></li>
  <li><a href="#language-operator-comparison-string">文字列比較Operator </a></li>
  <li><a href="#language-operator-isa">isaOperator </a></li>
  <li><a href="#language-operator-logical">論理Operator </a></li>
  <li><a href="#language-operator-logical-and">論理ANDOperator </a></li>
  <li><a href="#language-operator-logical-or">論理OROperator </a></li>
  <li><a href="#language-operator-logical-not">論理NOTOperator </a></li>
  <li><a href="#language-operator-concat">文字列連結Operator </a></li>
  <li><a href="#language-operator-assign">代入Operator </a></li>
  <li><a href="#language-operator-assign-special">特殊代入Operator </a></li>
  <li><a href="#language-operator-ref">リファレンスOperator </a></li>
  <li><a href="#language-operator-array-length">配列長Operator </a></li>
  <li><a href="#language-operator-string-length">文字列長Operator </a></li>
  <li><a href="#language-operator-scalar">スカラOperator </a></li>
  <li><a href="#language-operator-isweak">isweakOperator </a></li>
</ul>

<h3 id="language-operator-summary">Operator の概要</h3>
<p>
  Operator は、<a href="#language-operator-unary">単項Operator </a>、<a href="#language-operator-binary">二項Operator </a>、<a href="#language-operator-inc">インクリメントOperator </a>、<a href="#language-operator-dec">デクリメントOperator </a>、<a href="#language-operator-comparison">比較Operator </a>、<a href="#language-operator-logical">論理Operator </a>、<a href="#language-operator-assign">代入Operator </a>からなります。
</p>

<h3 id="language-operator-unary">単項Operator </h3>
<p>
  単項Operator とは、<a href="#language-expresssion">式</a>の前に置かれるOperator のことをいいます。
</p>
<pre>
単項Operator  式
</pre>
<p>
  単項Operator には、<a href="#language-operator-unary-plus">単項プラスOperator </a>、<a href="#language-operator-unary-minus">単項マイナスOperator </a>、<a href="#language-operator-bit-not">ビット否定Operator </a>、<a href="#language-operator-logical-not">論理否定Operator </a>、<a href="#language-operator-array-legnth">配列長Operator </a>、<a href="#language-operator-string-legnth">文字列長Operator </a>があります。
</p>
<p>
  インクリメントOperator とデクリメントOperator は、単項Operator には含まれません。
</p>

<h3 id="language-operator-binary">二項Operator </h3>
<p>
  二項Operator とは、左式と右式の間に置かれるOperator のことをいいます。項については、<a href="#language-expresssion">式</a>を参考にしてください。
</p>
<pre>
左式 二項Operator  右式
</pre>

<p>
  二項Operator には、<a href="#language-operator-add">加算Operator </a>、<a href="#language-operator-subtract">減算Operator </a>、<a href="#language-operator-multiply">乗算Operator </a>、<a href="#language-operator-divide">除算Operator </a>、<a href="#language-operator-remainder">剰余Operator </a>、<a href="#language-operator-bit-and">ビットANDOperator </a>、<a href="#language-operator-bit-or">ビットOROperator </a>、<a href="#language-operator-logical-and">論理ANDOperator </a>、<a href="#language-operator-logical-or">論理OROperator </a>、<a href="#language-operator-shift">シフトOperator </a>、<a href="#language-operator-concat">文字列連結Operator </a>があります。
</p>

<h3 id="language-operator-sequential">順次Operator </h3>
<p>
  順次Operator とは、複数の<a href="#language-expression">式</a>を並べて記述でき、最後の値を返すOperator のことです。
</p>
<pre>
(式1, 式2, 式3)
</pre>
<p>
  式は左から実行されます。最後の値が返されます。
<p>
<p>
  順次Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>順次Operator のExample</b>
</p>
<p>
  順次Operator のExampleです。
</p>
<pre>
# $fooには3が代入される。
my $foo = (1, 2, 3);

# $xは3、$retは5になる
my $x = 1;
my $y = 2;
my $ret = ($x += 2, $x + $y);
</pre>

<li><a href="#language-operator-sequential">順次Operator </a></li>

<h3 id="language-operator-arithmetic">算術Operator </h3>
<p>
  算術Operator は、算術を行うOperator のことで、<a href="#language-operator-add">加算Operator </a>、<a href="#language-operator-subtract">減算Operator </a>、<a href="#language-operator-multiply">乗算Operator </a>、<a href="#language-operator-divide">除算Operator </a>、<a href="#language-operator-remainder">剰余Operator </a>、<a href="#language-operator-unary-plus">単項プラスOperator </a>、<a href="#language-operator-unary-minus">単項マイナスOperator </a>、<a href="#language-operator-inc">インクリメントOperator </a>、<a href="#language-operator-dec">デクリメントOperator </a>からなります。
</p>

<h3 id="language-operator-unary-plus">単項プラスOperator </h3>
<p>
  単項プラスOperator は"+"で表現される<a href="#language-operator-unary">単項Operator </a>です。
</p>
<pre>
+式
</pre>
<p>
  式は<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  <a href="#language-expression">式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、単項プラスOperator は、与えられた値をコピーして返します。
</p>
<p>
  単項プラスOperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  単項プラスOperator の戻り値の型は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
</p>
<p>
  単項プラスOperator は例外を発生させません。
</p>
<p>
  <b>単項プラスOperator のExample</b>
</p>
<pre>
my $num = +10;
</pre>
<h3 id="language-operator-unary-minus">単項マイナスOperator </h3>
<p>
  単項マイナスOperator は"-"で表現される<a href="#language-operator-unary">単項Operator </a>です。
</p>
<pre>
-式
</pre>
<p>
  式は<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  <a href="#language-expression">式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、単項マイナスOperator は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
</p>
<pre>
-x
</pre>
<p>
  単項マイナスOperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  単項マイナスOperator の戻り値の型は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
</p>
<p>
  単項マイナスOperator は例外を発生させません。
</p>
<p>
  <b>単項マイナスOperator のExample</b>
</p>
<pre>
my $num = -10;
</pre>
<h3 id="language-operator-add">加算Operator </h3>
<p>
  加算Operator は"+"で表現される、加算を行うための<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 + 右式
</pre>
<p>
  左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、加算Operator は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
</p>
<pre>
x + y;
</pre>
<p>
  加算Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  加算Operator の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  加算Operator は、例外を発生させません。
</p>
<h3 id="language-operator-subtract">減算Operator </h3>
<p>
  減算Operator は"-"で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 - 右式
</pre>
<p>
  左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、減算Operator は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
</p>
<pre>
x - y;
</pre>
<p>
  減算Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  減算Operator の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  減算Operator は、例外を発生させません。
</p>
<h3 id="language-operator-multiply">乗算Operator </h3>
<p>
  乗算Operator は"*"で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 * 右式
</pre>
<p>
  左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、乗算Operator は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
</p>
<pre>
x * y;
</pre>
<p>
  乗算Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  乗算Operator の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  乗算Operator は、例外を発生させません。
</p>
<h3 id="language-operator-divide">除算Operator </h3>
<p>
  除算Operator は"/"で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 / 右式
</pre>
<p>
  左式と右式は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、除算Operator は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型における演算が定義されます。
</p>
<pre>
x / y;
</pre>
<p>
  除算Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  除算Operator の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  整数型に対する演算の場合には、除算Operator は、右辺が0であった場合に、例外が発生します。
</p>
<p>
  浮動小数点型に対する演算の場合には、除算Operator は、例外を発生させません。
</p>

<h3 id="language-operator-remainder">剰余Operator </h3>
<p>
  剰余Operator は"%"で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 % 右式
</pre>
<p>
  左式と右式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、剰余Operator は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
</p>
<pre>
x % y;
</pre>
<p>
  剰余Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  剰余Operator の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  剰余Operator は、右辺が0であった場合に、例外が発生します。
</p>

<h3 id="language-operator-inc">インクリメントOperator </h3>
<p>
  インクリメントOperator は、値を1加算するOperator です。インクリメントOperator が前置されるか、後置されるかで、意味が変わります。
</p>
<pre>
# 前置のインクリメント
++レキシカル変数
++パッケージ変数
++フィールドへのアクセス
++配列へのアクセス
++デリファレンス

# 後置のインクリメント
レキシカル変数++
パッケージ変数++
フィールドへのアクセス++
配列へのアクセス++
デリファレンス++
</pre>
<p>
  インクリメントOperator の対象は、<a href="#language-lex-var">レキシカル変数</a>、<a href="#language-package-var">パッケージ変数</a>、<a href="#language-field-access">フィールドへのアクセス</a>、<a href="#language-array-access">配列へのアクセス</a>、<a href="#language-deref">デリファレンス</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  インクリメントOperator の対象の型は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイルエラーが発生します。
</p>
<p>
  <b>前置のインクリメントOperator </b>
</p>
<p>
  前置のインクリメントOperator は、インクリメントを行った後に、インクリメントされた値を返します。
</p>
<p>
  前置のインクリメントOperator は、次の式と等価です。対象に1が加算された後に、元の型で型キャストが行われ、対象に代入されます。
</p>
<pre>
(対象 = (型キャスト)(対象 + 1))
</pre>
<p>
  たとえば、byte型の値の前置のインクリメントは、次の式と等価です。
</p>

<pre>
($num = (byte)($num + 1))
</pre>
<p>
  <b>後置のインクリメントOperator </b>
</p>
<p>
  後置のインクリメントOperator は、インクリメントを行った後に、インクリメントする前の値を返します。
</p>
<p>
  後置のインクリメントOperator は、順次Operator を使った、次の式と等価です。対象が一時変数に保存され、対象に1が足された後に、元の型で型キャストが行われ、対象に代入されます。その後、一時変数が返されます。
</p>
<pre>
(my 一時変数 = 対象, 対象 = (型キャスト)(対象 + 1), 一時変数)
</pre>
<p>
  たとえば、byte型の値の後置のインクリメントは、次の式と等価です。
</p>

<pre>
(my $tmp = $num, $num = (byte)($num + 1), $tmp)
</pre>

<h3 id="language-operator-dec">デクリメントOperator </h3>
<p>
  デクリメントOperator は、値を1減算するOperator です。デクリメントOperator が前置されるか、後置されるかで、意味が変わります。
</p>
<pre>
# 前置のデクリメント
--レキシカル変数
--パッケージ変数
--フィールドへのアクセス
--配列へのアクセス
--デリファレンス

# 後置のデクリメント
レキシカル変数--
パッケージ変数--
フィールドへのアクセス--
配列へのアクセス--
デリファレンス--
</pre>
<p>
  デクリメントOperator の対象は、<a href="#language-lex-var">レキシカル変数</a>、<a href="#language-package-var">パッケージ変数</a>、<a href="#language-field-access">フィールドへのアクセス</a>、<a href="#language-array-access">配列へのアクセス</a>、<a href="#language-deref">デリファレンス</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  デクリメントOperator の対象の型は、<a href="#language-type-numeric">数値型</a>でなければなりません。そうでない場合は、コンパイルエラーが発生します。
</p>
<p>
  <b>前置のデクリメントOperator </b>
</p>
<p>
  前置のデクリメントOperator は、デクリメントを行った後に、デクリメントされた値を返します。
</p>
<p>
  前置のデクリメントOperator は、次の式と等価です。対象に1が減算された後に、元の型で型キャストが行われ、対象に代入されます。
</p>
<pre>
(対象 = (型キャスト)(対象 - 1))
</pre>
<p>
  たとえば、byte型の値の前置のデクリメントは、次の式と等価です。
</p>

<pre>
($num = (byte)($num - 1))
</pre>
<p>
  <b>後置のデクリメントOperator </b>
</p>
<p>
  後置のデクリメントOperator は、デクリメントを行った後に、デクリメントする前の値を返します。
</p>
<p>
  後置のデクリメントOperator は、順次Operator を使った、次の式と等価です。対象が一時変数に保存され、対象に1が足された後に、元の型で型キャストが行われ、対象に代入されます。その後、一時変数が返されます。
</p>
<pre>
(my 一時変数 = 対象, 対象 = (型キャスト)(対象 - 1), 一時変数)
</pre>
<p>
  たとえば、byte型の値の後置のデクリメントは、次の式と等価です。
</p>

<pre>
(my $tmp = $num, $num = (byte)($num - 1), $tmp)
</pre>

<h3 id="language-operator-bit">ビットOperator </h3>
<p>
  ビットOperator は、ビット演算を行うOperator のことで、><a href="#language-operator-bit-and">ビットANDOperator </a>、<a href="#language-operator-bit-or">ビットOROperator </a>、<a href="#language-operator-bit-not">ビット否定Operator </a>からなります。
</p>

<h3 id="language-operator-bit-and">ビットANDOperator </h3>
<p>
  ビットANDは"&"で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 & 右式
</pre>
<p>
  左式と右式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、ビットANDOperator の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
</p>
<pre>
x & y;
</pre>
<p>
  ビットANDOperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  ビットANDOperator の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  ビットANDOperator は、例外を発生させません。
</p>

<h3 id="language-operator-bit-or">ビットOROperator </h3>
<p>
  ビットORは"|"で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 | 右式
</pre>
<p>
  左式と右式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、ビットOROperator の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
</p>
<pre>
x | y;
</pre>
<p>
  ビットOROperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  ビットOROperator の戻り値の型は、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>された型です。
</p>
<p>
  ビットOROperator は、例外を発生させません。
</p>

<h3 id="language-operator-bit-not">ビット否定Operator </h3>
<p>
  ビット否定Operator は"~"で表現される<a href="#language-operator-unary">単項Operator </a>です。
</p>
<pre>
~式
</pre>
<p>
  式は<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  <a href="#language-expression">式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、ビット否定Operator の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
</p>
<pre>
~x
</pre>
<p>
  ビット否定Operator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  ビット否定Operator の戻り値の型は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>された型です。
</p>
<p>
  ビット否定Operator は例外を発生させません。
</p>
<p>
  <b>ビット否定Operator のExample</b>
</p>
<pre>
my $num = ~0xFF0A;
</pre>

<h3 id="language-operator-shift">シフトOperator </h3>
<p>
  シフトOperator は、ビットシフトを行うOperator で、<a href="#language-operator-left-shift">左シフトOperator </a>、<a href="#language-operator-arithmetic-right-shift">算術右シフトOperator </a>、<a href="#language-operator-logical-right-shift">論理右シフトOperator </a>からなります。
</p>
<h3 id="language-operator-left-shift">左シフトOperator </h3>
<p>
  左シフトは"<<"で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 << 右式
</pre>
<p>
  左式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  最初に<a href="#language-expression">左式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  右式は、int型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  左シフトOperator の演算結果は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
</p>
<pre>
x << y;
</pre>
<p>
  左シフトOperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  左シフトOperator は、例外を発生させません。
</p>

<h3 id="language-operator-arithmetic-right-shift">算術右シフトOperator </h3>
<p>
  算術右シフトは">>"で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 >> 右式
</pre>
<p>
  左式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  最初に<a href="#language-expression">左式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  右式は、int型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  算術右シフトOperator の演算結果は、C99における以下の演算と完全に一致する演算を行います。xに対して、<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
</p>
<pre>
x >> y;
</pre>
<p>
  算術右シフトOperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  算術右シフトOperator は、例外を発生させません。
</p>

<h3 id="language-operator-logical-right-shift">論理右シフトOperator </h3>
<p>
  論理右シフトは">>>"で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 >>> 右式
</pre>
<p>
  左式は、<a href="#language-type-integral">整数型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  最初に<a href="#language-expression">左式</a>に対して、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  右式は、int型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
<p>
<p>
  論理右シフトOperator の演算結果は、C99における以下の演算と完全に一致する演算を行います。xに対して、<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型における演算が定義されます。
</p>
<pre>
(符号付整数型キャスト)((符号なし整数型キャスト)x >> y);
</pre>
<p>
  論理右シフトOperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  論理右シフトOperator は、例外を発生させません。
</p>

<h3 id="language-operator-comparison">比較Operator </h3>
<p>
  比較Operator とは、左式と右式の間に置かれるOperator で、<a href="#language-expression">式</a>を返すOperator のことをいいます。
</p>
<pre>
左式 比較Operator  右式
</pre>
<p>
  比較Operator には、<a href="#language-operator-comparison-numeric">数値比較Operator </a>、<a href="#language-operator-comparison-string">文字列比較Operator </a>、isaOperator があります。
</p>

<h3 id="language-operator-comparison-numeric">数値比較Operator </h3>
<p>
  数値比較Operator とは、数値あるいはオブジェクトのアドレスを比較するために、左式と右式の間に置かれるOperator で、<a href="#language-expression">式</a>を返すOperator のことをいいます。
</p>
<pre>
左式 数値比較Operator  右式
</pre>
<p>
  数値比較Operator の一覧です。
</p>
<table>
  <tr>
    <th>Operator </th>
    <th>比較可能な型</th>
    <th>解説</th>
  </tr>
  <tr>
    <td>
      左式 == 右式
    </td>
    <td>
      左式と右式が数値型、左式と右式がオブジェクト型(未定義値を含む)
    </td>
    <td>
      左式と右式が等しい
    </td>
  </tr>
  <tr>
    <td>
      左式 != 右式
    </td>
    <td>
      左式と右式が数値型、左式と右式がオブジェクト型(未定義値を含む)
    </td>
    <td>
      左式と右式が等しくない
    </td>
  </tr>
  <tr>
    <td>
      左式 > 右式
    </td>
    <td>
      左式と右式が数値型
    </td>
    <td>
      左式は右式より大きい
    </td>
  </tr>
  <tr>
    <td>
      左式 >= 右式
    </td>
    <td>
      左式と右式が数値型
    </td>
    <td>
      左式は右式より大きいまたは等しい
    </td>
  </tr>
  <tr>
    <td>
      左式 < 右式
    </td>
    <td>
      左式と右式が数値型
    </td>
    <td>
      左式は右式より小さい
    </td>
  </tr>
  <tr>
    <td>
      左式 <= 右式
    </td>
    <td>
      左式と右式が数値型
    </td>
    <td>
      左式は右式より小さいまたは等しい
    </td>
  </tr>
</table>
<p>
  左辺と右辺の型は、比較可能な型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  数値型の比較の場合は、左式と右式に対して、<a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a>が行われます。
</p>
<p>
  その後、数値比較Operator は、C99における以下の演算と完全に一致する演算を行います。<a href="#language-c99-type">C99との型の対応</a>に応じた、int型、long型、float型、double型、オブジェクト型における演算が定義されます。
</p>
<pre>
# 数値型の比較、オブジェクト型の比較
(int32_t)(x == y);
(int32_t)(x != y);

# 数値型の比較
(int32_t)(x > y);
(int32_t)(x >= y);
(int32_t)(x < y);
(int32_t)(x <= y);
</pre>
<p>
  数値比較Operator の戻り値の型は、int型です。
</p>
<p>
  数値比較Operator は、例外を発生させません。
</p>

<h3 id="language-operator-comparison-string">文字列比較Operator </h3>
<p>
  文字列比較Operator とは、文字列を比較するために、左式と右式の間に置かれるOperator で、<a href="#language-expression">式</a>を返すOperator のことをいいます。
</p>
<pre>
左式 文字列比較Operator  右式
</pre>
<p>
  左式と右式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。
</p>
<p>
  文字列比較Operator の一覧です。
</p>
<table>
  <tr>
    <th>Operator </th>
    <th>解説</th>
  </tr>
  <tr>
    <td>
      左式 eq 右式
    </td>
    <td>
      左式と右式が等しい
    </td>
  </tr>
  <tr>
    <td>
      左式 ne 右式
    </td>
    <td>
      左式と右式が等しくない
    </td>
  </tr>
  <tr>
    <td>
      左式 gt 右式
    </td>
    <td>
      左式は右式より辞書式順序で比較して大きい
    </td>
  </tr>
  <tr>
    <td>
      左式 ge 右式
    </td>
    <td>
      左式は右式より辞書式順序で比較して大きいまたは等しい
    </td>
  </tr>
  <tr>
    <td>
      左式 lt 右式
    </td>
    <td>
      左式は右式より辞書式順序で比較して小さい
    </td>
  </tr>
  <tr>
    <td>
      左式 le 右式
    </td>
    <td>
      左式は右式より辞書式順序で比較して小さいまたは等しい
    </td>
  </tr>
</table>
<p>
  文字列比較Operator の戻り値の型は、int型です。条件が満たされた場合は1を、そうでない場合は0を返します。
</p>
<h3 id="language-operator-isa">isaOperator </h3>
<p>
  数値比較Operator とは、数値あるいはオブジェクトのアドレスを比較するために、左式と右式の間に置かれるOperator で、<a href="#language-expression">式</a>を返すOperator のことをいいます。
</p>
<p>
  isaOperator とはは、型の適合性をチェックするためのOperator で、<a href="#language-expression">式</a>を返します。
</p>
<pre>
左式 isa 右型
</pre>
<p>
  isaOperator は、右型に応じて、3種類の動作をします。
</p>
<p>
  1. 右型が、<a href="#language-type-numeric">数値型</a>、<a href="#language-type-multi-numeric">複数数値型</a>、<a href="#language-type-any-object">汎用オブジェクト型</a>、<a href="#language-type-ref">リファレンス型</a>の場合は、コンパイル時に左式の型が右型と同一のものであるかをチェックします。同一であった場合はint型で1を、そうでない場合は0を返します。
</p>
<p>
  2. 右型が、<a href="#language-type-class">クラス型</a>であった場合は、実行時に左式の型が、クラス型と一致するかをチェックします。一致した場合はint型で1を、そうでない場合は0を返します。左式の型は、オブジェクト型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  3. 右型が、<a href="#language-type-callback">コールバック型</a>であった場合は、実行時に左式の型がクラス型であり、そのクラスがコールバック型を満たすかどうかをチェックします。満たした場合はint型の1を、そうでない場合は0を返します。左式の型は、オブジェクト型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>

<h3 id="language-operator-logical">論理Operator </h3>
<p>
  論理Operator は、論理演算を行うOperator のことで、><a href="#language-operator-logical-and">論理ANDOperator </a>、<a href="#language-operator-logical-or">論理OROperator </a>、<a href="#language-operator-logical-not">論理否定Operator </a>からなります。
</p>
<p>
  論理Operator は、<a href="#language-expression">式</a>を返します。
</p>

<h3 id="language-operator-logical-and">論理ANDOperator </h3>
<p>
  論理ANDOperator とは、論理AND演算を行うために、"&&"で表現される、<a href="#language-expresssion">式</a>をオペランドとする<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 && 右式
</pre>
<p>
  論理ANDOperator の戻り値の型は、int型です。
</p>
<p>
  論理ANDOperator は次のように動作します。
</p>
<p>
  1. 左式に<a href="#language-type-convertion-bool">ブール型変換</a>を実行します。
</p>
<p>
  2. 左式の値が0以外であれば、右式に対して、<a href="#language-type-convertion-bool">ブール型変換</a>を実行し、その値を返します。
</p>
<p>
  3. 左式の値が0であれば、その値を返します。
</p>
<p>
  論理ANDOperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  論理ANDOperator は、例外を発生させません。
</p>

<h3 id="language-operator-logical-and">論理OROperator </h3>
<p>
  論理OROperator とは、論理OR演算を行うために、"||"で表現される、<a href="#language-expresssion">式</a>をオペランドとする<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 || 右式
</pre>
<p>
  論理OROperator は次のように動作します。
</p>
<p>
  論理OROperator の戻り値の型は、int型です。
</p>
<p>
  1. 左式に<a href="#language-type-convertion-bool">ブール型変換</a>を実行します。
</p>
<p>
  2. 左式の値が0あれば、右式に対して、<a href="#language-type-convertion-bool">ブール型変換</a>を実行し、その値を返します。
</p>
<p>
  3. 左式の値が0以外であれば、その値を返します。
</p>
<p>
  論理OROperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  論理OROperator は、例外を発生させません。
</p>

<h3 id="language-operator-logical-and">論理NOTOperator </h3>
<p>
  論理NOTOperator とは、論理NOT演算を行うために、式の左に置かれるOperator で、"!"で表現される<a href="#language-expression">式</a>を返す<a href="#language-operator-binary">単項Operator </a>です。式については、<a href="#language-expresssion">式</a>を参考にしてください。
</p>
<pre>
!式
</pre>
<p>
  論理NOTOperator の戻り値の型は、int型です。
</p>
<p>
  論理NOTOperator は、式に<a href="#language-type-convertion-bool">ブール型変換</a>を実行し、その値が0の場合は1を、0以外の値の場合は、0を返します。
</p>
<p>
  論理NOTOperator は<a href="#language-expression">式</a>を返します。
</p>
<p>
  論理NOTOperator は、例外を発生させません。
</p>

<h3 id="language-operator-concat">文字列連結Operator </h3>
<p>
  文字列連結Operator は"."で表現される<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 . 右式
</pre>
<p>
  左式あるいは右式が、<a href="#language-type-numeric">数値型</a>であった場合は、<a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a>によって文字列に変換されます。
</p>
<p>
  左式と右式はどちらも<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。そうでない場合は、コンパイルエラーになります。
</p>
<p>
  文字列連結Operator は、左式と右式で表現される<a href="#language-string">文字列</a>を連結し、新しい文字列を返します。
</p>
<p>
  文字列連結Operator は<a href="#language-expression">式</a>を返し、型は<a href="#language-type-string">文字列型</a>です。
</p>
<p>
  左式と右式の両方が、<a href="#language-literal-string">文字列Literal </a>であった場合は、コンパイル時に連結された文字列Literal が生成されます。パフォーマンスのコストを意識せずに、文字列連結Operator で、文字列Literal を連結できます。
</p>
<p>
  実行時に、左式あるいは右式が<a href="#language-undef">未定義値</a>だった場合は、例外が発生します。
</p>
<p>
  <b>文字列連結Operator のExample</b>
</p>
<pre>
my $str = "abc" . "def";
my $str = "def" . 34;
my $str = 123 . 456;
</pre>
<h3 id="language-operator-assign">代入Operator </h3>
<p>
  代入Operator は"="で表現される、代入を行うための<a href="#language-operator-binary">二項Operator </a>です。
</p>
<pre>
左式 = 右式
</pre>
<p>
  代入Operator は、右辺と左辺によって、複数の意味を持ちます。各項目を参考にしてください。
</p>
<p>
  代入Operator においては、右式が評価された後に、左式が評価されます。これは、原則として、式は左から右へ実行されるということの例外です。
</p>

<ul>
  <li><a href="#language-expression-set-lex-var">レキシカル変数の値の設定</a></li>
</ul>

<h3 id="language-operator-assign-special">特殊代入Operator </h3>
<p>
  特殊代入Operator とは、<a href="#language-operator-binary">二項Operator </a>と<a href="#language-operator-assign">代入Operator </a>の組み合わせで表現される特殊な代入を行う<a href="#language-operator-binary">二項Operator </a>のことです。
</p>
<pre>
左式 特殊代入Operator  右式
</pre>
<p>
  左式と右式が<a href="#language-type-compatible">型の互換性</a>を満たさない場合は、コンパイル時エラーが発生します。
</p>
<p>
  <b>特殊代入Operator の一覧</b>
</p>
<p>
  特殊代入Operator の一覧です。
</p>
<table>
  <tr>
    <td>加算代入Operator </td>
    <td>+=</td>
  </tr>
  <tr>
    <td>減算代入Operator </td>
    <td>-=</td>
  </tr>
  <tr>
    <td>乗算代入Operator </td>
    <td>*=</td>
  </tr>
  <tr>
    <td>除算代入Operator </td>
    <td>/=</td>
  </tr>
  <tr>
    <td>剰余代入Operator </td>
    <td>%=</td>
  </tr>
  <tr>
    <td>ビットAND代入Operator </td>
    <td>&=</td>
  </tr>
  <tr>
    <td>ビットOR代入Operator </td>
    <td>|=</td>
  </tr>
  <tr>
    <td>左シフト代入Operator </td>
    <td><<=</td>
  </tr>
  <tr>
    <td>算術右シフト代入Operator </td>
    <td>>>=</td>
  </tr>
  <tr>
    <td>論理右シフト代入Operator </td>
    <td>>>>=</td>
  </tr>
</table>
<p>
  特殊代入Operator は、次のように展開されます。
</p>
<pre>
# 展開前
左式 特殊代入Operator  右式

# 展開後
左式 代入Operator  (左式の型によるキャスト)(左式 指定されたOperator  右式)
</pre>
<p>
  たとえば、加算代入Operator の場合は、次のように展開されます。
</p>
<pre>
# 展開前 xはbyte型
$x += 1;

# 展開後
$x = (byte)($x + 1)
</pre>
<p>
  <b>特殊代入Operator のExample</b>
</p>
<p>
  特殊代入Operator のExampleです。
</p>
<pre>
$x += 1;
$x -= 1;
$x *= 1;
$x /= 1;
$x &= 1;
$x |= 1;
$x ^= 1;
$x %= 1;
$x <<= 1;
$x >>= 1;
$x >>>= 1;
</pre>
<h3 id="language-operator-ref">リファレンスOperator </h3>
<p>
  リファレンスOperator は、<a href="#language-type-numeric">数値型</a>または<a href="#language-type-multi-numeric">複数数値型</a>の変数のアドレスを取得するOperator です。C言語のアドレスOperator "&"を実現するために設計されました。
</p>
<pre>
\変数
</pre>
<p>
  変数が数値型または複数数値型でなかった場合は、コンパイル時エラーが発生します。
</p>
<p>
  リファレンスOperator は式を返します。返される型は、<a href="#language-type-ref">リファレンス型</a>です。
</p>
<pre>
  <b>リファレンスOperator のExample</b>
</pre>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $z : SPVM::Complex_2d;
my $z_ref : SPVM::Complex_2d& = \$z;
</pre>
<p>
  リファレンスの詳しい解説については、<a href="#language-ref">リファレンス</a>を見てください。
</p>

<h3 id="language-operator-array-length">配列長Operator </h3>
<p>
  配列長Operator は、<a href="#language-array">配列</a>の長さを取得するための"@"で表現される<a href="#language-operator-binary">単項Operator </a>です。
</p>
<pre>
@右式
</pre>
<p>
  右式は、配列型でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  配列長Operator は、配列の長さをint型の値で返します。
</p>
<p>
  配列長Operator は、<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>配列長Operator のExample</b>
</p>
<p>
  配列長Operator のExampleです。
</p>
<pre>
my $nums = new byte[10];
my $length = @$nums;
</pre>
<p>
  SPVMにはPerlにおけるコンテキストという考え方はなく、配列長Operator は、常に配列の長さを返すことに注意してください。
</p>

<h3 id="language-operator-string-length">文字列長Operator </h3>
<p>
  文字列長Operator は、<a href="#language-string">文字列</a>の長さを取得するための"length"で表現される<a href="#language-operator-binary">単項Operator </a>です。
</p>
<pre>
length 右式
</pre>
<p>
  右式は、<a href="#language-type-string-compatible">文字列互換型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  文字列長Operator は、文字列の長さをint型の値で返します。文字列長Operator が返す文字列の長さは、バイト列としてみたときの長さでです。
</p>
<p>
  文字列長Operator は、<a href="#language-expression">式</a>を返します。
</p>
<p>
  <b>文字列長Operator のExample</b>
</p>
<p>
  文字列長Operator のExampleです。
</p>
<pre>
my $nums = "abcde";
my $length = length $nums;
</pre>

<h3 id="language-operator-scalar">スカラOperator </h3>
<p>
  スカラOperator は、何もしないで、与えられた値そのものを返すOperator です。<a href="language-operator-array-length">配列長Operator </a>の意味を分かりやすくするためだけに用意されています。
</p>
<pre>
scalar 右式
</pre>
<p>
  右式は<a href="language-operator-array-length">配列長Operator </a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  スカラOperator は、式を返します。
</p>
<p>
  <b>スカラOperator のExample</b>
</p>
<p>
  スカラOperator のExampleです。
</p>
<pre>
my $nums = new int[3];
foo(scalar @$nums);
</pre>

<h3 id="language-operator-isweak">isweakOperator </h2>
<p>
  isweakOperator は、フィールドが、<a href="#language-weak-ref">ウィークリファレンス</a>かを確認するOperator です。
</p>
<pre>
isweak 変数->{Field Name};
</pre>
<p>
  オブジェクト式の型は、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  Field Nameは、存在するField Nameでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  フィールドに保存される値の型は、<a href="#language-type-object">オブジェクト型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>だった場合は、偽を返します。これは、<a href="#language-expression">式</a>です。
</p>
<p>
  isweakOperator は、フィールドがウィークリファレンスの場合は、int型の1を、そうでない場合は0を返します。これは、<a href="#language-expression">式</a>です。
</p>

<h2 id="language-operator-precedence">Operator の優先順位</h2>
<p>
  Operator の優先順位は、以下の通りです。下にいくほど、優先順位が高くなります。
</p>
<table>
  <tr>
    <th>結合方向</th>
    <th>Operator </th>
  </tr>
  <tr>
    <td>
      右結合
    </td>
    <td>
      <ul>
      代入Operator "="<br>
      加算代入Operator "+="<br>
      減算代入Operator "-="<br>
      乗算代入Operator "*="<br>
      除算代入Operator "/="<br>
      剰余代入Operator "%="<br>
      ビットAND代入Operator "&="<br>
      ビットOR代入Operator "|="<br>
      ビット排他OR代入Operator "^="<br>
      左シフト代入Operator "<<="<br>
      算術右シフト代入Operator ">>="<br>
      論理右シフトOperator ">>>="<br>
      文字列結合代入Operator ".="
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      論理OROperator "||"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      論理ANDOperator  "&&"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      ビットOROperator "|"<br>
      ビットXOROperator  "^"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      ビットANDOperator "&"
    </td>
  </tr>
  <tr>
    <td>
      非結合
    </td>
    <td>
      数値等価Operator "=="<br>
      数値非等価Operator "!="<br>
      文字列等価Operator "eq"<br>
      文字列非等価Operator "ne"<br>
    </td>
  </tr>
  <tr>
    <td>
      非結合
    </td>
    <td>
      数値大なりOperator ">"<br>
      数値小なりOperator "<"<br>
      数値大なり等価Operator ">="<br>
      数値小なり等価Operator "<="<br>
      文字列大なりOperator "gt"<br>
      文字列大なり等価Operator "ge"<br>
      文字列小なりOperator "lt"<br>
      文字列小なり等価Operator "le"<br>
      isaOperator "isa"
    </td>
  </tr>
  <tr>
    <td>
      左結合 
    </td>
    <td>
      左シフトOperator  "<<"<br>
      符号付き右シフトOperator ">>"<br>
      符号なし右シフトOperator ">>>"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      加算Operator "+"<br>
      減算Operator "-"<br>
      文字列連結Operator "."
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      乗算Operator "*"<br>
      除算Operator "/"<br>
      剰余Operator "%"
    </td>
  </tr>
  <tr>
    <td>
      右結合
    </td>
    <td>
      論理NOTOperator "!"<br>
      ビットNOTOperator "~"<br>
      リファレンスOperator "\"<br>
      プラスOperator "+"<br>
      マイナスOperator "-"<br>
      配列長取得Operator "@"<br>
      デリファレンスOperator "$"<br>
      型キャスト"(TypeName)"
      スカラOperator "scalar"<br>
      文字列長取得Operator "length"<br>
      requireOperator "require"<br>
    </td>
  </tr>
  <tr>
    <td>
      非結合
    </td>
    <td>
      前置インクリメントOperator "++"<br>
      後置インクリメントOperator "++"<br>
      前置デクリメントOperator "--"<br>
      後置デクリメントOperator "--"
    </td>
  </tr>
  <tr>
    <td>
      左結合
    </td>
    <td>
      アローOperator "->"<br>
    </td>
  </tr>
</table>
<p>
  Operator の優先順位は"()"を使うことによって、最優先にすることができます。
</p>
<pre>
# a * b が先
a * b + c

# b + c が先
a * (b + c)
</pre>

<h2 id="language-statement">文</h2>
<p>
  文は、ひとつの処理のことで"<a href="#language-scope-block">スコープブロック</a>"の中に複数記述することができます。<a href="#language-expression">式</a>のように値として評価されることはありません。
</p>
<p>
  <b>文の一覧</b>
</p>
<p>
  文の一覧です。
</p>
<ul class="list">
  <li><a href="#language-statement-if">if文</a></li>
  <li><a href="#language-statement-switch">switch文</a></li>
  <li><a href="#language-statement-case">case文</a></li>
  <li><a href="#language-statement-while">while文</a></li>
  <li><a href="#language-statement-for">for文</a></li>
  <li><a href="#language-statement-default">default文</a></li>
  <li><a href="#language-statement-block-simple">単純ブロック</a></li>
  <li><a href="#language-statement-eval">eval文</a></li>
  <li><a href="#language-statement-ifrequire">if require文</a></li>
  <li><a href="#language-statement-next">next文</a></li>
  <li><a href="#language-statement-last">last文</a></li>
  <li><a href="#language-statement-break">break文</a></li>
  <li><a href="#language-statement-return">return文</a></li>
  <li><a href="#language-statement-die">die文</a></li>
  <li><a href="#language-statement-weaken">weaken文</a></li>
  <li><a href="#language-statement-unweaken">unweaken文</a></li>
  <li><a href="#language-statement-expression">式文</a></li>
  <li><a href="#language-statement-empty">空文</a></li>
</ul>

<h3 id="language-statement-if">if文</h2>
<p>
  if文は、条件分岐を行うための文です。
</p>
<pre>
if (式) {

}
</pre>
<p>
  式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され、値が0以外の場合に、ブロックが実行されます。
</p>
<p>
  条件を複数書きたい場合には"elsif文"を続けることができます。 条件判定は上から実行され、それぞれの式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され、値が0以外の場合に対応するブロックが実行されます。
</p>
<pre>
if (式) {

}
elsif(式) {

}
</pre>
<p>
  "else文"を使って、if文あるいは、elsif文が条件を満たさなかった場合の処理を記述することができます。if文とelsif文の条件判定がすべて偽であった場合にelseのブロックの内部の文が実行されます。elsif文は、なくてもかまいません。
</p>
<pre>
if (式) {

}
elsif(式) {

}
else {

}
</pre>
<p>
  <b>if文のExample</b>
</p>
<p>
  if文のExampleです。
</p>
<pre>
my $flag = 1;

if ($flag == 1) {
print "One\n";
}
elsif ($flag == 2) {
print "Tow\n";
}
else {
print "Other";
}
</pre>
<p>
  if文は、内部的には、目には見えない単純なブロックで囲まれています。
</p>
<pre>
{
if (式) {

}
}
</pre>
<p>
  elsifは、内部的には、if文とelse文に展開されます。
</p>
<pre>
# 展開前
if (式1) {

}
elsif (式2) {

}
else {

}

# 展開後
if (式1) {
}
else {
if (式2) {

}
else {

}
}
</pre>
<p>
  if文の条件部で、変数宣言を行うときは、目には見えない<a href="#language-block-statement-simple">単純なブロック</a>で囲まれていることと、elsifは、内部的には、if文とelse文に展開されるということを、意識してください。
</p>
<pre>
# 展開前
my $num = 1;
if (my $num = 2) {

}
elsif (my $num = 3) {

}
else {

}

# 展開後
my $num = 1;
{
if (my $num = 2) {

}
else {
{
if (my $num = 3) {
  
}
else {
  
}
}
}
}
</pre>

<h3 id="language-statement-switch">switch文</h3>
<p>
  switch文は、int型の整数を条件にして、条件分岐を行うための文です。条件がint型の整数で、たくさんの分岐がある場合は、if文よりも高速です。
</p>
<pre>
switch (条件式) {
case 定数1: {

break;
}
case 定数2: {

break;
}
case 定数n: {
break;
}
default: {

}
}
</pre>
<p>
  条件式は、<a href="#language-expression">式</a>を指定できます。条件式には、<a href="#language-type-convertion-bool">ブール型変換</a>が実行されます。
</p>
<p>
  case文で指定される定数は、byte型かint型の定数でなければなりません。byte型の定数の場合は、コンパイル時に、int型に型変換されます。enum型の値や、int型の定数サブルーチンは、int型の定数として、構文解析時に展開されるので、利用することができます。
</p>
<p>
  case文に指定される定数は、重複してはいけません。重複している場合は、コンパイル時エラーが発生します。
</p>
<p>
  条件式で指定された値が、case文で指定された値にマッチした場合は、そのcase文の位置にジャンプします。
</p>
<p>
  マッチしなかった場合でdefault文が指定されている場合は、default文の位置にジャンプします。default文が指定されていなかった場合は、switchブロックは実行されません。
</p>
<p>
  switch文には、少なくともひとつのcase文が必要です。そうでない場合は、コンパイルエラーが発生します。
</p>
<p>
  default文は省略可能です。
</p>
<p>
  switchブロックの直下に記述できるのはcase文とdefault文だけです。
</p>
<p>
  caseとdefaultのブロックは省略することができます。
</p>
<pre>
switch (条件式) {
case 定数1:
case 定数2:
{
break;
}
default:
}
</pre>
<p>
  break文を使用した場合は、switchブロックから抜けることができます。
</p>

<pre>
switch (条件式) {
case 定数1: {
break;
}
case 定数2: {
break;
}
case 定数n: {
break;
}
default: {

}
}
</pre>
<p>
  caseのブロックが存在する場合は、最後の文はbreak文あるいは、return文でなければなりません。そうでない場合は、コンパイルエラーが発生します。
</p>

<p>
  <b>switch文のExample</b>
</p>
<p>
  switch文のExampleです。
</p>
<pre>
my $code = 2;
switch ($code) {
case 1: {
print "1\n";
break;
}
case 2: {
print "2\n";
break;
}
case 3: {
print "3\n";
break;
}
case 4:
case 5:
{
print "4 or 5\n"; {
break;
}
default: {
print "Other\n";
}
}
</pre>

<h3 id="language-statement-switch">case文</h3>
<p>
  case文は、switchブロックの中で使うことができる、条件を指定するための文です。case文についての詳細は、<a href="#language-statement-switch">switch文</a>の解説を見てください。
</p>

<h3 id="language-statement-switch">default文</h3>
<p>
  default文は、switchブロックの中で使うことができる、デフォルトの条件を指定するための文です。default文についての詳細は、<a href="#language-statement-switch">switch文</a>の解説を見てください。
</p>

<h3 id="language-statement-while">while文</h3>
<p>
  while文は、繰り返しを行うための文です。
</p>
<pre>
while (条件式) {

}
</pre>
<p>
  条件式に、<a href="#language-expresssion">式</a>を記述できます。条件式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され、値が0以外の場合に、ブロックが実行されます。そうでない場合は、ブロックを抜けます。
</p>
<p>
  <b>while文のExample</b>
</p>
<p>
  while文のExampleです。
</p>
<pre>
my $i = 0;
while ($i < 5) {

print "$i\n";

$i++;
}
</pre>
<p>
  whileブロックの内部では、<a href="#language-statement-last">last文</a>を使って、whileブロックを抜けることができます。
</p>
<pre>
while (1) {
last;
}
</pre>

<p>
  whileブロックの内部では、<a href="#language-statement-next">next文</a>を使って、次に実行される条件式の直前に移動することができます。
</p>
<pre>
my $i = 0;
while ($i < 5) {

if ($i == 3) {
$i++;
next;
}

print "$i\n";
$i++;
}
</pre>

<p>
  while文は、内部的には、目には見えない<a href="#language-block-statement-simple">単純なブロック</a>で囲まれています。
</p>
<pre>
{
while (条件式) {

}
}
</pre>
<p>
  while文の条件部で、変数宣言を行うときは、目には見えない<a href="#language-block-statement-simple">単純なブロック</a>で囲まれていることを意識してください。
</p>
<pre>
# 展開前
my $num = 5;
while (my $num = 3) {

$i++;
}

# 展開後
my $num = 5;
{
while (my $num = 3) {

$i++;
}
}
</pre>

<h3 id="language-statement-for">for文</h3>
<p>
  for文は、繰り返しを行うための文です。
</p>
<pre>
for (初期化式; 条件式; インクリメント式) {

}
</pre>
<p>
  初期化式には、<a href="#language-expression">式</a>を記述できます。一般的には、ループ変数の初期化などの式を記述します。初期化式は省略することが可能です。
</p>
<p>
  条件式、<a href="#language-expresssion">式</a>を記述できます。条件式に<a href="#language-type-convertion-bool">ブール型変換</a>が実行され、値が0以外の場合に、ブロックが実行されます。そうでない場合は、ブロックを抜けます。
</p>
<p>
  インクリメント式には、<a href="#language-expression">式</a>を記述できます。一般的には、ループ変数のインクリメントの式を記述します。インクリメント式は省略することが可能です。
</p>
<p>
  for文は以下のwhile文と同じ意味を持ちます。インクリメント式は、ブロックの最後に実行されます。初期化式は、<a href="#language-block-statement-simple">単純なブロック</a>に囲まれています。
</p>
<pre>
{
初期化式;
while (条件式) {



インクリメント式;
}
}
</pre>
<p>
  <b>for文のExample</b>
</p>
<p>
  for文のExampleです。
</p>
<pre>
for (my $i = 0; $i < 5; $i++) {

print "$i\n";
}
</pre>
<p>
  forブロックの内部では、<a href="#language-statement-last">last文</a>を使って、forブロックを抜けることができます。
</p>

<pre>
for (初期化式; 条件式; インクリメント式) {

}
</pre>

<p>
  forブロックの内部では、<a href="#language-statement-next">next文</a>を使って、次に実行されるインクリメント式の直前に移動することができます。
</p>
<pre>
for (my $i = 0; $i < 5; $i++) {

if ($i == 3) {
next;
}
}
</pre>

<h3 id="language-statement-return">return文</h3>
<p>
  return文を使うと、サブルーチンから脱出します。モータル変数に代入されているオブジェクトは、自動的に解放されます。
</p>
<pre>
return;
</pre>
<p>
  戻り値がある場合は、<a href="#language-expression">式</a>を指定することができます。
</p>
<pre>
return 式;
</pre>
<p>
  <a href="#language-sub-definition">サブルーチンの定義</a>において戻り値の型が"void型"である場合は、式が存在してはいけません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  <a href="#language-sub-definition">サブルーチンの定義</a>において戻り値の型が"void型"以外の場合は、式の型と一致していなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>

<h3 id="language-statement-die">die文</h3>
<p>
  die文は、例外を発生させるための文です。
</p>
<pre>
die 式;
</pre>
<p>
  式は、文字列互換型でなければなりません。
</p>
<p>
  die文の詳しい解説については、<a href="#language-exception">例外処理</a>を見てください。
</p>

<h3 id="language-statement-weaken">weaken文</h3>
<p>
  weaken文は、フィールドに対して、<a href="#language-weak-ref">ウィークリファレンス</a>を設定する文です。
</p>
<pre>
weaken 変数->{Field Name};
</pre>
<p>
  オブジェクト式の型は、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  Field Nameは、存在するField Nameでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  フィールドに保存される値の型は、<a href="#language-type-object">オブジェクト型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>だった場合は、weaken文は、何もしません。
</p>
<p>
  実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>でない場合は、次のことが行われます。
</p>
<p>
  1. フィールドに保存されているオブジェクトのリファレンスカウントを1減らします。
</p>
<p>
  2. フィールドに、ウィークリファレンスフラグを設定します。
</p>
<p>
  3. フィールドに保存されているオブジェクトのバックリファレンスに、フィールドを追加します。
</p>
<p>
  ウィークリファレンスフラグは、フィールドに保存されているオブジェクトに設定されるのではなく、フィールド自体に設定されることに注意してください。
</p>
<p>
  フィールドに保存されているオブジェクトのリファレンスカウントが、0になってしまった場合は、ウィークリファレンスは作成されず、フィールドに保存されているオブジェクトは解放されます。
</p>
<p>
  バックリファレンスとは、フィールドに保存されているオブジェクトが持つデータで、ウィークリファレンスフラグが設定されたフィールドを知るために、追加されます。これは、複数存在することがあります。
</p>
<pre>
# バックリファレンスが、複数あるExample
my $foo = new Foo;
my $bar = new Bar;
my $baz = new Baz;

$foo->{bar} = $bar;
$foo->{baz} = $baz;

$bar->{foo} = $foo;
$baz->{foo} = $foo;

weaken $bar->{foo};
weaken $baz->{foo};
</pre>
<p>
  上記の例では"$bar->{foo}"と"$baz->{foo}"に、ウィークリファレンスフラグが立ちます。$fooで表現されるオブジェクトは、バックリファレンス"$bar->{foo}"と"$baz->{foo}"を持ちます。
</p>
<p>
  バックリファレンスの情報が必要なのは、<a href="#language-expression-release-object">オブジェクトの解放</a>が行われるときに、バックリファレンスが指すフィールドに未定義値を代入する必要があるからです。
</p>

<h3 id="language-statement-unweaken">unweaken文</h3>
<p>
  unweaken文は、フィールドに対して、<a href="#language-weak-ref">ウィークリファレンス</a>を解除する文です。
</p>
<pre>
unweaken 変数->{Field Name};
</pre>
<p>
  オブジェクト式の型は、<a href="#language-type-class">クラス型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  Field Nameは、存在するField Nameでなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  フィールドに保存される値の型は、<a href="#language-type-object">オブジェクト型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>だった場合は、unweaken文は、何もしません。
</p>
<p>
  実行時にフィールドに保存されている値が、<a href="#language-undef">未定義値</a>でない場合は、次のことが行われます。
</p>
<p>
  1. フィールドに保存されているオブジェクトのリファレンスカウントを1増やします。
</p>
<p>
  2. フィールドのウィークリファレンスフラグを解除します。
</p>
<p>
  3. フィールドに保存されているオブジェクトのバックリファレンスから、フィールドを削除します。
</p>

<h3 id="language-statement-next">next文</h3>
<p>
  "next文"は、次のループの先頭に移動するための文です。<a href="#language-block-statement-while">whileブロック</a>、<a href="#language-block-statement-for">forブロック</a>の中で使うことができます。
</p>
<pre>
next;
</pre>
<p>
  実際の動作については<a href="#language-statement-while">while文</a>、<a href="#language-statement-for">for文</a>の解説を見てください。
</p>

<h3 id="language-statement-last">last文</h3>
<p>
  "last文"は、ループを脱出するための文です。<a href="#language-block-statement-while">whileブロック</a>、<a href="#language-block-statement-for">forブロック</a>の中で使うことができます。
</p>
<p>
  実際の動作については<a href="#language-statement-while">while文</a>、<a href="#language-statement-for">for文</a>の解説を見てください。
</p>
<pre>
last;
</pre>

<h3 id="language-statement-break">break文</h3>
<p>
  "break文"は、switchブロックを脱出するための文です。<a href="#language-block-statement-switch">switchブロック</a>の中で使うことができます。
</p>
<p>
  実際の動作については<a href="#language-statement-switch">switch文</a>の解説を見てください。
</p>
<pre>
break;
</pre>

<h3 id="language-statement-expression">式文</h3>
<p>
  式文は"<a href="#language-expression">式</a>"と";"で構成される文のことです。
</p>
<pre>
式;
</pre>

<p>
  式文のExampleです。
</p>
<pre>
1;
$var;
1 + 2;
foo();
my $num = 1 + 2;
</pre>

<h3 id="language-statement-empty">空文</h3>
<p>
  空文は";"だけで終わる文のことです。
</p>
<pre>
;
</pre>

<h2 id="language-type">型</h2>
<ul class="list">
  <li><a href="#language-type-summary">型の概要</a></li>
  <li><a href="#language-type-initial-value">型の初期値</a></li>
  <li><a href="#language-type-void">void型</a></li>
  <li><a href="#language-type-numeric">数値型</a></li>
  <li><a href="#language-type-integral">整数型</a></li>
  <li><a href="#language-type-byte">byte型</a></li>
  <li><a href="#language-type-short">short型</a></li>
  <li><a href="#language-type-int">int型</a></li>
  <li><a href="#language-type-long">long型</a></li>
  <li><a href="#language-type-floating-point">浮動小数点型</a></li>
  <li><a href="#language-type-float">float型</a></li>
  <li><a href="#language-type-double">double型</a></li>
  <li><a href="#language-type-package">パッケージ型</a></li>
  <li><a href="#language-type-object">オブジェクト型</a></li>
  <li><a href="#language-type-numeric-object">数値オブジェクト型</a></li>
  <li><a href="#language-type-undef">未定義型</a></li>
  <li><a href="#language-type-class">クラス型</a></li>
  <li><a href="#language-type-callback">コールバック型</a></li>
  <li><a href="#language-type-any-object">汎用オブジェクト型</a></li>
  <li><a href="#language-type-self">self型</a></li>
  <li><a href="#language-type-array">配列型</a></li>
  <li><a href="#language-type-array-numeric">数値配列型</a></li>
  <li><a href="#language-type-array-byte">byte[]型</a></li>
  <li><a href="#language-type-array-object">オブジェクト配列型</a></li>
  <li><a href="#language-type-array-value">値配列型</a></li>
  <li><a href="#language-type-any-object-array">汎用オブジェクト配列型</a></li>
  <li><a href="#language-type-string">文字列型</a></li>
  <li><a href="#language-type-string-compatible">文字列互換型</a></li>
  <li><a href="#language-type-multi-numeric">複数数値型</a></li>
  <li><a href="#language-type-ref">リファレンス型</a></li>
  <li><a href="#language-type-ref-numeric">数値のリファレンス型</a></li>
  <li><a href="#language-type-ref-multi-numeric">複数数値のリファレンス型</a></li>
</ul>
<h3 id="language-type-summary">型の概要</h2>
<p>
  SPVMは、静的型言語です。すべてのデータは静的な型を持ちます。
</p>
<p>
  レキシカル変数の宣言、フィールドの定義、パッケージ変数の定義、サブルーチンの定義の引数と戻り値において、型が指定される必要があります。
</p>
<p>
  レキシカル変数の宣言においては、型推論を利用して、暗黙的に型を指定することもできます。
</p>
<h3 id="language-type-initial-value">型の初期値</h2>
<p>
  レキシカル変数の初期値、<a href="#language-package-var-initial-value">パッケージ変数の初期値</a>、オブジェクトの生成におけるフィールドの初期値は、型の初期値によって決まります。
</p>
<p>
  型の初期化値の一覧です。データにおけるすべてのビット列は0に設定されます。
</p>
</p>
<table>
  <tr>
    <th>
      <b>Type Name </b>
    </th>
    <th>
      初期値
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      0
    </td>
  </tr>
  <tr>
    <td>
      <b>オブジェクト型</b>
    </td>
    <td>
      undef
    </td>
  </tr>
  <tr>
    <td>
      <b>複数数値型</b>
    </td>
    <td>
      すべてのフィールドが0
    </td>
  </tr>
</table>

<h3 id="language-type-numeric">数値型</h2>
<p>
  数値型は"<a href="#language-type-integral">整数型</a>"と"<a href="#language-type-floating-point">浮動小数点型</a>"からなります。
</p>

<h3 id="language-type-integral">整数型</h2>
<p>
  SPVMの整数型は以下の4つです。
</p>
<table>
  <tr>
    <th>
      <b>Type Name </b>
    </th>
    <th>
      説明
    </th>
    <th>
      サイズ
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      8bit符号付整数型
    </td>
    <td>
      1バイト
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      16bit符号付整数型
    </td>
    <td>
      2バイト
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      32bit符号付整数型
    </td>
    <td>
      4バイト
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      64bit符号付整数型
    </td>
    <td>
      8バイト
    </td>
  </tr>
</table>
<p>
  SPVMの整数型には、符号なし整数型は存在しません。
</p>
<p>
  整数の計算規則については、<a href="#language-operator-arithmetic">算術Operator </a>を参考にしてください。
</p>
<h3 id="language-type-byte">byte型</h2>
<p>
  byte型は、符号付8bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint8_t型と同じ型です。
</p>
<h3 id="language-type-short">short型</h2>
<p>
  byte型は、符号付16bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint16_t型と同じ型です。
</p>
<h3 id="language-type-int">int型</h2>
<p>
  int型は、符号付32bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint32_t型と同じ型です。
</p>
<h3 id="language-type-long">long型</h2>
<p>
  long型は、符号付64bit整数を表現する<a href="#language-type-integral">整数型</a>です。C99のint64_t型と同じ型です。
</p>

<h3 id="language-type-floating-point">浮動小数点型</h2>
<p>
  SPVMの浮動小数点型は以下の2つです。
</p>
<table>
  <tr>
    <th>
      <b>Type Name </b>
    </th>
    <th>
      説明
    </th>
    <th>
      サイズ
    </th>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      単精度浮動小数点型 - 32bitで浮動小数点を表現します
    </td>
    <td>
      4バイト
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      倍精度浮動小数点型 - 64bitで浮動小数点を表現します
    </td>
    <td>
      8バイト
    </td>
  </tr>
</table>
<p>
  浮動小数点の計算規則については、<a href="#language-operator-arithmetic">算術Operator </a>を参考にしてください。
</p>

<h3 id="language-type-float">float型</h2>
<p>
  float型は、単精度浮動小数点(32bit)を表現する<a href="#language-type-floating-point">浮動小数点型</a>です。C99のfloat型と同じ型です。
</p>

<h3 id="language-type-double">double型</h2>
<p>
  double型は、倍精度浮動小数点(64bit)を表現する<a href="#language-type-floating-point">浮動小数点型</a>です。C99のdouble型と同じ型です。
</p>

<h3 id="language-type-package">パッケージ型</h3>
<p>
  パッケージ型とは"<a href="#language-package-definition">パッケージの定義</a>"によって定義される型のことをいいます。
</p>
<pre>
package Foo {

}
</pre>
<p>
  パッケージ型は"<a href="#language-type-class">クラス型</a>""<a href="#language-type-callback">コールバック型</a>""<a href="#language-type-multi-numeric">複数数値型</a>"からなります。
</p>
<pre>
# クラス型
package Foo {

}

# コールバック型
package Foo : callback_t {

}

# 複数数値型
package Foo : mulnum_t {

}
</pre>
<p>
  <a href="#language-type-pointer">ポインタ型</a>は、クラス型でもあるので、ポインタ型もパッケージ型になります。
</p>
<pre>
# ポインタ型
package Foo : pointer_t {

}
</pre>

<h3 id="language-type-object">オブジェクト型</h3>
<p>
  オブジェクト型とは"<a href="#language-type-class">クラス型</a>""<a href="#language-type-callback">コールバック型</a>""<a href="#language-type-array">配列型</a>""<a href="#language-type-string">文字列型</a>""<a href="#language-type-any-object">汎用オブジェクト型</a>"を合わせたものをいいます。"複数数値型""リファレンス型"は含みません。
</p>
<p>
  オブジェクト型の値は"汎用オブジェクト型"に代入できます。
</p>
<pre>
my $object : object = new Foo;
my $object : object = new Foo[];
my $object : object = "abc";
</pre>
<p>
  オブジェクト型のサイズはC99における"sizeof(void*)"の値と一致していなければなりません。
</p>

<h3 id="language-type-numeric-object">数値オブジェクト型</h3>
<p>
  SPVMには、数値オブジェクト型として以下の型があります。
</p>
<table>
  <tr>
    <th>
      <b>数値型</b>
    </th>
    <th>
      対応する数値オブジェクト型
    </th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      SPVM::Byte
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      SPVM::Short
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      SPVM::Int
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      SPVM::Long
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      SPVM::Float
    </td>
  </tr>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      SPVM::Double
    </td>
  </tr>
</table>

<h3 id="language-type-undef">未定義型</h3>
<p>
  未定義型とは、<a href="#language-undef">未定義値</a>が持っている型のことです。明示的に利用することはできません。
</p>
<p>
  未定義型の値は<a href="#language-undef">未定義値</a>のみです。
</p>
<p>
  未定義型の値は、オブジェクト型に代入できます。他の型に代入した場合は、コンパイル時エラーが発生します。
</p>

<h3 id="language-type-class">クラス型</h3>
<p>
  クラス型とは"<a href="#language-package-definition">パッケージの定義</a>"によって定義される型で"複数数値型""コールバック型"ではない型のことをいいます。
</p>
<pre>
packag Foo {

}
</pre>
<p>
  クラス型はnewOperator によって、オブジェクトを生成することができます。
</p>
<pre>
my $foo = new Foo;
</pre>
<p>
  クラス型は<a href="#language-type-object">オブジェクト型</a>です。
</p>
<p>
  クラス型は<a href="#language-type-package">パッケージ型</a>です。
</p>
<p>
  "<a href="#language-type-pointer">ポインタ型</a>はクラス型です。
</p>

<h3 id="language-type-pointer">ポインタ型</h3>
<p>
  ポインタ型とは"<a href="#language-package-definition">パッケージの定義</a>"において"pointer_t デスクリプタ"が指定されたものをいいます。
</p>
<pre>
package Foo : pointer_t {

}
</pre>
<p>
  ポインタ型は、クラス型の一種です。
</p>
<p>
  ポインタ型のデータには、C言語のポインタを保存することができます。
</p>
<p>
  ポインタ型には、フィールドを定義することはできません。定義されていた場合は、コンパイル時エラーが発生します。
</p>
<h3 id="language-type-callback">コールバック型</h3>
<p>
  コールバック型とは"<a href="#language-package-definition">パッケージの定義</a>"において"callback_t デスクリプタ"が指定されたものをいいます。
</p>
<pre>
package SPVM::Comparator : callback_t {
sub : int ($self : self, $x1 : object, $x2 : object);
}
</pre>
<p>
  コールバック型は、C言語における関数ポインタに該当する機能を提供するために設計されました。
</p>
<p>
  コールバック型は、サブルーチンの定義を一つだけ持ちます。サブルーチンは、<a href="#language-sub-method">メソッド</a>でなければなりません。
</p>
<p>
  コールバック型のSubroutine Nameは、無名でなければなりません。
</p>
<p>
  コールバック型は"<a href="#language-field-definition">フィールドの定義</a>""<a href="#language-package-var-definition">パッケージ変数の定義</a>"を持つことはできません。
</p>
<p>
  コールバック型の値を、newOperator によって実体化することはできません。
</p>
<p>
  コールバック型は"パッケージ型"です。
</p>
<p>
  コールバック型は"オブジェクト型"です。
</p>
<p>
  コールバック型には、コールバックを満たしたクラス型のオブジェクトを代入できます。この場合、クラス型はコールバック型に適合するといいます。クラス型がコールバック型を満たすのは次の二つの場合です。
</p>
<p>
  1. コールバック型として定義されたサブルーチンと同一の名前とシグネチャを持つクラス型のオブジェクトは、コールバック型に代入できます。
</p>
<pre>
# コールバック型の定義
package SPVM::Comparator : callback_t {
sub : int ($self : self, $x1 : object, $x2 : object);
}

# クラスの定義
package SomeComparator {
sub new : int () {
return new SomeComparator;
}

sub : int ($self : self, $x1 : object, $x2 : object) {

}
}

# コールバック型への代入
my $comparator : SPVM::Comparator = SomeComparator->new;
</pre>
<p>
  2. コールバック型として定義されたサブルーチンと同一のシグネチャを持つコールバックオブジェクトの生成を行うと、コールバック型に代入できます。
</p>
<pre>
# コールバック型の定義
package SPVM::Comparator : callback_t {
sub : int ($self : self, $x1 : object, $x2 : object);
}

# コールバック型への代入
my $comparator : SPVM::Comparator = sub : int ($self : self, $x1 : object, $x2 : object) {

}
</pre>

<h3 id="language-type-any-object">汎用オブジェクト型</h3>
<p>
  汎用オブジェクト型は"object"で表現します。C言語の"void*"型を表現するために設計されました。
</p>
<pre>
my $object : object;
</pre>
<p>
  汎用オブジェクト型には"オブジェクト型"の値を代入できます。
</p>
<pre>
my $object : object = new Foo;
my $object : object = "abc";
my $object : object = new Foo[3];
</pre>

<h3 id="language-type-self">self型</h3>
<p>
  self型とは、自身の属するパッケージ型を表現し、引数がインボカントであることを示します。
</p>
<p>
  <a href="#language-sub-definition">サブルーチンの定義</a>において第一引数の型としてのみ利用できます。
</p>

<h3 id="language-type-void">void型</h3>
<p>
  void型とは、<a href="#language-sub-definition">サブルーチンの定義</a>において戻り値の型としてだけ利用できる、存在しないことを示す特別な型です。
</p>

<h3 id="language-type-basic">基本型</h3>
<p>
  次元を持たない型を基本型と呼びます。<a href="#language-type-numeric">数値型</a>、<a href="#language-type-package">パッケージ型</a>、<a href="#language-type-any-object">汎用オブジェクト型</a>、<a href="#language-type-string">文字列型</a>は、基本型です。
</p>

<h3 id="language-type-array">配列型</h3>
<p>
  配列型は、連続した複数のデータ領域を表現します。<a href="#language-type-basic">基本型</a>は、配列にすることができます。
</p>
<pre>
int[]
double[]
Point[]
object[]
string[]
</pre>
<p>
  配列は次元を持ち最大255次元まで表現できます。
</p>
<pre>
# 二次元
int[][]

# 三次元
int[][][]
</pre>
<p>
  配列型は、<a href="#language-type-object">オブジェクト型</a>です。
</p>
<p>
  配列を作成するには、newOperator を使用します。以下の例では、要素数が3のint型の配列を作成しています。
</p>
<p>
my $nums = new int[3];
</p>
<p>
  多次元配列を作成するときも、newOperator を使用します。以下の例では、要素数が3のint[]型の配列を作成しています。
</p>
<p>
my $nums = new int[][3];
</p>
<h3 id="language-type-array-numeric">数値の配列型</h3>
<p>
  数値の配列型とは、<a href="#language-type-numeric">数値型</a>の値を要素に持つ<a href="#language-type-array">配列型</a>のことです。
</p>
<p>
  <b>数値の配列型の一覧</b>
</p>
<ul class="list">
  <li>
    byte[]
  </li>
  <li>
    short[]
  </li>
  <li>
    int[]
  </li>
  <li>
    long[]
  </li>
  <li>
    float[]
  </li>
  <li>
    double[]
  </li>
</ul>
<p>
  数値の配列型によって表現されるデータは、要素が<a href="#language-type-numeric">数値型</a>のサイズで、配列の長さの個数で連続していなければなりません。
</p>
<p>
  数値の配列型のすべての要素は、配列の生成が行われたときに<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
</p>
<h3 id="language-type-array-byte">byte[]型</h3>
<p>
  SPVMにおいては、byte[]型は<a href="#language-type-string-compatible">文字列互換型</a>であるという点において特別な型です。
</p>
<pre>
byte[]
</pre>
<p>
  <a href="#language-type-string">文字列型</a>は、コンパイル時には文字列型として扱われますが、実行時にはbyte[]型になります。
</p>

<h3 id="language-type-array-object">オブジェクトの配列型</h3>
<p>
  オブジェクトの配列型とは、<a href="#language-type-object">オブジェクト型</a>の値を要素に持つ<a href="#language-type-array">配列型</a>のことです。
</p>
<p>
  <b>オブジェクトの配列型のExample</b>
</p>
<ul class="list">
  <li>
    Foo[]
  </li>
  <li>
    Foo[][]
  </li>
  <li>
    Comparable[]
  </li>
  <li>
    object[]
  </li>
</ul>
<p>
  オブジェクトの配列型によって表現されるデータは、要素が<a href="#language-type-object">オブジェクト型</a>のサイズで、配列の長さの個数で連続していなければなりません。
</p>
<p>
  オブジェクトの配列型のすべての要素は、配列の生成が行われたときに<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
</p>

<h3 id="language-type-array-value">値の配列型</h3>
<p>
  値の配列型とは、<a href="#language-type-multi-numeric">複数数値型</a>の値を要素に持つ<a href="#language-type-array">配列型</a>のことです。
</p>
<p>
  <b>値の配列型のExample</b>
</p>
<ul class="list">
  <li>
    Complex_2d[]
  </li>
  <li>
    Complex_2f[]
  </li>
</ul>
<p>
  値の配列型によって表現されるデータは、要素が<a href="#language-type-numeric">複数数値型</a>のサイズで、配列の長さの個数で連続していなければなりません。
</p>
<p>
  値の配列型のすべての要素は、配列の生成が行われたときに<a href="#language-type-initial-value">型の初期値</a>によって初期化されます。
</p>

<h3 id="language-type-any-object-array">汎用オブジェクト配列型</h3>
<p>
  汎用オブジェクト配列型とは、oarrayで表現される、<a href="#language-type-object">オブジェクト型</a>の値を要素として持つ任意の<a href="#language-type-array">配列型</a>の値を代入できる型です。C言語のqsort関数の第一引数には、任意の配列型をvoid*型にキャストして渡すことができますが、これに該当する機能を実現するために、汎用オブジェクト配列型は設計されました。
</p>
<pre>
my $array : oarray = new Point[3];
my $array : oarray = new object[3];
</pre>
<p>
  オブジェクト型以外の型を持つ値が代入された場合は、コンパイル時エラーが発生します。
</p>
<p>
  "oarray型"は"object[]型"と異なる型であることに注意してください。oarray型は、オブジェクト型の値を要素として持つ任意の配列型の値を代入できる型であるのに対して、"object[]型"は、"object型の値を要素に持つ配列"を表現する型で、任意の配列型の値を代入することはできません。
</p>
<p>
  汎用オブジェクト配列型は、<a href="#language-type-array">配列型</a>です。<a href="#language-operator-array-length">配列長Operator </a>によって長さを取得すること、<a href="#language-expression-set-array-element">配列の要素の値の設定</a>、<a href="#language-expression-get-array-element">配列の要素の値の取得</a>ができます。
</p>
<pre>
my $array : oarray = new SPVM::Int[3];

# 汎用オブジェクト配列型の要素の長さを取得
my $legnth = @$array;

# 汎用オブジェクト配列型の要素の値の取得
my $num = (SPVM::Int)$array->[0];

# 汎用オブジェクト配列型の要素の値の設定
$array->[0] = SPVM::Int->new(5);
</pre>
<p>
  汎用オブジェクト配列型の要素の値の設定においては、要素の型が、配列の型の次元よりも1だけ小さくなっているかの実行時チェックが入ります。チェックに失敗した場合は、例外が発生します。汎用オブジェクト配列型は、実行時型安全性を保証します。
</p>

<h3 id="language-type-string">文字列型</h3>
<p>
  文字列型は、文字列を表現する型です。stringによって表現します。C言語の"const char*"を表現するために設計されました。
</p>
<pre>
my $str : string;
</pre>
<p>
  文字列Literal によって、生成された文字列オブジェクトを代入できます。
</p>
<pre>
my $str : string = "abc";
</pre>
<p>
  SPVMの文字列は、要素を変更できないバイト型の配列です。配列アクセスを行って、文字を取得することができます。
</p>
<pre>
# 文字の取得
my $ch = $str->[1];
</pre>
<p>
  要素を変更しようとした場合は、コンパイル時エラーが発生します。
</p>
<pre>
# 要素の変更はコンパイルエラー
$str->[1] = 'd';
</pre>
<p>
  文字列型は、コンパイルが終わった後は、バイト型の配列とまったく同じものになります。たとえば、一つ目の表現は、二つ目の表現として扱われます。
</p>
<pre>
# isa 文字列型
if ($str isa string) {

}

# isa バイト型の配列
if ($str isa byte[]) {

}
</pre>
<p>
  SPVMの文字列は、変更不可ですが、これは、コンパイル時チェックであることに注意してください。
</p>
<p>
  文字列型は、byte[]型に、キャストすることができ、実行時に文字列を変更することができます。
</p>
<pre>
my $bytes = (byte[])$str;
$bytes->[1] = 'd';
</pre>
<p>
  文字列は、常に変更が可能であるものとして、扱ってください。
</p>

<h3 id="language-type-string-compatible">文字列互換型</h3>
<p>
  文字列互換型とは、<a href="#language-type-string">文字列型</a>と<a href="#language-type-array-byte">byte[]型</a>のことを言います。
</p>
<p>
  文字列互換型の値が生成される場合には、値のために確保されたメモリ領域の最後のひとつ後ろは"\0"になることが保証されます。(たとえば"abc"であれば"c"の後ろは"\0")SPVM言語から見た場合、この"\0"は意味を持ちませんが、ネイティブAPIを使う場合は、文字列互換型を、C言語の文字列として扱うことができます。
</p>

<h3 id="language-type-multi-numeric">複数数値型</h3>
<p>
  複数数値型とは、連続した数値を表現できる型です。
</p>
<p>
  パッケージの定義において"mulnum_t"デスクリプタを指定することで、複数数値型を定義できます。
</p>
<pre>
package Point_3i : mulnum_t {
has x : int;
has y : int;
has z : int;
}
</pre>
<p>
  複数数値型の詳しい解説については、<a href="#language-value">値</a>を見てください。
</p>

<h3 id="language-type-ref">リファレンス型</h3>
<p>
  リファレンス型とは、変数のアドレスが格納できる型のことです。<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-multi-numeric">複数数値型</a>の後ろに"&"を付けることで定義できます。
</p>
<pre>
my $num : int;
my $num_ref : int& = \$num;

my $point : Point_3i;;
my $point_ref : Point_3i& = \$point;
</pre>
<p>
  リファレンス型の値に代入できるのは、<a href="#language-operator-ref">リファレンスOperator </a>で取得したレキシカル変数のアドレスだけです。
</p>
<p>
  リファレンス型のレキシカル変数の宣言だけが行われた場合は、コンパイル時エラーが発生します。
</p>
<p>
  リファレンス型は、<a href="#language-lex-var-declaration">レキシカル変数の宣言</a>の型として利用できます。必ずリファレンスOperator によって、レキシカル変数のアドレスが格納される必要があります。レキシカル変数の宣言だけの場合は、コンパイル時エラーが発生します。
</p>
<p>
  リファレンス型は、<a href="#language-sub-definition">サブルーチンの定義</a>における引数の型として利用できます。
</p>
<p>
  リファレンス型は、<a href="#language-sub-definition">サブルーチンの定義</a>における戻り値の型として利用できません。
</p>
<p>
  リファレンス型は、<a href="#language-package-definition">パッケージの定義</a>におけるフィールドの型として利用できません。
</p>
<p>
  リファレンス型は、<a href="#language-package-definition">パッケージの定義</a>におけるパッケージ変数の型として利用できません。
</p>
<p>
  Invalid 場所で、リファレンス型が使用された場合は、コンパイル時エラーが発生します。
</p>
<p>
  リファレンスの詳しい解説については、<a href="#language-ref">リファレンス</a>を見てください。
</p>

<h2 id="language-type-inference">型推論</h2>
<p>
  型推論によって、<a href="#language-lex-var-declaration">レキシカル変数の宣言</a>するときに、<a href="#language-type">型</a>の指定を省略することができます。型推論は、常に代入Operator の右辺の型によって、行われます。
</p>
<pre>
# int
my $num = 1;

# double
my $num = 1.0;

# Foo
my $foo = new Foo;
</pre>
<h2 id="language-type-compatible">型の互換性</h2>
<p>
  型に互換性があるというのは、<a href="#language-expression-typecast">型キャスト</a>を行わないで、値が移動ができる型のことです。
</p>
<p>
  型に互換性があるのは次の場合です。
</p>
<p>
  <b>移動元と移動先の型が同一の場合</b>
</p>
<p>
  移動元と移動先の型が同一の場合は、型の互換性があります。
</p>
<pre>
my $num1 : int;
my $num2 : int;
$num1 = $num2;
</pre>
<p>
  <b>移動元の型がbyte[]型で、移動先の型が文字列型の場合</b>
</p>
<p>
  移動元の型がbyte[]型で、移動先の型が文字列型の場合は、型の互換性があります。
</p>
<pre>
my $bytes = new byte[3];
my $str : string;
$str = $bytes;
</pre>
<p>
  <b>移動元の型がオブジェクト型で、移動先の型が汎用オブジェクト型の場合</b>
</p>
<pre>
my $foo : Foo = new Foo;
my $object : object;
$object = $foo;
</pre>
<p>
  <b>移動元の型と移動先の型が、汎用オブジェクト型あるいは、汎用オブジェクト型の配列で、移動元の型の次元数が、移動先の型の次元数以上の場合</b>
</p>
<pre>
my $objects_dim2_src : object[];
my $objects_dim1_dist : object;
$objects_dim1_dist = $objects_dim2_src;
</pre>
<p>
  注意点として、汎用オブジェクトの配列と基本型の配列には互換性はありません。
</p>
<pre>
# コンパイルエラー
my $objets : object[] = new int[3];
</pre>
<p>
  型に互換性がない場合は、<a href="#language-type-convertion-implicite">暗黙的な型変換</a>が試みられます。暗黙の型変換に失敗した場合は、コンパイル時エラーが発生します。
</p>

<h2 id="language-type-convertion">型変換</h2>
<ul class="list">
  <li><a href="#language-type-convertion-typecast">型キャスト</a></li>
  <li><a href="#language-type-convertion-typecast">数値型の型変換</a></li>
  <li><a href="#language-type-convertion-implicite">暗黙的な型変換</a></li>
  <li><a href="#language-type-convertion-numeric-type-order">数値型の順序</a></li>
  <li><a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a></li>
  <li><a href="#language-type-convertion-binary-numeric-widening">二項数値拡大型変換</a></li>
  <li><a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a></li>
  <li><a href="#language-type-convertion-numeric-widening">数値拡大型変換</a></li>
  <li><a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a></li>
  <li><a href="#language-type-convertion-boxing">ボクシング変換</a></li>
  <li><a href="#language-type-convertion-unboxing">アンボクシング変換</a></li>
  <li><a href="#language-type-convertion-bool">ブール型変換</a></li>
</ul>

<h3 id="language-type-convertion-typecast">型キャスト</h3>
<p>
  型キャストとは、明示的に記述して行う型変換のことを言います。
</p>
<pre>
# 型キャスト
(型)式
</pre>
<p>
  int型の値をlong型に変換するExampleは以下のようになります。
</p>
<pre>
my $num = (long)3;
</pre>
<p>
  型キャストは、<a href="#language-expression">式</a>を返します。
</p>
<p>
  移動元の型と指定した型が同一の場合は、単に値のコピーになります。
</p>
<pre>
my $num : int = (int)4;
</pre>
<p>
  <b>型キャストにおける型変換の一覧</b>
</p>
<p>
  型キャストにおける型変換の一覧です。この表にない型キャストが行われた場合は、コンパイル時エラーが発生します。
</p>
<table>
  <tr>
    <th>
      <b>指定した型</b>
    </th>
    <th>
      <b>移動元の型</b>
    </th>
    <th>
      変換の内容
    </th>
  </tr>
  <tr>
    <td>
      <b>byte[]</b>
    </td>
    <td>
      <b>string</b>
    </td>
    <td>
      アドレス値がコピーされます。
    </td>
  </tr>
  <tr>
    <td>
      <b>string</b>
    </td>
    <td>
      <b>byte[]</b>
    </td>
    <td>
      アドレス値がコピーされます。
    </td>
  </tr>
  <tr>
    <td>
      <b>数値型</b>
    </td>
    <td>
      <b>数値型</b>
    </td>
    <td>
      <a href="#language-type-convertion-numeric-widening">数値型の型変換</a>が行われます。
    </td>
  </tr>
  <tr>
    <td>
      <b>数値オブジェクト型</b>
    </td>
    <td>
      <b>数値型</b>
    </td>
    <td>
      <a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。数値型と数値オブジェクト型が表現する数値型は、同じでなければなりません。たとえば、数値型がintの場合は、数値オブジェクト型はSPVM::Int型でなければなりません。
    </td>
  </tr>
  <tr>
    <td>
      <b>汎用オブジェクト型</b>
    </td>
    <td>
      <b>数値型</b>
    </td>
    <td>
      <a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。
    </td>
  </tr>
  <tr>
    <td>
      <b>数値型</b>
    </td>
    <td>
      <b>数値オブジェクト型</b>
    </td>
    <td>
      <a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。数値型と数値オブジェクト型が表現する数値型は、同じでなければなりません。たとえば、数値型がintの場合は、数値オブジェクト型はSPVM::Int型でなければなりません。
    </td>
  </tr>
  <tr>
    <td>
      <b>数値型</b>
    </td>
    <td>
      <b>汎用オブジェクト型</b>
    </td>
    <td>
      <a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。
    </td>
  </tr>
  <tr>
    <td>
      <b>文字列型</b>
    </td>
    <td>
      <b>数値型</b>
    </td>
    <td>
      数値が、C標準のsprintf関数の"%g"フォーマットを使って、文字列化されます。
    </td>
  </tr>
</table>

<h3 id="language-type-convertion-numeric">数値型の型変換</h3>
<p>
  数値型の型変換とは、<a href="#language-type-numeric">数値型</a>から<a href="#language-type-numeric">数値型</a>への変換のことです。
</p>
<p>
  数値型の型変換は、対応するC言語における数値型による型変換と全く同じ処理を行います。例えば、SPVMにおけるintからlongへの型変換は、C言語のint32_t型からint64_t型への型変換と同じ処理を行います。
</p>
<pre>
# SPVMの変換
my $src : int = 5;
my $dist = (long)$src;

# C言語における対応
int32_t src = 5;
int64_t dist = (int64_t)src;
</pre>
<p>
  型の対応については、<a href="#language-c99-type">C99との型の対応</a>を見てください。
</p>
<p>
  大きな型から小さな型に変換した場合や、浮動小数点から整数型に変換した場合は、Valid 情報が保持されない場合があります。SPVMでは、C99に対応する型変換をそのまま行っているので、Valid 情報が保持されない場合に、どの値に変換されるかは、C99の仕様と同じです。
</p>

<h3 id="language-type-convertion-implicite">暗黙的な型変換</h3>
<p>
  暗黙的な型変換とは、SPVMによって行われる自動的な型変換のことです。次の箇所が、暗黙的な型変換が行われる可能性のある個所です。
</p>
<ul class="list">
  <li>異なる型に代入する場合</li>
  <li>異なる型のサブルーチンの引数に渡す場合</li>
  <li>戻り値とは異なる型を返却する場合</li>
</ul>
<p>
  次の場合に暗黙的な型変換が行われます。
</p>
<p>
  移動元と移動先の型がどちらも数値型で、移動元の型よりも移動先の型が大きい場合は、<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>が行われます。
</p>
<pre>
# 暗黙の拡大型変換
my $num : long = 123;
my $num : double = 12.5f;
</pre>
<p>
  移動元と移動先の型がどちらも数値型で、移動元の型よりも移動先の型が小さい場合で、移動元の値が、Integer Literal  かつ移動先の型の値の範囲で表現できる場合は、<a href="#language-type-convertion-numeric-narrowing">数値縮小型変換</a>が行われます。
</p>
<pre>
# 暗黙の縮小型変換
my $num : byte = 123;
my $num : short = 134;
</pre>
<p>
  移動元の型が数値型で、移動先の型が汎用オブジェクト型の場合は、対応する数値オブジェクト型への<a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。以下の場合の例では、SPVM::Int型のオブジェクトに変換されたものが、汎用オブジェクトに代入されます。
</p>
<pre>
# object型への暗黙のボクシング変換
my $num = 123;
my $object : object = $num;
</pre>
<p>
  移動元の型が数値型で、移動先の型が対応する数値オブジェクト型の場合は、対応する数値オブジェクト型への<a href="#language-type-convertion-boxing">ボクシング変換</a>が行われます。
</p>
<pre>
# object型への暗黙のボクシング変換
my $num = 123;
my $object : SPVM::Int = $num;
</pre>
<p>
  移動元の型が汎用オブジェクト型で、移動先の型が数値型の場合は、対応する数値型における<a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。以下の場合の例では、SPVM::Int型のオブジェクトからint型への変換が試みられます。
</p>
<pre>
# object型からの暗黙のアンボクシング変換 - 
my $object : object;
my $num : int = $object;
</pre>
<p>
  移動元の型が数値オブジェクト型で、移動先の型が対応する数値型の場合は、対応する数値型における<a href="#language-type-convertion-unboxing">アンボクシング変換</a>が行われます。
</p>
<pre>
# 数値オブジェクト型からの暗黙のアンボクシング変換
my $num_obj = SPVM::Int->new(3);
my $num : int = $num_obj;
</pre>
  移動元の型が数値型で、移動先の型が、文字列型の場合は、<a href="#language-type-convertion-numeric-to-string">数値から文字列への型変換</a>が行われます。以下の場合の例では、数値の"123"が文字列""123""に変換されたものが代入されます。
</p>
<pre>
# 文字列型への暗黙のボクシング変換
my $num = 123;
my $str : string = $num;
</pre>

<h3 id="language-type-convertion-numeric-type-order">数値型の順序</h3>
<p>
  <a href="#language-type-numeric">数値型</a>は、型の順序を持ちます。型の順序は小さい方から"byte""short""int""long""float""double"です。
</p>
<h3 id="language-type-convertion-unary-numeric-widening">単項数値拡大型変換</h3>
<p>
  単項数値拡大型変換とは、<a href="#language-expression">式</a>がbyte型あるいはshort型であった場合に、int型へ<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>を行うことをいいます。
</p>
<p>
  単項数値拡大型変換が行われるのは以下の場合です。
</p>
<ul class="list">
  <li>配列のインデックス</li>
  <li>配列を作成する場合の次元</li>
  <li>単項プラスOperator のオペランド</li>
  <li>単項マイナスOperator のオペランド</li>
  <li>シフトOperator "<<"">>"">>>"の左右のオペランド</li>
</ul>
<h3 id="language-type-convertion-binary-numeric-widening">二項数値拡大型変換</h3>
<p>
  二項数値拡大型変換とは、左辺と右辺に数値型をとる二項Operator において、左式と右式に適用される<a href="#language-type-convertion-numeric-widening">数値拡大型変換</a>のことをいいます。
</p>
<p>
  次のルールが適用されます。
</p>
<p>
  1. 一方の式が、double型の場合は、他方の型はdouble型に変換されます。
</p>
<p>
  2. 一方の式が、float型の場合は、他方の型はfloat型に変換されます。
</p>
<p>
  3. 一方の式が、long型の場合は、他方の型はlong型に変換されます。
</p>
<p>
  4. それ以外の場合は、int型に変換されます。
</p>
<p>
  二項数値拡大型変換が行われるのは以下の場合です。
</p>
<ul class="list">
  <li><a href="#language-operator-add">加算Operator </a></li>
  <li><a href="#language-operator-subtract">減算Operator </a></li>
  <li><a href="#language-operator-multiply">乗算Operator </a></li>
  <li><a href="#language-operator-divide">除算Operator </a></li>
  <li><a href="#language-operator-remainder">剰余Operator </a></li>
  <li><a href="#language-operator-bit-and">ビットANDOperator </a></li>
  <li><a href="#language-operator-bit-or">ビットOROperator </a></li>
  <li><a href="#language-operator-comparison-numeric">数値比較Operator </a></li>
</ul>

<h3 id="language-type-convertion-numeric-narrowing">数値縮小型変換</h3>
<p>
  数値縮小型変換とは、<a href="#language-type-numeric">数値型</a>において大きい型から小さい型への変換が行われる場合に適用される変換の規則のことです。
</p>

<h3 id="language-type-convertion-numeric-widening">数値拡大型変換</h3>
<p>
  数値拡大型変換とは、<a href="#language-type-numeric">数値型</a>において小さい型から大きい型への変換が行われる場合に適用される変換の規則のことです。
</p>

<h3 id="language-type-convertion-boxing">ボクシング変換</h3>
<p>
  ボクシング変換とは、数値型の値を、数値オブジェクト型に変換する操作のことをいいます。
</p>

<h3 id="language-type-convertion-unboxing">アンボクシング変換</h3>
<p>
  アンボクシング変換とは、数値オブジェクト型の値を、対応する数値型の値に変換する操作のことをいいます。
</p>

<h3 id="language-type-convertion-bool">ブール型変換</h3>
<p>
  ブール型変換とは、if文の条件部などで適用される、真偽値判定のために、適用される変換のことです。
</p>
<p>
  <b>ブール型変換が行われる場所</b>
</p>
<p>
  <b>if文のかっこの中</b>
</p>
<pre>
if (条件部) {

}
</pre>
<p>
  <b>unless文のかっこの中</b>
</p>
<pre>
unless (条件部) {

}
</pre>
<p>
  <b>forのかっこの中の二つ目</b>
</p>
<pre>
for (初期化;条件部;次の値;) {

}
</pre>
<p>
  <b>whileのかっこの中</b>
</p>
<pre>
while (条件部) {

}
</pre>
<p>
  <b>論理ANDOperator の左右</b>
</p>
<pre>
条件部 && 条件部
</pre>
<p>
  <b>論理OROperator の左右</b>
</p>
<pre>
条件部 || 条件部
</pre>
<p>
  <b>論理否定Operator の右側</b>
</p>
<pre>
!条件部
</pre>
<p>
  ブール型変換で指定される式は、<a href="#language-type-numeric">数値型</a>あるいは<a href="#language-type-object">オブジェクト型</a>あるいは<a href="#language-type-undef">未定義型</a>でなければなりません。そうでない場合は、コンパイル時エラーが発生します。
</p>
<p>
  ブール型変換の戻り値は、int型の式です。
</p>
<p>
  式が<a href="#language-undef">未定義値</a>である場合は、0が返されます。
</p>
<p>
  式が、<a href="#language-type-numeric">数値型</a>の場合は、<a href="#language-type-convertion-unary-numeric-widening">単項数値拡大型変換</a>が行われます。
</p>
<p>
  式がint型の場合は、その値が返されます。
</p>
<p>
  式がlong型、float型、double型、オブジェクト型である場合は、C99における以下の演算と完全に一致する演算を行い、結果が返されます。
</p>
<pre>
!!x
</pre>
<p>
  式がオブジェクト型の場合は、未定義値の場合は0、そうでない場合は1が返されます。
</p>

<h2 id="language-auto-loaded-module">自動的に読み込まれるモジュール</h2>
<p>
  自動的に読み込まれるモジュールです。<a href="#language-module-use">モジュールの読み込み</a>を行わないで利用することができます。
</p>
<ul class="list">
  <li>SPVM::Byte</li>
  <li>SPVM::Short</li>
  <li>SPVM::Int</li>
  <li>SPVM::Long</li>
  <li>SPVM::Float</li>
  <li>SPVM::Double</li>
  <li>SPVM::Complex_2f</li>
  <li>SPVM::Complex_2d</li>
</ul>

<h2 id="language-other">参考情報</h2>
<p>
  SPVMの公式ドキュメントについては、"<a href="/">SPVMドキュメント</a>"を見てください。
</p>
<p>
  PerlからSPVM言語の利用については"<a href="/exchange-api">SPVMエクスチェンジAPI仕様</a>"を見てください。
</p>
<p>
  SPVMからC/C++などのネイティブコードの利用については、"SPVMネイティブAPI"を見てください。
</p>
<p>
  SPVMの標準関数については、"SPVM標準関数"を見てください。
</p>
<p>
  SPVMの標準モジュールについては、"SPVM標準モジュール"を見てください。
</p>

<h2 id="language-limitation">制限</h2>
<p>
  SPVMにおける制限です。
</p>

<h3 id="language-limitation-sub-arguments-count">サブルーチンの引数の個数の制限</h3>
<p>
  SPVMのサブルーチンの引数の個数の最大は256個です。
</p>
<p>
  複数数値型の引数を渡すときは、フィールドの個数が、引数の個数としてカウントされます。たとえばSPVM::Complex_2d型が引数で指定された場合は、2個と数えます。
</p>
<p>
  複数数値のリファレンス型の引数を渡すときは、複数数値型のフィールドの個数が、引数の個数としてカウントされます。たとえばSPVM::Complex_2d&型が引数で指定された場合は、2個と数えます。
</p>
<p>
  もし、最大値を超えた場合は、コンパイル時エラーが発生します。
</p>

<h3 id="language-limitation-value-type-fileds-count">複数数値型のフィールドの個数の制限</h3>
<p>
  複数数値型のフィールドの個数の最大値は、256個で、少なくともひとつのフィールドが必要です。そうでない場合は、コンパイル時エラーが発生します。
</p>

