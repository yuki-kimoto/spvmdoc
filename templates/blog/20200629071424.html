<h2>SPVM Getting Started and How to improve SPVM Performance</h2>

Let's take SPVM for the first time. Then, let's improve the performance of the SPVM code.

<h3>SPVM Getting Started</h3>

Let's take SPVM for the first time. This is a first simple example. Let's calcurate the sum of numbers.

<h4>Create SPVM module</h4>

Create SPVM module. The extension is "spvm". In this example, the name of SPVM module is "MyMath.spvm".

Create "MyMath.spvm" in the "lib" directory, and you write the following code.

<pre>
# lib/MyMath.spvm
package MyMath {
  sub sum : int ($nums : int[]) {
    
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }
    
    return $total;
  }
}
</pre>

<h4>Package Definition</h4>

Write <b>Package Definition</b> by <b>package</b> keyword. Unlike Perl, SPVM always need package. The whole SPVM grammar is a set of packages.

<pre>
# Package Definition
package MyMath {

}
</pre>

See also <a href="/language.html#language-package">Package - SPVM Language Specification</a> about Package.

<h4>Subroutine Definition</h4>

Write <b>Subroutine Definition</b> by <b>sub</b> keyword. Unlike Perl, SPVM Subroutine Definition have return type and argument types.
  
<pre>
package MyMath {
  # Subroutine Definition
  sub sum : int ($nums : int[]) {
    
  }
}
</pre>

See also <a href="/language.html#language-sub">Subroutine - SPVM Language Specification</a> about Subroutine.

<h4>Numeric Types</h4>

<b>int</b> type in sum return value is signed 32bit integer type. This is same as C99 int32_t.

<pre>
int
</pre>

SPVM has the following types as other numeric types.

<table>
  <tr>
    <th>
      <b>SPVM numric type</b>
    </ th>
    <th>
      <b>C99 type</b>
    </ th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      int8_t
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      int16_t
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      int32_t
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      int64_t
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      float
    </td>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      double
    </td>
  </tr>
</table>

See also <a href="http://59.106.185.196:3000/spvmdoc-public/language.html#language-type">Type - SPVM Language Specification</a> about Type.

<h4>Array Types</h4>

<b>int[]</b> type in sum arguments is array of int type. 

<pre>
int[]
</pre>

The numeric array type guarantees that the values are consecutive in memory.

In this point, unlike Perl where all value are assigned to the dynamic type SV, SPVM has a static type, so it can represent a efficient sequence of numbers.

See also <a href="http://59.106.185.196:3000/spvmdoc-public/language.html#language-type">Type - SPVM Language Specification</a> about Type.

<h4>Lexical Variable Declaration</h4>

Write <b>Lexical Variable Declaration</b> by <b>my</b> keyword. You can initialize variables at the same time you declare variables.

<pre>
my $total = 0;
</pre>

The above declaration has the same meaning as:

<pre>
my $total : int = 0;
</pre>

0 on the right side is a signed 32-bit integer, so the type of the variable is automatically determined by type inference.

See also <a href="/language.html#language-lex-var">Lexical Variabe - SPVM Language Specification</a> about Lexical Variabe Declaration.

See also <a href="/language.html#language-type-inference">Type Inference - SPVM Language Specification</a> about Type Inference.

<h4>Integer Literal</h4>

0 is Integer Literal. 

<pre>
my $total : int = 0;
</pre>

SPVM has the following Literal.

<ul>
  <li>Integer Literal</li>
  <li>Floating Point Literal</li>
  <li>Charater Literal</li>
  <li>String Literal</li>
</ul>

<pre>
# Integer Literal
123
123_456_789

# Floating Point Literal
1.32
1.32f

# Character Literal
'a'
'c'

# String Literal
"Hello World!"
</pre>

See also <a href="/language.html#language-literal">Literal - SPVM Language Specification</a> about Literal.

<h4>for Statement</h4>

  <p>
    Let's look at the part where the sum of the arrays is calculated.
  </p>
<pre>
my $total = 0;
for (my $i = 0; $i <@$nums; $i++) {
  $total += $nums->[$i];
}

return $total;
</pre>
  <p>
    The way the sum is calculated looks exactly like what I wrote with the for statement in Perl.
  </p>
  <p>
    In this way, SPVM has one of the characteristics that it can be described in the same syntax as M<b>Perl</b>. It is designed to minimize the burden of learning the new syntax for Perl users.
  </p>
  <p>
    You can omit the type using <b>type inference</b> in the variable declaration.
  </p>
<pre>
my $total = 0;
</pre>
  <p>
    SPVM's type inference can omit the type declaration on the left side when the type on the right side is fixed.
  </p>
  <p>
    Since the numeric literal "0" is "int type", the type of "$total" is also "int type". It has the same meaning as described below.
  </p>
<pre>
my $total : int = 0;
</pre>
  <p>
    <b>Array length</b> can be obtained by using "@".
  </p>
<pre>
@$nums
</pre>
  <p>
    In SPVM, there is no context and "@" always returns the length of the array.
  </p>
  <p>
    Next, let's call a subroutine written in SPVM from the Perl side.
  <p>
  <h4>Call SPVM module</h4>
  <p>
    Create a file called "sum.pl" and describe the following contents.
  </p>
  <p>
    Call the "sum" subroutine of the "MyMath" package written in SPVM to calculate the sum of the arrays.
  </p>
<pre>
use FindBin;
use lib "$FindBin::Bin/lib";

use SPVM'MyMath';

my $sp_nums = SPVM::new_int_array([3, 6, 8, 9]);

my $total = MyMath->sum($sp_nums);

print $total ."\n";
</pre>
  <p>
    First, add the <b>lib directory to the module search path</b>.
  </p>
<pre>
# add lib directory to module search path
use FindBin;
use lib "$FindBin::Bin/lib";
</pre>
  <p>
    Then <b>load the SPVM module</b>.
  </p>
<pre>
# Load SPVM module
use SPVM'MyMath';
</pre>
  <p>
    You can load the SPVM module with the description "use SPVM'SPVM module name'".
  </p>
  <p>
    Then <b>create an array of SPVMs</b>.
  </p>
<pre>
# Int type array creation
my $sp_nums = SPVM::new_int_array([3, 6, 8, 9]);
</pre>
  <p>
    You can use the <b>SPVM::new_int_array function</b> to create a SPVM int array by passing an array reference.
  </p>
  <p>
    <b>Call the sum subroutine of the MyMath package</b>.
  </p>
<pre>
# Call the sum subroutine of the MyMath package
my $total = MyMath->sum($sp_nums);
</pre>
  <p>
    Note that <b>SPVM subroutine calls are Perl class method calls. </b>It cannot be called with the absolute name MyMath::sub.
  </p>
  
  <p>
    The return value of the sum function is "int type", but the SPVM integer type is automatically converted to the Perl scalar type.
  </p>



=head1 SYNOPSIS

SPVM Module:

<pre>
# lib/MyMath.spvm
package MyMath {
  sub sum : int ($nums : int[]) {
    
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }
    
    return $total;
  }
}
</pre>

Use SPVM Module from Perl

<pre>
# spvm.pl
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/lib";

use SPVM 'MyMath';

# Initialize SPVM
UNITCHECK { SPVM::init() }

# Call subroutine
my $total = MyMath->sum([3, 6, 8, 9]);

print "Total: $total\n";

# Call subroutine with packed data
my $nums_packed = pack('l*', 3, 6, 8, 9);
my $sv_nums = SPVM::new_int_array_from_bin($nums_packed);
my $total_packed = MyMath->sum($sv_nums);

print "Total Packed: $total_packed\n";
</pre>

Precompiled SPVM Subroutine. This means SPVM code is converted to Machine Code:

<pre>
# lib/MyMath.spvm
package MyMath {
  precompile sub sum_precompile : int ($nums : int[]) {
    
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }
    
    return $total;
  }
}
</pre>

Call SPVM Precompile Subroutine from Perl

<pre>
# spvm.pl
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/lib";

use SPVM 'MyMath';

# Initialize SPVM
UNITCHECK { SPVM::init() }

# Call precompile subroutine
my $total_precompile = MyMath->sum_precompile([3, 6, 8, 9]);

print "Total Precompile: $total_precompile\n";
</pre>

SPVM Native Subroutine. This means SPVM subroutine call C/C++ native subroutine:

<pre>
# lib/MyMath.spvm
package MyMath {
  native sub sum_native : int ($nums : int[]);
}

// lib/MyMath.c
#include "spvm_native.h"

int32_t SPNATIVE__MyMath__sum_native(SPVM_ENV* env, SPVM_VALUE* stack) {
  
  void* sv_nums = stack[0].oval;
  
  int32_t length = env->length(env, sv_nums);
  
  int32_t* nums = env->get_elems_int(env, sv_nums);
  
  int32_t total = 0;
  for (int32_t i = 0; i < length; i++) {
    total += nums[i];
  }
  
  stack[0].ival = total;
  
  return SPVM_SUCCESS;
}

# lib/MyMath.config

use strict;
use warnings;

use SPVM::Builder::Config;
my $bconf = SPVM::Builder::Config->new_c99;

$bconf;
</pre>

Use SPVM Native Subroutine from Perl

<pre>
# spvm.pl
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/lib";

use SPVM 'MyMath';

# Initialize SPVM
UNITCHECK { SPVM::init() }

# Call native subroutine
my $total_native = MyMath->sum_native([3, 6, 8, 9]);

print "Total Native: $total_native\n";
</pre>

Environment Variable "SPVM_BUILD_DIR" must be set for precompile and native subroutine

<pre>
# bash example
export SPVM_BUILD_DIR=~/.spvm_build
</pre>
