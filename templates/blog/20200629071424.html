<h2>SPVM Getting Started</h2>

Let's take SPVM for the first time. Then, let's improve the performance of the SPVM code.

<h3>First SPVM Program</h3>

Let's take SPVM for the first time. This is a first simple example. Let's calcurate the sum of numbers.

<h4>Create SPVM module</h4>

Create SPVM module. The extension is "spvm". In this example, the name of SPVM module is "MyMath.spvm".

Create "MyMath.spvm" in the "lib" directory, and you write the following code.

<pre>
# lib/MyMath.spvm
package MyMath {
  sub sum : int ($nums : int[]) {
    
    my $total = 0;
    for (my $i = 0; $i < @$nums; $i++) {
      $total += $nums->[$i];
    }
    
    return $total;
  }
}
</pre>

<h4>Package Definition</h4>

Write <b>Package Definition</b> by <b>package</b> keyword. Unlike Perl, SPVM always need package. The whole SPVM grammar is a set of packages.

<pre>
# Package Definition
package MyMath {

}
</pre>

See also <a href="/language.html#language-package">Package - SPVM Language Specification</a> about Package.

<h4>Subroutine Definition</h4>

Write <b>Subroutine Definition</b> by <b>sub</b> keyword. Unlike Perl, SPVM Subroutine Definition have return type and argument types.
  
<pre>
package MyMath {
  # Subroutine Definition
  sub sum : int ($nums : int[]) {
    
  }
}
</pre>

See also <a href="/language.html#language-sub">Subroutine - SPVM Language Specification</a> about Subroutine.

<h4>Numeric Types</h4>

<b>int</b> type in sum return value is signed 32bit integer type. This is same as C99 int32_t.

<pre>
int
</pre>

SPVM has the following types as other numeric types.

<table>
  <tr>
    <th>
      <b>SPVM numric type</b>
    </ th>
    <th>
      <b>C99 type</b>
    </ th>
  </tr>
  <tr>
    <td>
      <b>byte</b>
    </td>
    <td>
      int8_t
    </td>
  </tr>
  <tr>
    <td>
      <b>short</b>
    </td>
    <td>
      int16_t
    </td>
  </tr>
  <tr>
    <td>
      <b>int</b>
    </td>
    <td>
      int32_t
    </td>
  </tr>
  <tr>
    <td>
      <b>long</b>
    </td>
    <td>
      int64_t
    </td>
  </tr>
  <tr>
    <td>
      <b>float</b>
    </td>
    <td>
      float
    </td>
  <tr>
    <td>
      <b>double</b>
    </td>
    <td>
      double
    </td>
  </tr>
</table>

See also <a href="http://59.106.185.196:3000/spvmdoc-public/language.html#language-type">Type - SPVM Language Specification</a> about Type.

<h4>Array Types</h4>

<b>int[]</b> type in sum arguments is array of int type. 

<pre>
int[]
</pre>

The numeric array type guarantees that the values are consecutive in memory.

In this point, unlike Perl where all value are assigned to the dynamic type SV, SPVM has a static type, so it can represent a efficient sequence of numbers.

See also <a href="http://59.106.185.196:3000/spvmdoc-public/language.html#language-type">Type - SPVM Language Specification</a> about Type.

<h4>Lexical Variable Declaration</h4>

Write <b>Lexical Variable Declaration</b> by <b>my</b> keyword. You can initialize variables at the same time you declare variables.

<pre>
my $total = 0;
</pre>

The above declaration has the same meaning as:

<pre>
my $total : int = 0;
</pre>

0 on the right side is a signed 32-bit integer, so the type of the variable is automatically determined by type inference.

See also <a href="/language.html#language-lex-var">Lexical Variabe - SPVM Language Specification</a> about Lexical Variabe Declaration.

See also <a href="/language.html#language-type-inference">Type Inference - SPVM Language Specification</a> about Type Inference.

<h4>Integer Literal</h4>

0 is Integer Literal. 

<pre>
my $total : int = 0;
</pre>

SPVM has the following Literal.

<ul>
  <li>Integer Literal</li>
  <li>Floating Point Literal</li>
  <li>Charater Literal</li>
  <li>String Literal</li>
</ul>

<pre>
# Integer Literal
123
123_456_789

# Floating Point Literal
1.32
1.32f

# Character Literal
'a'
'c'

# String Literal
"Hello World!"
</pre>

See also <a href="/language.html#language-literal">Literal - SPVM Language Specification</a> about Literal.

<h4>Get Array Length</h4>

Let's look at the part where the sum of the arrays is calculated. 

<pre>
for (my $i = 0; $i < @$nums; $i++) {
  $total += $nums->[$i];
}
</pre>

See @$nums.

<pre>
@$nums
</pre>

@ is Array Length Operator to get array length.

Unlike Perl, which is context sensitive, Array Length Operator of SPVM always returns the length of the array.

Note that SPVM has no context.

See <a href="/language.html#language-operator-array-length">Array Length Operator - SPVM Language Specification</a> about Array Length Operator

<h4>Increment Operator</h4>

Incremental Operator increment the value.

<pre>
$i++
</pre>

See <a href="http://59.106.185.196:3000/spvmdoc-public/language.html#language-operator-inc">Increment Operator - SPVM Language Specification</a> about Incremental Operator.

See <a href="http://59.106.185.196:3000/spvmdoc-public/language.html#language-operator-dec">Decrement Operator - SPVM Language Specification</a> about Decrement Operator.

<h4>Array Access</h4>

Array Access can be done by "->" Arrow Operator.

<pre>
$nums->[$i]
</pre>

See <a href="http://59.106.185.196:3000/spvmdoc-public/language.html#language-array">Array - SPVM Language Specification</a> about Array operation.

<h4>Addition Operator</h4>

See the following code.

<pre>
$total += $nums->[$i];
</pre>

This is same as the following Additon Operator and Assignment Operator.

<pre>
$total = $total + $nums->[$i];
</pre>

SPVM has many operators.

See <a href="/language.html#language-operator">Operator - SPVM Language Specification</a> about Opeartor.

<h4>for Statement</h4>

Next, see for Statement.

<pre>
for (my $i = 0; $i < @$nums; $i++) {
  $total += $nums->[$i];
}
</pre>

See <a href="/language.html#language-statement-for">for Statement - SPVM Language Specification</a> about for Statement.

See <a href="/language.html#language-statement">Statement - SPVM Language Specification</a> about Statement like if Statement, while Statement, and switch Statement.

<h4>return Statement</h4>

At last, return Statement.

<pre>
return $total;
</pre>

See <a href="/language.html#language-statement-return">return Statement - SPVM Language Specification</a> about return Statement.


<h3>Call SPVM Subroutine from Perl</h3>

Create "sum.pl" file  and write the following code. This is Perl program.

<pre>
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/lib";

use SPVM 'MyMath';

# Call subroutine
my $total = MyMath->sum([3, 6, 8, 9]);

print "Total: $total\n";

# Call subroutine with packed data
my $nums_packed = pack('l*', 3, 6, 8, 9);
my $sv_nums = SPVM::new_int_array_from_bin($nums_packed);
my $total_packed = MyMath->sum($sv_nums);

print "Total Packed: $total_packed\n";
</pre>

<h4>Add library path</h4>

The followings are the conventions and add current script directry's "lib" directory to library path .
<pre>
use strict;
use warnings;
use FindBin;
use lib "$FindBin::Bin/lib";
</pre>

<h4>use SPVM module</h4>

use SPVM module.

<pre>
use SPVM 'MyMath';
</pre>

In this place, compilation is not done. Collect SPVM modules.

<h4>Call SPVM Subroutine</h4>

Call SPVM Subroutine. It's amazing that SPVM subroutine can be called as Perl subroutine.

<pre>
# Call subroutine
my $total = MyMath->sum([3, 6, 8, 9]);
</pre>

Perl array reference is converted to SPVM int array.

See <a href="/exchange-api.html#exchange-api-perl-data-to-spvm-value">Convert Perl Data to SPVM Value - SPVM Exchange API</a> about Conversion of Perl Data to SPVM Value.

SPVM int return value is converted to Perl Scalar.

See <a href="/exchange-api.html#exchange-api-spvm-value-to-perl-data">Converting SPVM Value to Perl Data - SPVM Exchange API</a> about Conversion of Perl Data to SPVM Value.

<h4>Call SPVM Subroutine with packed data</h4>

you can pass packed binary data. SPVM::new_int_array_from_bin create SPVM int array from packed binary data. This is efficient.

<pre>
# Call subroutine with packed data
my $nums_packed = pack('l*', 3, 6, 8, 9);
my $sv_nums = SPVM::new_int_array_from_bin($nums_packed);
my $total_packed = MyMath->sum($sv_nums);
</pre>

See <a href="/exchange-api.html">SPVM Exchange API</a> about SPVM Exchange API like SPVM::new_int_array_from_bin.

<h3>How to improve SPVM Performance</h2>

See How to improve SPVM Performance.

If you're searching SPVM for performance reasons, here's what you really want to see.

<ul class="toc">
  <li><a href="/blog/20200702071424.html">How to improve SPVM Performance</a></li>
</ul>
